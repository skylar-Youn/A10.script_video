<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>영상 분석기</title>

    <style>
        /* 로컬 한국어 폰트 정의 */
        @font-face {
            font-family: 'Noto Sans KR Local';
            src: url('/static/fonts/NotoSansKR-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        /* 로컬 일본어 폰트 정의 */
        @font-face {
            font-family: 'Noto Sans JP Local';
            src: url('/static/fonts/NotoSansJP-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        /* 전체 페이지에 기본 폰트 적용 */
        body, * {
            font-family: 'Noto Sans KR Local', 'Noto Sans JP Local', '맑은 고딕', 'Malgun Gothic', Arial, 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', sans-serif !important;
        }

        /* 비디오 오버레이 텍스트에 폰트 강제 적용 */
        #video-container .video-title-overlay,
        #video-container .video-subtitle-overlay,
        #video-container .custom-subtitle-overlay {
            font-family: 'Noto Sans KR Local', 'Noto Sans JP Local', '맑은 고딕', 'Malgun Gothic', Arial, 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', sans-serif;
        }
    </style>

    <link rel="stylesheet" href="/static/style.css">
    <style>
        /* 타임라인 에디터 스타일 */
        .timeline-editor {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .playback-controls {
            display: flex;
            gap: 8px;
        }

        .playback-controls button,
        .zoom-controls button {
            background: #2d3748;
            border: 1px solid #4a5568;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            color: #e2e8f0;
            font-size: 16px;
            transition: all 0.2s;
        }

        .playback-controls button:hover,
        .zoom-controls button:hover {
            background: #4a5568;
            transform: scale(1.05);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-controls label {
            color: #a0aec0;
            font-size: 14px;
        }

        .zoom-controls input[type="range"] {
            width: 150px;
        }

        #zoom-display {
            color: #e2e8f0;
            font-weight: bold;
            min-width: 40px;
        }

        .time-display {
            display: flex;
            gap: 5px;
            align-items: center;
            color: #e2e8f0;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
        }

        .timeline-container {
            overflow-x: auto;
            overflow-y: hidden;
            border: 1px solid #2d3748;
            border-radius: 6px;
            background: #16213e;
            position: relative;
            max-width: 100%;  /* 부모 컨테이너에 맞춤 */
        }

        .timeline-content {
            position: relative;
            min-height: 300px;  /* 높이 줄임 */
            width: max-content;  /* 내용물 크기에 맞춰 늘어남 */
            min-width: 100%;  /* 최소 너비는 컨테이너 너비 */
        }

        .timeline-ruler {
            display: flex;  /* 수평 레이아웃 */
            height: 30px;
            background: #0f172a;
            border-bottom: 2px solid #2d3748;
        }

        .timeline-ruler-header {
            width: 180px;  /* 트랙 헤더와 동일한 너비 */
            flex-shrink: 0;
            background: #0f172a;
            border-right: 1px solid #334155;
        }

        .timeline-ruler-content {
            flex: 1;
            position: relative;
            background: #0f172a;
        }

        .time-marker {
            position: absolute;
            top: 0;
            color: #94a3b8;
            font-size: 11px;
            padding: 5px;
            border-left: 1px solid #334155;
        }

        .time-marker.major {
            color: #e2e8f0;
            font-weight: bold;
            border-left: 2px solid #475569;
        }

        .time-marker.zero-marker {
            border-left: 3px solid #ef4444;
        }

        /* 재생 헤드 */
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 1000;
            pointer-events: none;
            transition: left 0.1s linear;
        }

        .playhead::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-top: 8px solid #ef4444;
        }

        .playhead-time {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #ef4444;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .timeline-track {
            border-bottom: 1px solid #2d3748;
            height: 50px;  /* 고정 높이 */
            position: relative;
            display: flex;  /* 수평 레이아웃 */
        }

        .track-header {
            display: flex;
            flex-direction: row;  /* 가로 배치 */
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #1e293b;
            border-right: 1px solid #334155;  /* 오른쪽 경계선 */
            width: 180px;  /* 고정 너비 */
            flex-shrink: 0;  /* 축소 방지 */
            gap: 8px;
        }

        .track-header label {
            color: #e2e8f0;
            font-size: 14px;
            font-weight: 500;
        }

        .track-title {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .track-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .track-controls button {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .track-controls button:hover {
            opacity: 1;
        }

        .audio-edit-toolbar {
            display: none;  /* 편집 툴바 숨김 */
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 6px;
            padding: 6px 10px;
            margin: 6px 12px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .audio-edit-toolbar .audio-selection-info {
            color: #f8fafc;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .audio-edit-toolbar .audio-edit-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .audio-action-btn {
            background: rgba(37, 99, 235, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #bfdbfe;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .audio-action-btn:hover:not(:disabled) {
            background: rgba(59, 130, 246, 0.25);
            transform: translateY(-1px);
        }

        .audio-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .audio-selection-marker {
            position: absolute;
            top: -6px;
            width: 2px;
            height: calc(100% + 12px);
            background: #f97316;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(249, 115, 22, 0.6);
            z-index: 5;
        }

        .track-content {
            height: 100%;  /* 부모 높이에 맞춤 */
            position: relative;
            background: rgba(255, 255, 255, 0.02);
            flex: 1;  /* 남은 공간 채우기 */
            overflow: visible;  /* 캔버스가 컨테이너 밖으로 표시되도록 허용 */
        }

        .track-content canvas {
            width: auto;  /* JavaScript에서 설정한 너비 사용 */
            display: block;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 100;
            pointer-events: none;
        }

        .playhead::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #ef4444;
        }
    </style>
    <!-- JSZip library for ZIP file creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>영상 분석기</h1>
        <nav class="nav-links">
            <a href="/ytdl" class="nav-link">⬇️ 다운로드 도구</a>
            <a href="/text-removal" class="nav-link">🧽 영상에서 글자 지우기</a>
            <a href="/video-analyzer" class="nav-link {% if nav_active == 'video_analyzer' %}active{% endif %}">📹 영상 분석기</a>
            <a href="/analysis" class="nav-link">📊 영상메이커</a>
            <a href="/" class="nav-link">🏠 AI 쇼츠 메이커</a>
            <a href="/similarity" class="nav-link">🎞️ 영상 유사도 검사</a>
            <a href="/copyright" class="nav-link">🛡️ 저작권 검사</a>
        </nav>
    </header>

    <section class="panel">
        <h2>다운로드한 영상 자막 가져오기</h2>
        <p class="panel-sub">로컬에 저장된 영상 파일에서 자막을 추출하거나, 함께 다운로드된 자막 파일(.srt, .vtt 등)을 불러옵니다.</p>

        <form method="post" action="/video-analyzer" enctype="multipart/form-data" class="analyzer-form">
            <div class="field">
                <label for="video_file">영상 파일 선택</label>
                <input type="file" id="video_file" name="video_file" accept="video/*">
                <span class="hint-text">또는 아래 영상폴더에서 파일을 선택하세요.</span>
            </div>

            <div class="field">
                <label for="video_path">영상 파일 또는 폴더 경로</label>
                <input type="text" id="video_path" name="video_path" value="{{ form_values.video_path }}" placeholder="/path/to/videos 또는 /path/to/video.mp4">
                <span class="hint-text">📁 폴더 경로 또는 📹 영상 파일 경로를 입력하세요. 영상 미리보기에서 선택 시 자동으로 입력됩니다.</span>
            </div>

            <div class="field">
                <label for="subtitle_file">자막 파일 선택 (선택사항)</label>
                <input type="file" id="subtitle_file" name="subtitle_file" accept=".srt,.vtt,.ass,.ssa,.sub">
                <span class="hint-text">자막 파일이 있다면 업로드하세요. 없으면 자동으로 찾습니다.</span>
            </div>

            <div class="field inline">
                <label for="search_directory">자막 검색 폴더</label>
                <input type="text" id="search_directory" name="search_directory" value="{{ form_values.search_directory }}" placeholder="자막 파일이 있는 폴더">
                <label><input type="checkbox" name="auto_search" {% if form_values.auto_search %}checked{% endif %}> 자동 검색</label>
            </div>

            <button type="submit">자막 불러오기</button>
        </form>
    </section>

    <!-- AI 분석 빠른 접근 버튼 -->
    <section class="panel" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: 2px solid rgba(102, 126, 234, 0.5);">
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px;">
            <button onclick="scrollToFrameAnalysis()" class="btn-primary" style="padding: 15px 30px; font-size: 1.1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: 2px solid rgba(255, 255, 255, 0.3); box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);">
                🤖 AI 프레임 분석
            </button>
            <button onclick="scrollToSubtitleAnalysis()" class="btn-primary" style="padding: 15px 30px; font-size: 1.1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: 2px solid rgba(255, 255, 255, 0.3); box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);">
                🤖 AI 자막 분석
            </button>
        </div>
        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;">
            <button onclick="clearFrameAnalysisContent()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #ef4444; border: 1px solid rgba(255, 255, 255, 0.3);">
                🗑️ 프레임 분석 내용 비우기
            </button>
            <button onclick="clearSubtitleAnalysisContent()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #ef4444; border: 1px solid rgba(255, 255, 255, 0.3);">
                🗑️ 자막 분석 내용 비우기
            </button>
        </div>
        <p style="text-align: center; color: rgba(255, 255, 255, 0.8); margin-top: 10px; margin-bottom: 0; font-size: 0.9rem;">
            💡 버튼을 클릭하면 해당 AI 분석 섹션으로 이동합니다
        </p>
    </section>

    <section class="panel">
        <h2>영상 파일 목록</h2>
        <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
            <button type="button" onclick="loadVideoFilesFromFolder()" class="btn-primary" style="padding: 8px 16px;">📁 폴더 내용 불러오기</button>
            <button type="button" id="merge-videos-btn" onclick="mergeSelectedVideos()" class="btn-secondary" style="padding: 8px 16px; background: #10b981; display: none;">🎬 선택된 영상 합치기 (<span id="selected-count">0</span>개)</button>
            <span id="folder-status" style="color: #a0aec0; font-size: 0.9rem;"></span>
        </div>
        <div id="video-list-container">
            <div class="empty-state">영상폴더 경로를 입력하고 '폴더 내용 불러오기' 버튼을 클릭하세요.</div>
        </div>
    </section>

    <!-- 영상 미리보기 섹션 -->
    <section class="panel" id="video-preview-section" style="display: none;">
        <h2>영상 미리보기</h2>

        <!-- 텍스트 오버레이 컨트롤 패널 -->
        <div class="text-overlay-controls" style="margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; border: 2px solid rgba(102, 126, 234, 0.5);">
            <h3 style="margin: 0 0 15px 0; color: white;">🎨 텍스트 오버레이</h3>

            <!-- AI 제목/부제목 생성 버튼 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <div style="flex: 1;">
                        <label style="display: block; color: white; margin-bottom: 5px; font-size: 0.9rem;">🤖 AI 모델 선택</label>
                        <select id="ai-model-select" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a; font-size: 14px; cursor: pointer;">
                            <option value="claude">Claude 3.5 Sonnet (Anthropic)</option>
                            <option value="gpt">GPT-4o Mini (OpenAI)</option>
                        </select>
                    </div>
                </div>
                <button onclick="generateAITitleSubtitle()" class="btn-primary" style="padding: 10px 20px; width: 100%; background: linear-gradient(135deg, #FF6B6B 0%, #FFE66D 100%); color: #1a1a1a; font-weight: bold; font-size: 16px; border: none; border-radius: 6px; cursor: pointer; transition: transform 0.2s;">
                    🤖 AI 제목 & 부제목 만들기
                </button>
                <div id="ai-generation-status" style="margin-top: 8px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; color: #94a3b8; font-size: 0.85rem; text-align: center; display: none;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <div class="spinner" style="width: 16px; height: 16px; border: 2px solid rgba(255, 255, 255, 0.3); border-top-color: #60a5fa; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <span id="ai-status-text">⏳ AI가 제목과 부제목을 생성하고 있습니다...</span>
                    </div>
                    <div id="ai-status-timer" style="margin-top: 5px; font-size: 0.75rem; color: #64748b;"></div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            </div>

            <!-- 제목 컨트롤 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                    <label style="color: white; font-weight: bold; margin: 0;">📝 제목</label>
                    <input type="checkbox" id="hide-title-overlay" style="cursor: pointer;" />
                    <label for="hide-title-overlay" style="cursor: pointer; color: #94a3b8; font-size: 0.85rem; margin: 0;" title="체크하면 출처 오버레이를 숨깁니다">🙈 화면에서 숨기기</label>
                </div>
                <input type="text" id="overlay-title-input" placeholder="영상 제목을 입력하세요"
                       style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; margin-bottom: 8px; color: #1a1a1a;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">크기: <span id="title-size-display">48px</span></label>
                        <input type="range" id="overlay-title-size" min="24" max="120" value="48" step="2"
                               style="width: 100%;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">색상</label>
                        <input type="color" id="overlay-title-color" value="#ffffff"
                               style="width: 100%; height: 36px; border: none; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">정적 효과</label>
                        <select id="overlay-title-static-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none">없음</option>
                            <option value="outline" selected>외곽선</option>
                            <option value="shadow">그림자</option>
                            <option value="glow">글로우</option>
                            <option value="gradient">그라데이션</option>
                            <option value="neon">네온</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">동적 효과</label>
                        <select id="overlay-title-dynamic-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none" selected>없음</option>
                            <option value="fade">✨ 페이드</option>
                            <option value="slide-in">➡️ 슬라이드 인</option>
                            <option value="slide-up">⬆️ 슬라이드 업</option>
                            <option value="bounce">⬇️ 바운스</option>
                            <option value="scale">🔍 스케일</option>
                            <option value="glow">💫 글로우</option>
                            <option value="pulse">💓 펄스</option>
                        </select>
                    </div>
                </div>
                <button onclick="applyTitle()" class="btn-primary" style="margin-top: 10px; padding: 8px 16px; width: 100%; background: #10b981;">✅ 제목 적용</button>
            </div>

            <!-- 부제목 컨트롤 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                    <label style="color: white; font-weight: bold; margin: 0;">📋 부제목</label>
                    <input type="checkbox" id="hide-subtitle-overlay" style="cursor: pointer;" />
                    <label for="hide-subtitle-overlay" style="cursor: pointer; color: #94a3b8; font-size: 0.85rem; margin: 0;" title="체크하면 출처 오버레이를 숨깁니다">🙈 화면에서 숨기기</label>
                </div>
                <input type="text" id="overlay-subtitle-input" placeholder="부제목을 입력하세요"
                       style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; margin-bottom: 8px; color: #1a1a1a;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">크기: <span id="subtitle-size-display">32px</span></label>
                        <input type="range" id="overlay-subtitle-size" min="20" max="96" value="32" step="2"
                               style="width: 100%;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">색상</label>
                        <input type="color" id="overlay-subtitle-color" value="#ffe14d"
                               style="width: 100%; height: 36px; border: none; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">정적 효과</label>
                        <select id="overlay-subtitle-static-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none">없음</option>
                            <option value="outline" selected>외곽선</option>
                            <option value="shadow">그림자</option>
                            <option value="glow">글로우</option>
                            <option value="gradient">그라데이션</option>
                            <option value="neon">네온</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">동적 효과</label>
                        <select id="overlay-subtitle-dynamic-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none" selected>없음</option>
                            <option value="fade">✨ 페이드</option>
                            <option value="slide-in">➡️ 슬라이드 인</option>
                            <option value="slide-down">⬇️ 슬라이드 다운</option>
                            <option value="slide-up">⬆️ 슬라이드 업</option>
                            <option value="bounce">⬇️ 바운스</option>
                            <option value="scale">🔍 스케일</option>
                            <option value="glow">💫 글로우</option>
                            <option value="pulse">💓 펄스</option>
                        </select>
                    </div>
                </div>
                <button onclick="applySubtitle()" class="btn-primary" style="margin-top: 10px; padding: 8px 16px; width: 100%; background: #10b981;">✅ 부제목 적용</button>
            </div>

            <!-- 출처 표시 컨트롤 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                    <label style="color: white; font-weight: bold; margin: 0;">🔗 출처 표시</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="source-overlay-hide" style="cursor: pointer; width: 16px; height: 16px;">
                        <label for="source-overlay-hide" style="cursor: pointer; color: #94a3b8; font-size: 0.85rem; margin: 0;" title="체크하면 출처 오버레이를 숨깁니다">🙈 화면에서 숨기기</label>
                    </div>
                </div>
                <input type="text" id="overlay-source-input" placeholder="출처를 입력하세요 (예: 출처: YouTube)"
                       style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; margin-bottom: 8px; color: #1a1a1a;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">크기: <span id="source-size-display">18px</span></label>
                        <input type="range" id="overlay-source-size" min="12" max="48" value="18" step="2"
                               style="width: 100%;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">색상</label>
                        <input type="color" id="overlay-source-color" value="#cccccc"
                               style="width: 100%; height: 36px; border: none; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">X 위치 (%)</label>
                        <input type="number" id="overlay-source-x" min="0" max="100" value="50"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">Y 위치 (%)</label>
                        <input type="number" id="overlay-source-y" min="0" max="100" value="95"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">정적 효과</label>
                        <select id="overlay-source-static-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none">없음</option>
                            <option value="outline" selected>외곽선</option>
                            <option value="shadow">그림자</option>
                            <option value="glow">글로우</option>
                            <option value="gradient">그라데이션</option>
                            <option value="neon">네온</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">동적 효과</label>
                        <select id="overlay-source-dynamic-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none" selected>없음</option>
                            <option value="fade">✨ 페이드</option>
                            <option value="slide-in">➡️ 슬라이드 인</option>
                            <option value="slide-up">⬆️ 슬라이드 업</option>
                            <option value="bounce">⬇️ 바운스</option>
                            <option value="scale">🔍 스케일</option>
                            <option value="glow">💫 글로우</option>
                            <option value="pulse">💓 펄스</option>
                        </select>
                    </div>
                </div>
                <button onclick="applySource()" class="btn-primary" style="margin-top: 10px; padding: 8px 16px; width: 100%; background: #10b981;">✅ 출처 적용</button>
            </div>

            <!-- 메인 자막 컨트롤 (일본어) -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <label style="display: block; color: white; margin-bottom: 8px; font-weight: bold;">🎌 메인 자막 (일본어)</label>
                <textarea id="overlay-japanese-input" placeholder="メイン字幕を入力してください" rows="2"
                       style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; margin-bottom: 8px; font-family: 'Noto Sans JP', 'Yu Gothic', Meiryo, sans-serif; resize: vertical; color: #1a1a1a;"></textarea>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">크기: <span id="japanese-size-display">50px</span></label>
                        <input type="range" id="overlay-japanese-size" min="18" max="96" value="50" step="2"
                               style="width: 100%;"
                               oninput="document.getElementById('japanese-size-display').textContent = this.value + 'px'">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">색상</label>
                        <input type="color" id="overlay-japanese-color" value="#000000"
                               style="width: 100%; height: 36px; border: none; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">X 위치 (%)</label>
                        <input type="number" id="overlay-japanese-x" min="0" max="100" value="50"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">Y 위치 (%)</label>
                        <input type="number" id="overlay-japanese-y" min="0" max="100" value="73"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">정적 효과</label>
                        <select id="overlay-japanese-static-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none">없음</option>
                            <option value="outline" selected>외곽선</option>
                            <option value="shadow">그림자</option>
                            <option value="glow">글로우</option>
                            <option value="gradient">그라데이션</option>
                            <option value="neon">네온</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">동적 효과</label>
                        <select id="overlay-japanese-dynamic-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none" selected>없음</option>
                            <option value="fade">✨ 페이드</option>
                            <option value="slide-in">➡️ 슬라이드 인</option>
                            <option value="slide-up">⬆️ 슬라이드 업</option>
                            <option value="bounce">⬇️ 바운스</option>
                            <option value="scale">🔍 스케일</option>
                            <option value="glow">💫 글로우</option>
                            <option value="pulse">💓 펄스</option>
                        </select>
                    </div>
                </div>
                <button onclick="applyJapaneseSubtitle()" class="btn-primary" style="margin-top: 10px; padding: 8px 16px; width: 100%; background: #10b981;">✅ 메인 자막 적용</button>
            </div>

            <!-- 주 자막 컨트롤 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <label style="display: block; color: white; margin-bottom: 8px; font-weight: bold;">📝 주 자막</label>
                <textarea id="overlay-korean-input" placeholder="주 자막을 입력하세요" rows="2"
                       style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; margin-bottom: 8px; font-family: 'Nanum Gothic', sans-serif; resize: vertical; color: #1a1a1a;"></textarea>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">크기: <span id="korean-size-display">50px</span></label>
                        <input type="range" id="overlay-korean-size" min="18" max="96" value="50" step="2"
                               style="width: 100%;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">색상</label>
                        <input type="color" id="overlay-korean-color" value="#ffffff"
                               style="width: 100%; height: 36px; border: none; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">X 위치 (%)</label>
                        <input type="number" id="overlay-korean-x" min="0" max="100" value="50"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">Y 위치 (%)</label>
                        <input type="number" id="overlay-korean-y" min="0" max="100" value="65"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">정적 효과</label>
                        <select id="overlay-korean-static-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none">없음</option>
                            <option value="outline" selected>외곽선</option>
                            <option value="shadow">그림자</option>
                            <option value="glow">글로우</option>
                            <option value="gradient">그라데이션</option>
                            <option value="neon">네온</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">동적 효과</label>
                        <select id="overlay-korean-dynamic-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none" selected>없음</option>
                            <option value="fade">✨ 페이드</option>
                            <option value="slide-in">➡️ 슬라이드 인</option>
                            <option value="slide-up">⬆️ 슬라이드 업</option>
                            <option value="bounce">⬇️ 바운스</option>
                            <option value="scale">🔍 스케일</option>
                            <option value="glow">💫 글로우</option>
                            <option value="pulse">💓 펄스</option>
                        </select>
                    </div>
                </div>
                <button onclick="applyKoreanSubtitle()" class="btn-primary" style="margin-top: 10px; padding: 8px 16px; width: 100%; background: #10b981;">✅ 주 자막 적용</button>
            </div>

            <!-- 보조 자막 컨트롤 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <label style="display: block; color: white; margin-bottom: 8px; font-weight: bold;">📋 보조 자막</label>
                <textarea id="overlay-english-input" placeholder="보조 자막을 입력하세요" rows="2"
                       style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; margin-bottom: 8px; resize: vertical; color: #1a1a1a;"></textarea>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">크기: <span id="english-size-display">50px</span></label>
                        <input type="range" id="overlay-english-size" min="18" max="96" value="50" step="2"
                               style="width: 100%;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">색상</label>
                        <input type="color" id="overlay-english-color" value="#ffe14d"
                               style="width: 100%; height: 36px; border: none; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">X 위치 (%)</label>
                        <input type="number" id="overlay-english-x" min="0" max="100" value="50"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">Y 위치 (%)</label>
                        <input type="number" id="overlay-english-y" min="0" max="100" value="95"
                               style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">정적 효과</label>
                        <select id="overlay-english-static-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none">없음</option>
                            <option value="outline" selected>외곽선</option>
                            <option value="shadow">그림자</option>
                            <option value="glow">글로우</option>
                            <option value="gradient">그라데이션</option>
                            <option value="neon">네온</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">동적 효과</label>
                        <select id="overlay-english-dynamic-effect"
                                style="width: 100%; padding: 6px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 4px; color: #1a1a1a;">
                            <option value="none" selected>없음</option>
                            <option value="fade">✨ 페이드</option>
                            <option value="slide-in">➡️ 슬라이드 인</option>
                            <option value="slide-up">⬆️ 슬라이드 업</option>
                            <option value="bounce">⬇️ 바운스</option>
                            <option value="scale">🔍 스케일</option>
                            <option value="glow">💫 글로우</option>
                            <option value="pulse">💓 펄스</option>
                        </select>
                    </div>
                </div>
                <button onclick="applyEnglishSubtitle()" class="btn-primary" style="margin-top: 10px; padding: 8px 16px; width: 100%; background: #10b981;">✅ 보조 자막 적용</button>
            </div>

            <!-- 검정 배경 컨트롤 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <label style="display: block; color: white; margin-bottom: 8px; font-weight: bold;">⬛ 검정 배경</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <!-- 상단 배경 -->
                    <div style="padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                        <div style="display: flex; align-items: center; margin-bottom: 8px;">
                            <input type="checkbox" id="top-bar-enable" onchange="toggleBlackBar('top')" style="margin-right: 8px;">
                            <label style="color: white; font-weight: bold; margin: 0;">⬆️ 상단 배경</label>
                        </div>
                        <div>
                            <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">높이: <span id="top-bar-height-display">15%</span></label>
                            <input type="range" id="top-bar-height" min="5" max="40" value="15" step="1" oninput="updateBlackBar('top')" style="width: 100%;">
                        </div>
                        <div style="margin-top: 8px;">
                            <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">투명도: <span id="top-bar-opacity-display">80%</span></label>
                            <input type="range" id="top-bar-opacity" min="0" max="100" value="80" step="5" oninput="updateBlackBar('top')" style="width: 100%;">
                        </div>
                    </div>

                    <!-- 하단 배경 -->
                    <div style="padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                        <div style="display: flex; align-items: center; margin-bottom: 8px;">
                            <input type="checkbox" id="bottom-bar-enable" onchange="toggleBlackBar('bottom')" style="margin-right: 8px;">
                            <label style="color: white; font-weight: bold; margin: 0;">⬇️ 하단 배경</label>
                        </div>
                        <div>
                            <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">높이: <span id="bottom-bar-height-display">15%</span></label>
                            <input type="range" id="bottom-bar-height" min="5" max="40" value="15" step="1" oninput="updateBlackBar('bottom')" style="width: 100%;">
                        </div>
                        <div style="margin-top: 8px;">
                            <label style="color: #1a1a1a; font-size: 0.9rem; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 3px; display: inline-block; margin-bottom: 4px;">투명도: <span id="bottom-bar-opacity-display">80%</span></label>
                            <input type="range" id="bottom-bar-opacity" min="0" max="100" value="80" step="5" oninput="updateBlackBar('bottom')" style="width: 100%;">
                        </div>
                    </div>
                </div>
            </div>

            <!-- 현재 설정 상태 표시 -->
            <div id="current-settings-status" style="margin-bottom: 10px; padding: 10px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid #3b82f6;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                    <span style="font-weight: bold; color: #3b82f6;">📊 현재 적용 중인 설정</span>
                </div>
                <div id="settings-info" style="font-size: 0.85rem; color: #1e293b;">
                    <span id="saved-settings-name">기본 설정</span> |
                    <span id="saved-settings-time">미저장</span>
                </div>
            </div>

            <!-- 해상도 선택 -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                <label style="display: block; color: white; margin-bottom: 8px; font-weight: bold;">📐 미리보기 해상도</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="setPreviewResolution('youtube')" id="btn-youtube-res" class="btn-primary" style="padding: 10px 20px; background: #3b82f6; font-size: 0.95rem;">
                        📺 유튜브 (16:9)<br>
                        <span style="font-size: 0.8rem; opacity: 0.8;">1920×1080</span>
                    </button>
                    <button onclick="setPreviewResolution('shorts')" id="btn-shorts-res" class="btn-primary" style="padding: 10px 20px; background: #8b5cf6; font-size: 0.95rem;">
                        📱 쇼츠 (9:16)<br>
                        <span style="font-size: 0.8rem; opacity: 0.8;">1080×1920</span>
                    </button>
                    <button onclick="setPreviewResolution('4k')" id="btn-4k-res" class="btn-primary" style="padding: 10px 20px; background: #10b981; font-size: 0.95rem;">
                        🎬 4K (16:9)<br>
                        <span style="font-size: 0.8rem; opacity: 0.8;">3840×2160</span>
                    </button>
                    <button onclick="setPreviewResolution('custom')" id="btn-custom-res" class="btn-secondary" style="padding: 10px 20px; font-size: 0.95rem;">
                        ⚙️ 커스텀<br>
                        <span style="font-size: 0.8rem; opacity: 0.8;">직접 입력</span>
                    </button>
                </div>
                <div id="custom-resolution-input" style="display: none; margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <div>
                            <label style="color: white; font-size: 0.9rem; display: block; margin-bottom: 4px;">너비</label>
                            <input type="number" id="custom-width" value="1920" min="320" max="7680" style="width: 100px; padding: 6px; border-radius: 4px; border: 1px solid #4a5568; background: #2d3748; color: white;">
                        </div>
                        <div>
                            <label style="color: white; font-size: 0.9rem; display: block; margin-bottom: 4px;">높이</label>
                            <input type="number" id="custom-height" value="1080" min="240" max="4320" style="width: 100px; padding: 6px; border-radius: 4px; border: 1px solid #4a5568; background: #2d3748; color: white;">
                        </div>
                        <button onclick="applyCustomResolution()" class="btn-primary" style="padding: 8px 16px; margin-top: 20px; background: #10b981;">✅ 적용</button>
                    </div>
                </div>
                <div id="current-resolution-display" style="margin-top: 8px; color: #a0aec0; font-size: 0.85rem;">
                    현재: <span id="current-res-text">1920×1080 (16:9)</span>
                </div>
            </div>

            <!-- 저장/불러오기 버튼 -->
            <div style="display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;">
                <button onclick="saveTextOverlaySettings()" class="btn-primary" style="padding: 8px 16px; background: #10b981;">💾 설정 저장</button>
                <button onclick="saveTextOverlaySettingsAs()" class="btn-primary" style="padding: 8px 16px; background: #059669;">💾 다른 이름으로 저장</button>
                <button onclick="loadTextOverlaySettings()" class="btn-secondary" style="padding: 8px 16px; background: #3b82f6;">📂 설정 불러오기</button>
                <button onclick="browseSettingsFile()" class="btn-secondary" style="padding: 8px 16px; background: #6366f1;">🔍 파일에서 불러오기</button>
                <button onclick="clearTextOverlay()" class="btn-secondary" style="padding: 8px 16px; background: #ef4444;">🗑️ 텍스트 지우기</button>
            </div>
        </div>

        <div class="video-preview-container" style="position: relative; display: inline-block;">
            <!-- 비디오 플레이어 Wrapper -->
            <div class="video-subtitle-wrapper" style="position: relative; display: inline-block;">
                <!-- Canvas 미리보기 (FFmpeg와 동일한 렌더링) -->
                <canvas id="video-canvas-preview"
                        style="width: 100%; max-width: 800px; border-radius: 8px; display: none; position: absolute; top: 0; left: 0; z-index: 100; cursor: default;">
                </canvas>

                <!-- 기존 비디오 플레이어 (숨김 처리) -->
                <video id="video-preview-player" controls crossorigin="anonymous"
                       style="width: 100%; max-width: 800px; border-radius: 8px; display: block;">
                    <source id="video-preview-source" src="" type="video/mp4">
                    <track id="video-subtitle-track" kind="subtitles" src="" srclang="ko" label="한국어 (원본)">
                    <track id="video-translation-track" kind="subtitles" src="" srclang="en" label="주자막">
                    브라우저가 비디오 태그를 지원하지 않습니다.
                </video>

                <!-- 상단 검정 배경 -->
                <div id="top-black-bar" style="position: absolute; top: 0; left: 0; width: 100%; height: 15%; background: rgba(0, 0, 0, 0.8); z-index: 5; display: none; pointer-events: none;"></div>

                <!-- 하단 검정 배경 -->
                <div id="bottom-black-bar" style="position: absolute; bottom: 0; left: 0; width: 100%; height: 15%; background: rgba(0, 0, 0, 0.8); z-index: 5; display: none; pointer-events: none;"></div>

                <!-- 텍스트 오버레이들 -->
                <div class="video-title-overlay video-text-overlay" id="video-title-overlay"
                     style="position: absolute; top: 80%; left: 50%; transform: translateX(-50%);
                            color: white; font-size: 48px; font-weight: bold;
                            font-family: '맑은 고딕', 'Malgun Gothic', 'Apple SD Gothic Neo', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', Meiryo, 'Noto Sans KR', 'Noto Sans JP', sans-serif;
                            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                            cursor: move; user-select: none; z-index: 10;
                            pointer-events: auto; display: block; opacity: 1;
                            white-space: nowrap;">
                    영상 제목을 입력하세요
                </div>

                <div class="video-subtitle-overlay video-text-overlay" id="video-subtitle-overlay"
                     style="position: absolute; top: 90%; left: 50%; transform: translateX(-50%);
                            color: #ffe14d; font-size: 32px; font-weight: bold;
                            font-family: '맑은 고딕', 'Malgun Gothic', 'Apple SD Gothic Neo', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', Meiryo, 'Noto Sans KR', 'Noto Sans JP', sans-serif;
                            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                            cursor: move; user-select: none; z-index: 9;
                            pointer-events: auto; display: block; opacity: 1;
                            white-space: nowrap;">
                    부제목을 입력하세요
                </div>

                <!-- 한글 자막 오버레이 (주 자막) -->
                <div class="custom-subtitle-overlay" id="korean-subtitle-overlay" data-lang="korean"
                     style="position: absolute; top: 65%; left: 50%; transform: translateX(-50%);
                            color: #000000; font-size: 32px; font-weight: bold;
                            text-shadow: -0.04em -0.04em 0 #fff, 0.04em -0.04em 0 #fff, -0.04em 0.04em 0 #fff, 0.04em 0.04em 0 #fff, -0.06em 0 0 #fff, 0.06em 0 0 #fff, 0 -0.06em 0 #fff, 0 0.06em 0 #fff;
                            cursor: move; user-select: none; z-index: 8;
                            pointer-events: auto; display: none; padding: 8px 16px;
                            background: rgba(255, 255, 255, 0.2); border-radius: 4px; opacity: 1;
                            white-space: nowrap;">
                </div>

                <!-- 일본어 자막 오버레이 (메인 자막) -->
                <div class="custom-subtitle-overlay" id="japanese-subtitle-overlay" data-lang="japanese"
                     style="position: absolute; top: 73%; left: 50%; transform: translateX(-50%);
                            color: #000000; font-size: 30px; font-weight: bold;
                            text-shadow: -0.04em -0.04em 0 #fff, 0.04em -0.04em 0 #fff, -0.04em 0.04em 0 #fff, 0.04em 0.04em 0 #fff, -0.06em 0 0 #fff, 0.06em 0 0 #fff, 0 -0.06em 0 #fff, 0 0.06em 0 #fff;
                            cursor: move; user-select: none; z-index: 7;
                            pointer-events: auto; display: none; padding: 8px 16px;
                            background: rgba(255, 255, 255, 0.2); border-radius: 4px; opacity: 1;
                            white-space: nowrap;">
                </div>

                <!-- 영어 자막 오버레이 (보조 자막) -->
                <div class="custom-subtitle-overlay" id="english-subtitle-overlay" data-lang="english"
                     style="position: absolute; top: 95%; left: 50%; transform: translateX(-50%);
                            color: #000000; font-size: 28px; font-weight: bold;
                            text-shadow: -0.04em -0.04em 0 #fff, 0.04em -0.04em 0 #fff, -0.04em 0.04em 0 #fff, 0.04em 0.04em 0 #fff, -0.06em 0 0 #fff, 0.06em 0 0 #fff, 0 -0.06em 0 #fff, 0 0.06em 0 #fff;
                            cursor: move; user-select: none; z-index: 6;
                            pointer-events: auto; display: none; padding: 8px 16px;
                            background: rgba(255, 255, 255, 0.2); border-radius: 4px; opacity: 1;
                            white-space: nowrap;">
                </div>

                <!-- 출처 표시 오버레이 -->
                <div class="custom-subtitle-overlay" id="source-overlay" data-lang="source"
                     style="position: absolute; top: 98%; left: 50%; transform: translateX(-50%);
                            color: #cccccc; font-size: 18px; font-weight: normal;
                            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
                            cursor: move; user-select: none; z-index: 6;
                            pointer-events: auto; display: block; padding: 4px 12px;
                            background: rgba(0, 0, 0, 0.1); border-radius: 4px; opacity: 0.5;
                            white-space: nowrap;">
                    출처를 입력하세요
                </div>
            </div>
            <div class="video-preview-info" style="margin-top: 15px;">
                <p><strong>파일명:</strong> <span id="preview-filename"></span></p>
                <p><strong>경로:</strong> <span id="preview-filepath"></span></p>
            </div>

            <!-- 타임라인 에디터 -->
            <div class="timeline-editor" style="margin-top: 20px;">
                <div class="timeline-controls">
                    <div class="playback-controls">
                        <button id="play-pause-btn" style="display: flex; opacity: 1; visibility: visible;">▶️</button>
                        <button id="stop-btn">⏹️</button>
                        <button id="rewind-btn">⏪</button>
                        <button id="forward-btn">⏩</button>
                        <button id="skip-to-start-btn" title="맨 처음으로">⏮️</button>
                        <button id="skip-to-end-btn" title="맨 끝으로">⏭️</button>
                        <button id="playback-speed-btn" title="재생 속도">1.0x</button>
                        <button id="set-point-a-btn" title="A 지점 설정 (현재 위치)">🅰️ A점</button>
                        <button id="set-point-b-btn" title="B 지점 설정 (현재 위치)">🅱️ B점</button>
                        <button id="toggle-ab-repeat-btn" title="A-B 구간 반복" style="background: #4a5568;">🔁 OFF</button>
                    </div>

                    <div class="zoom-controls">
                        <label>🔍 타임라인 확대/축소:</label>
                        <input type="range" id="timeline-zoom" min="1" max="20" value="1" step="0.5">
                        <span id="zoom-display">1x</span>
                        <button id="fit-to-subtitles">📝 자막에 맞춤</button>
                    </div>

                    <div class="time-display">
                        <span id="current-time">0:00</span> / <span id="total-time">5:00</span>
                    </div>
                </div>

                <!-- 스크롤 가능한 타임라인 컨테이너 -->
                <div class="timeline-container" id="timeline-container">
                    <div class="timeline-content" id="timeline-content">
                        <!-- 재생 헤드 -->
                        <div class="playhead" id="playhead" style="left: 0px; display: none;">
                            <div class="playhead-time" id="playhead-time">0:00</div>
                        </div>

                        <!-- 시간 눈금자 -->
                        <div class="timeline-ruler" id="timeline-ruler">
                            <div class="timeline-ruler-header"></div>
                            <div class="timeline-ruler-content">
                                <div class="time-marker major zero-marker" style="color: rgb(255, 68, 68); font-weight: bold; z-index: 100; left: 0px;">0:00</div>
                                <div class="time-marker" style="left: 500px;">0:10</div>
                                <div class="time-marker" style="left: 1000px;">0:20</div>
                                <div class="time-marker" style="left: 1500px;">0:30</div>
                                <div class="time-marker" style="left: 2000px;">0:40</div>
                                <div class="time-marker major" style="left: 2500px;">0:50</div>
                                <div class="time-marker" style="left: 3000px;">1:00</div>
                                <div class="time-marker" style="left: 3500px;">1:10</div>
                                <div class="time-marker" style="left: 4000px;">1:20</div>
                                <div class="time-marker" style="left: 4500px;">1:30</div>
                                <div class="time-marker major" style="left: 5000px;">1:40</div>
                                <div class="time-marker" style="left: 5500px;">1:50</div>
                                <div class="time-marker" style="left: 6000px;">2:00</div>
                                <div class="time-marker" style="left: 6500px;">2:10</div>
                                <div class="time-marker" style="left: 7000px;">2:20</div>
                                <div class="time-marker major" style="left: 7500px;">2:30</div>
                                <div class="time-marker" style="left: 8000px;">2:40</div>
                                <div class="time-marker" style="left: 8500px;">2:50</div>
                                <div class="time-marker" style="left: 9000px;">3:00</div>
                                <div class="time-marker" style="left: 9500px;">3:10</div>
                                <div class="time-marker major" style="left: 10000px;">3:20</div>
                                <div class="time-marker" style="left: 10500px;">3:30</div>
                                <div class="time-marker" style="left: 11000px;">3:40</div>
                                <div class="time-marker" style="left: 11500px;">3:50</div>
                                <div class="time-marker" style="left: 12000px;">4:00</div>
                                <div class="time-marker major" style="left: 12500px;">4:10</div>
                                <div class="time-marker" style="left: 13000px;">4:20</div>
                                <div class="time-marker" style="left: 13500px;">4:30</div>
                                <div class="time-marker" style="left: 14000px;">4:40</div>
                                <div class="time-marker" style="left: 14500px;">4:50</div>
                                <div class="time-marker major" style="left: 15000px;">5:00</div>
                            </div>
                        </div>

                        <!-- 영상 트랙 -->
                        <div class="timeline-track video-track">
                            <div class="track-header">
                                <div class="track-title">
                                    <input type="checkbox" id="track-video-enable" checked style="cursor: pointer; width: 18px; height: 18px;">
                                    <label for="track-video-enable" style="cursor: pointer;">📹 영상</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="video-file-input" accept="video/*" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('video-file-input').click()" title="영상 파일 로드">📂</button>
                                    <button class="track-clear" onclick="clearMediaTrack('video')" title="트랙 비우기">🗑️</button>
                                    <button id="video-mute-btn" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px 8px;" title="영상 음소거 해제">🔇</button>
                                </div>
                            </div>
                            <div class="track-content" id="video-track">
                                <!-- 영상 클립이 여기에 표시됩니다 -->
                            </div>
                        </div>

                        <!-- 음성 파형 트랙 -->
                        <div class="timeline-track audio-track">
                            <div class="track-header">
                                <div class="track-title">
                                    <input type="checkbox" id="track-audio-enable" checked style="cursor: pointer; width: 18px; height: 18px;">
                                    <label for="track-audio-enable" style="cursor: pointer;">🎵 음성</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="audio-file-input" accept="audio/*" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('audio-file-input').click()" title="음성 파일 로드">📂</button>
                                    <button class="track-clear" onclick="clearMediaTrack('audio')" title="트랙 비우기">🗑️</button>
                                </div>
                            </div>
                            <div class="audio-edit-toolbar" data-track="audio">
                                <div class="audio-selection-info" id="audio-selection-info-audio">선택 위치: 없음</div>
                                <div class="audio-edit-actions">
                                    <button type="button" class="audio-action-btn" data-audio-action="trim-to-video" data-track="audio">✂️ 영상 길이 맞추기</button>
                                    <button type="button" class="audio-action-btn" data-audio-action="delete-from-selection" data-track="audio">🗑️ 선택 이후 삭제</button>
                                    <button type="button" class="audio-action-btn" data-audio-action="clear-selection" data-track="audio">❌ 선택 해제</button>
                                </div>
                            </div>
                            <div class="track-content" id="audio-track">
                                <canvas id="timeline-waveform" height="50"></canvas>
                            </div>
                        </div>

                        <!-- 해설 음성 파형 트랙 -->
                        <div class="timeline-track audio-track">
                            <div class="track-header">
                                <div class="track-title">
                                    <input type="checkbox" id="track-commentary-enable" checked style="cursor: pointer; width: 18px; height: 18px;">
                                    <label for="track-commentary-enable" style="cursor: pointer;">🎙️ 해설 음성</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="commentary-file-input" accept="audio/*" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('commentary-file-input').click()" title="해설 음성 파일 로드">📂</button>
                                    <button class="track-clear" onclick="clearMediaTrack('commentary')" title="트랙 비우기">🗑️</button>
                                </div>
                            </div>
                            <div class="audio-edit-toolbar" data-track="commentary">
                                <div class="audio-selection-info" id="audio-selection-info-commentary">선택 위치: 없음</div>
                                <div class="audio-edit-actions">
                                    <button type="button" class="audio-action-btn" data-audio-action="trim-to-video" data-track="commentary">✂️ 영상 길이 맞추기</button>
                                    <button type="button" class="audio-action-btn" data-audio-action="delete-from-selection" data-track="commentary">🗑️ 선택 이후 삭제</button>
                                    <button type="button" class="audio-action-btn" data-audio-action="clear-selection" data-track="commentary">❌ 선택 해제</button>
                                </div>
                            </div>
                            <div class="track-content" id="commentary-audio-track">
                                <canvas id="commentary-waveform" height="50"></canvas>
                            </div>
                        </div>

                        <!-- 배경 음악 파형 트랙 -->
                        <div class="timeline-track audio-track">
                            <div class="track-header">
                                <div class="track-title">
                                    <input type="checkbox" id="track-bgm-enable" checked style="cursor: pointer; width: 18px; height: 18px;">
                                    <label for="track-bgm-enable" style="cursor: pointer;">🎵 배경 음악</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="bgm-file-input" accept="audio/*" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('bgm-file-input').click()" title="배경 음악 파일 로드">📂</button>
                                    <button class="track-clear" onclick="clearMediaTrack('bgm')" title="트랙 비우기">🗑️</button>
                                </div>
                            </div>
                            <div class="audio-edit-toolbar" data-track="bgm">
                                <div class="audio-selection-info" id="audio-selection-info-bgm">선택 위치: 없음</div>
                                <div class="audio-edit-actions">
                                    <button type="button" class="audio-action-btn" data-audio-action="trim-to-video" data-track="bgm">✂️ 영상 길이 맞추기</button>
                                    <button type="button" class="audio-action-btn" data-audio-action="delete-from-selection" data-track="bgm">🗑️ 선택 이후 삭제</button>
                                    <button type="button" class="audio-action-btn" data-audio-action="clear-selection" data-track="bgm">❌ 선택 해제</button>
                                </div>
                            </div>
                            <div class="track-content" id="bgm-audio-track">
                                <canvas id="bgm-waveform" height="50"></canvas>
                            </div>
                        </div>

                        <!-- 하이브리드 자막 트랙 시스템 -->
                        <!-- 메인 자막 트랙 (원어 대사) -->
                        <div class="timeline-track subtitle-track main-subtitle-track" id="main-subtitle-track">
                            <div class="track-header">
                                <div class="track-title" style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="track-main-subtitle-enable" checked="" style="cursor: pointer; width: 16px; height: 16px;">
                                    <label for="track-main-subtitle-enable" style="cursor: pointer; color: #f0f4f8;">📝 메인 자막</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="main-subtitle-file-input" accept=".srt,.vtt,.ass,.ssa" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('main-subtitle-file-input').click()" title="자막 파일 로드">📂</button>
                                    <button class="track-clear" data-track="main" title="트랙 비우기">🗑️</button>
                                </div>
                            </div>
                            <div class="track-content" id="main-subtitle-content">
                                <!-- 메인 자막 블록들이 여기에 표시됩니다 -->
                            </div>
                        </div>

                        <!-- 번역/더빙 자막 트랙 -->
                        <div class="timeline-track subtitle-track translation-subtitle-track" id="translation-subtitle-track">
                            <div class="track-header">
                                <div class="track-title" style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="track-translation-subtitle-enable" checked="" style="cursor: pointer; width: 16px; height: 16px;">
                                    <label for="track-translation-subtitle-enable" style="cursor: pointer; color: #f0f4f8;">🌐 주자막</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="translation-subtitle-file-input" accept=".srt,.vtt,.ass,.ssa" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('translation-subtitle-file-input').click()" title="자막 파일 로드">📂</button>
                                    <button class="track-clear" data-track="translation" title="트랙 비우기">🗑️</button>
                                </div>
                            </div>
                            <div class="track-content" id="translation-subtitle-content">
                                <!-- 주자막 블록들이 여기에 표시됩니다 -->
                            </div>
                        </div>

                        <!-- 설명/효과음 자막 트랙 -->
                        <div class="timeline-track subtitle-track description-subtitle-track" id="description-subtitle-track">
                            <div class="track-header">
                                <div class="track-title" style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="track-description-subtitle-enable" checked="" style="cursor: pointer; width: 16px; height: 16px;">
                                    <label for="track-description-subtitle-enable" style="cursor: pointer; color: #f0f4f8;">🔊 보조자막</label>
                                </div>
                                <div class="track-controls">
                                    <input type="file" id="description-subtitle-file-input" accept=".srt,.vtt,.ass,.ssa" style="display: none;">
                                    <button class="track-load" onclick="document.getElementById('description-subtitle-file-input').click()" title="자막 파일 로드">📂</button>
                                    <button class="track-clear" data-track="description" title="트랙 비우기">🗑️</button>
                                </div>
                            </div>
                            <div class="track-content" id="description-subtitle-content">
                                <!-- 보조자막 블록들이 여기에 표시됩니다 -->
                            </div>
                        </div>

                        <!-- 재생 헤드 -->
                        <div class="playhead" id="playhead" style="left: 0px;"></div>
                    </div>
                </div>
            </div>

            <!-- 자막 스타일 설정 -->
            <div class="subtitle-style-settings" style="margin-top: 20px; padding: 15px; background: rgba(26, 30, 46, 0.6); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h4 style="margin: 0 0 15px 0; color: #f0f4f8; font-size: 1rem;">🎭 자막 레이아웃 템플릿</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: rgba(42, 46, 62, 0.8); border-radius: 6px; border: 2px solid transparent; cursor: pointer; transition: all 0.3s ease;" onmouseenter="this.style.borderColor='rgba(74, 158, 255, 0.5)'" onmouseleave="if(!this.querySelector('input').checked) this.style.borderColor='transparent'">
                        <input type="radio" name="subtitle-template-video" value="classic" checked style="width: 18px; height: 18px; cursor: pointer;" onchange="toggleBannerControls()">
                        <div>
                            <strong style="display: block; color: #f0f4f8; font-size: 0.95rem;">Classic</strong>
                            <small style="color: #b0c4de; font-size: 0.85rem;">하단 실시간 자막</small>
                        </div>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; padding: 12px; background: rgba(42, 46, 62, 0.8); border-radius: 6px; border: 2px solid transparent; cursor: pointer; transition: all 0.3s ease;" onmouseenter="this.style.borderColor='rgba(74, 158, 255, 0.5)'" onmouseleave="if(!this.querySelector('input').checked) this.style.borderColor='transparent'">
                        <input type="radio" name="subtitle-template-video" value="banner" style="width: 18px; height: 18px; cursor: pointer;" onchange="toggleBannerControls()">
                        <div>
                            <strong style="display: block; color: #f0f4f8; font-size: 0.95rem;">Banner</strong>
                            <small style="color: #b0c4de; font-size: 0.85rem;">상단 배너 + 자막</small>
                        </div>
                    </label>
                </div>

                <div id="banner-controls-video" style="display: none; padding: 12px; background: rgba(42, 46, 62, 0.5); border-radius: 6px;">
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; color: #b0c4de; font-size: 0.9rem;">주 텍스트 (상단)</label>
                        <input type="text" id="banner-primary-video" placeholder="예: 충격적인 사건!" style="width: 100%; padding: 8px; background: rgba(26, 30, 46, 0.8); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: #f0f4f8; font-size: 0.9rem;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #b0c4de; font-size: 0.9rem;">보조 텍스트 (하단) - 비워두면 실시간 자막 표시</label>
                        <input type="text" id="banner-secondary-video" placeholder="비워두면 실시간 자막이 표시됩니다" style="width: 100%; padding: 8px; background: rgba(26, 30, 46, 0.8); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: #f0f4f8; font-size: 0.9rem;">
                    </div>
                    <p style="margin: 10px 0 0 0; padding: 8px; background: rgba(0, 255, 136, 0.05); border-left: 3px solid #00ff88; border-radius: 4px; color: #b0c4de; font-size: 0.85rem;">💡 팁: 보조 텍스트를 비워두면 하단에서도 실시간 자막을 볼 수 있습니다.</p>
                </div>
            </div>

            <!-- 브라우저 기능 진단 패널 -->
            <div class="browser-diagnostic-panel" style="margin-top: 20px; padding: 15px; background: rgba(26, 30, 46, 0.6); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; cursor: pointer;" onclick="toggleBrowserPanel()">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="browser-panel-toggle" style="color: #f0f4f8; font-size: 1.2rem; transition: transform 0.3s;">▶</span>
                        <h4 style="margin: 0; color: #f0f4f8; font-size: 1rem;">🔍 브라우저 기능 진단</h4>
                    </div>
                    <button onclick="event.stopPropagation(); runBrowserDiagnostics()" class="btn-primary" style="padding: 6px 12px; background: #3b82f6; font-size: 0.9rem;">
                        진단 실행
                    </button>
                </div>
                <div id="browser-panel-content" style="display: none;">
                    <div id="browser-diagnostic-results" style="display: none;">
                        <!-- 진단 결과가 여기에 표시됩니다 -->
                    </div>
                    <p style="margin: 10px 0 0 0; padding: 8px; background: rgba(59, 130, 246, 0.05); border-left: 3px solid #3b82f6; border-radius: 4px; color: #b0c4de; font-size: 0.85rem;">
                        💡 이 진단은 브라우저가 WebCodecs, WebGL2, SharedArrayBuffer 등 최신 기능을 지원하는지 확인합니다.
                    </p>
                </div>
            </div>

            <!-- 성능 대시보드 패널 -->
            <div class="performance-dashboard-panel" style="margin-top: 20px; padding: 15px; background: rgba(26, 30, 46, 0.6); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; cursor: pointer;" onclick="togglePerformancePanel()">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="performance-panel-toggle" style="color: #f0f4f8; font-size: 1.2rem; transition: transform 0.3s;">▶</span>
                        <h4 style="margin: 0; color: #f0f4f8; font-size: 1rem;">📊 성능 대시보드</h4>
                    </div>
                    <div style="display: flex; gap: 8px;" onclick="event.stopPropagation();">
                        <button onclick="showPerformanceReport()" class="btn-primary" style="padding: 6px 12px; background: #10b981; font-size: 0.9rem;">
                            리포트 표시
                        </button>
                        <button onclick="clearPerformanceData()" class="btn-secondary" style="padding: 6px 12px; background: #ef4444; font-size: 0.9rem;">
                            데이터 초기화
                        </button>
                    </div>
                </div>
                <div id="performance-panel-content" style="display: none;">
                    <div id="performance-dashboard-results" style="display: none;">
                        <!-- 성능 리포트가 여기에 표시됩니다 -->
                    </div>
                    <p style="margin: 10px 0 0 0; padding: 8px; background: rgba(16, 185, 129, 0.05); border-left: 3px solid #10b981; border-radius: 4px; color: #b0c4de; font-size: 0.85rem;">
                        💡 API 호출, DOM 렌더링, 메모리 사용량 등 실시간 성능 데이터를 수집합니다. 콘솔에서도 확인 가능합니다.
                    </p>
                </div>
            </div>

            <div class="video-preview-actions" style="margin-top: 15px;">
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button onclick="useThisVideo()" class="btn-primary">이 영상으로 자막 불러오기</button>
                    <button onclick="createFinalVideo()" class="btn-primary" style="background: #f59e0b;">🎬 영상제작하기</button>
                    <button onclick="closeVideoPreview()" class="btn-secondary" style="background: #666;">닫기</button>
                </div>
                <div style="margin-bottom: 10px;">
                    <button onclick="toggleFrameExtractionButtons()" class="btn-secondary" style="padding: 6px 16px; background: #6366f1; font-size: 0.9rem; width: 100%;">
                        <span id="frame-extraction-toggle-icon">▼</span> 프레임 추출 버튼
                    </button>
                </div>
                <div id="frame-extraction-buttons" style="display: none; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <button onclick="extractFirstFrame()" class="btn-secondary" style="background: #10b981;">📸 맨 앞 프레임</button>
                    <button onclick="extractLastFrame()" class="btn-secondary" style="background: #10b981;">📸 맨 뒤 프레임</button>
                    <div style="display: flex; align-items: center; gap: 5px; background: rgba(0, 0, 0, 0.2); padding: 8px 12px; border-radius: 6px;">
                        <button onclick="decreaseInterval()" class="btn-secondary" style="background: #ef4444; padding: 4px 12px; min-width: 40px;">−</button>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="number" id="frame-interval" value="5" min="1" max="60" style="width: 60px; padding: 6px; border: 1px solid #555; border-radius: 4px; background: #1a1a1a; color: #e0e6ed; text-align: center; font-size: 14px;">
                            <span style="color: #c8d8e8;">초 간격</span>
                        </div>
                        <button onclick="increaseInterval()" class="btn-secondary" style="background: #10b981; padding: 4px 12px; min-width: 40px;">+</button>
                        <button onclick="extractFramesByCurrentInterval()" class="btn-secondary" style="background: #3b82f6; padding: 6px 12px;">⏱️ 추출</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; background: rgba(139, 92, 246, 0.2); padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(139, 92, 246, 0.4);">
                        <button onclick="decreaseSegmentFrames()" class="btn-secondary" style="background: #ef4444; padding: 4px 12px; min-width: 40px;">−</button>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="number" id="frames-per-segment" value="2" min="1" max="10" style="width: 60px; padding: 6px; border: 1px solid #555; border-radius: 4px; background: #1a1a1a; color: #e0e6ed; text-align: center; font-size: 14px;">
                            <span style="color: #c8d8e8;">개</span>
                        </div>
                        <button onclick="increaseSegmentFrames()" class="btn-secondary" style="background: #10b981; padding: 4px 12px; min-width: 40px;">+</button>
                        <button onclick="extractFramesBySegments()" class="btn-secondary" style="background: #8b5cf6; padding: 6px 12px;">🎯 각 영상마다 추출</button>
                    </div>
                    <button onclick="extractFramesBySubtitles()" class="btn-secondary" style="background: #f59e0b;">📝 자막 기준 프레임 추출</button>
                    <button onclick="extractVideoClipsBySubtitles()" class="btn-secondary" style="background: #ef4444;">✂️ 자막 기준 영상 자르기</button>
                </div>
            </div>
            <div id="extracted-frames-gallery" style="display: none; margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0;">추출된 이미지</h3>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="downloadAllFrames()" class="btn-secondary" style="background: #10b981; padding: 6px 12px;">💾 이미지,트랙저장</button>
                        <button onclick="clearAllFrames()" class="btn-secondary" style="background: #ef4444; padding: 6px 12px;">🗑️ 전체 삭제</button>
                    </div>
                </div>

                <!-- AI 프레임 분석 -->
                <div id="frame-analysis-section" style="margin-bottom: 15px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3); scroll-margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <h4 style="margin: 0; color: #8ac5ff;">🤖 AI 프레임 분석</h4>
                            <button onclick="toggleFrameAnalysisSection()" class="btn-secondary" style="padding: 4px 10px; font-size: 0.85rem; background: #6366f1;">
                                <span id="frame-analysis-toggle-icon">▼</span> 펼치기/접기
                            </button>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="selectAllFrames()" class="btn-secondary" style="padding: 4px 10px; font-size: 0.85rem; background: #3b82f6;">✓ 전체 선택</button>
                            <button onclick="deselectAllFrames()" class="btn-secondary" style="padding: 4px 10px; font-size: 0.85rem; background: #6b7280;">✗ 선택 해제</button>
                        </div>
                    </div>
                    <div id="frame-analysis-content-area" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">AI 모델</label>
                            <select id="frame-ai-model-select" onchange="updateFrameAnalysisCost()" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                                <option value="gpt-4o-mini">GPT-4o Mini</option>
                                <option value="sonnet" selected>Claude Sonnet</option>
                                <option value="haiku">Claude Haiku</option>
                                <option value="gpt-4o">GPT-4o</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">분석 유형</label>
                            <select id="frame-analysis-type" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                                <option value="shorts-production" selected>🎥 쇼츠 제작용</option>
                                <option value="scene-description">🎬 장면 설명</option>
                                <option value="object-detection">🔍 객체 인식</option>
                                <option value="text-extraction">📝 텍스트 추출</option>
                                <option value="story-flow">📖 스토리 흐름</option>
                                <option value="thumbnail-suggest">🖼️ 썸네일 추천</option>
                                <option value="custom">✏️ 커스텀 프롬프트</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">주 자막 언어 (상단)</label>
                            <select id="subtitle-language-primary" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                                <option value="korean" selected>🇰🇷 한국어</option>
                                <option value="english">🇺🇸 English</option>
                                <option value="japanese">🇯🇵 日本語</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">보조 자막 언어 (하단)</label>
                            <select id="subtitle-language-secondary" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                                <option value="">없음</option>
                                <option value="korean">🇰🇷 한국어</option>
                                <option value="english" selected>🇺🇸 English</option>
                                <option value="japanese">🇯🇵 日本語</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">분석 템플릿</label>
                            <select id="frame-analysis-template" onchange="loadFrameAnalysisTemplate()" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                                <option value="">새 분석</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: flex-end;">
                            <button onclick="analyzeFramesWithAI()" class="btn-secondary" style="padding: 10px 20px; font-size: 0.95rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); white-space: nowrap;">🤖 분석 시작</button>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <p style="margin: 0; color: #a0aec0; font-size: 0.85rem;">
                                💡 프레임 각각에 체크박스를 클릭하여 분석할 프레임을 선택하세요.
                            </p>
                            <div style="display: flex; gap: 15px; align-items: center;">
                                <label style="display: flex; align-items: center; gap: 6px; color: #e0e6ed; font-size: 0.9rem; cursor: pointer;">
                                    <input type="checkbox" id="include-extracted-frames" style="width: 16px; height: 16px; cursor: pointer;">
                                    <span>🖼️ AI 추출된 프레임 포함</span>
                                </label>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <label style="display: flex; align-items: center; gap: 6px; color: #e0e6ed; font-size: 0.9rem; cursor: pointer;">
                                        <input type="checkbox" id="include-title-subtitle" style="width: 16px; height: 16px; cursor: pointer;">
                                        <span>📌 제목자막 포함</span>
                                    </label>
                                    <input type="file" id="quick-subtitle-file-input" accept=".srt,.vtt,.ass,.ssa" style="display: none;">
                                    <button onclick="document.getElementById('quick-subtitle-file-input').click()"
                                            style="background: rgba(16, 185, 129, 0.2); border: 1px solid #10b981; color: #10b981;
                                                   padding: 4px 10px; border-radius: 4px; font-size: 0.85rem; cursor: pointer;
                                                   transition: all 0.2s; display: flex; align-items: center; gap: 4px;"
                                            onmouseover="this.style.background='rgba(16, 185, 129, 0.3)'"
                                            onmouseout="this.style.background='rgba(16, 185, 129, 0.2)'"
                                            title="자막 파일 불러오기">
                                        📂 자막 불러오기
                                    </button>
                                    <button onclick="clearQuickSubtitle()"
                                            style="background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; color: #ef4444;
                                                   padding: 4px 10px; border-radius: 4px; font-size: 0.85rem; cursor: pointer;
                                                   transition: all 0.2s; display: flex; align-items: center; gap: 4px;"
                                            onmouseover="this.style.background='rgba(239, 68, 68, 0.3)'"
                                            onmouseout="this.style.background='rgba(239, 68, 68, 0.2)'"
                                            title="불러온 자막 비우기">
                                        🗑️ 비우기
                                    </button>
                                    <span id="loaded-subtitle-files" style="color: #10b981; font-size: 0.85rem; font-weight: 500;"></span>
                                </div>
                            </div>
                        </div>
                        <div id="frame-analysis-cost" style="color: #fbbf24; font-size: 0.9rem; font-weight: 600;">
                            예상 비용: 계산 중...
                        </div>
                    </div>
                    <!-- 커스텀 프롬프트 입력 -->
                    <div id="custom-prompt-container" style="display: none; margin-top: 10px;">
                        <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">커스텀 프롬프트</label>
                        <textarea id="custom-prompt-input" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem; min-height: 100px;" placeholder="분석에 사용할 프롬프트를 입력하세요..."></textarea>
                        <div style="display: flex; gap: 10px; margin-top: 5px;">
                            <button onclick="saveFrameAnalysisTemplate()" class="btn-secondary" style="padding: 4px 10px; font-size: 0.85rem; background: #10b981;">💾 템플릿으로 저장</button>
                        </div>
                    </div>
                    </div>
                </div>

                <!-- AI 프레임 분석 결과 -->
                <div id="frame-analysis-result" style="margin-bottom: 15px; padding: 15px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <h4 style="margin: 0; color: #10b981;">📊 AI 분석 결과 <span style="font-size: 0.75rem; color: #a0aec0; font-weight: normal;">(편집 가능)</span></h4>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="saveAnalysisToStorage()" class="btn-secondary" style="padding: 4px 10px; background: #3b82f6; font-size: 0.8rem;" title="브라우저에 임시 저장 (최대 20개)">📌 보관함에 저장</button>
                                <button onclick="showLoadAnalysisDialog()" class="btn-secondary" style="padding: 4px 10px; background: #6366f1; font-size: 0.8rem;" title="저장된 분석 결과 불러오기">📂 보관함 열기</button>
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div style="display: flex; gap: 8px;">
                                <button onclick="exportSubtitles()" class="btn-secondary" style="padding: 6px 12px; background: #8b5cf6; font-size: 0.85rem;" title="자막만 SRT 파일로 다운로드">💬 자막</button>
                                <button onclick="exportKoreanSubtitles()" class="btn-secondary" style="padding: 6px 12px; background: #f59e0b; font-size: 0.85rem; font-weight: 600;" title="AI 분석 결과에서 한글자막(2-0)을 추출하여 다운로드합니다">📥 한글자막2-0</button>
                                <button onclick="exportMainSubtitles()" class="btn-secondary" style="padding: 6px 12px; background: #10b981; font-size: 0.85rem; font-weight: 600;" title="AI 분석 결과에서 주자막을 추출하여 다운로드합니다">📥 주자막2-1</button>
                                <button onclick="exportSecondarySubtitles()" class="btn-secondary" style="padding: 6px 12px; background: #06b6d4; font-size: 0.85rem; font-weight: 600;" title="AI 분석 결과에서 보조자막을 추출하여 다운로드합니다">📥 보조 자막2-2</button>
                                <button onclick="exportNarration()" class="btn-secondary" style="padding: 6px 12px; background: #f59e0b; font-size: 0.85rem;" title="나레이션만 TXT 파일로 다운로드">🎙️ 나레이션</button>
                                <button onclick="exportImagePrompts()" class="btn-secondary" style="padding: 6px 12px; background: #ec4899; font-size: 0.85rem;" title="이미지 프롬프트만 TXT 파일로 다운로드">🎨 이미지</button>
                                <button onclick="exportVideoPrompts()" class="btn-secondary" style="padding: 6px 12px; background: #06b6d4; font-size: 0.85rem;" title="영상 프롬프트만 TXT 파일로 다운로드">🎥 영상</button>
                                <button onclick="saveFrameAnalysisResult()" class="btn-secondary" style="padding: 6px 12px; background: #10b981; font-size: 0.85rem;" title="전체 결과를 TXT 파일로 다운로드">📥 전체</button>
                                <button onclick="document.getElementById('file-upload-input').click()" class="btn-secondary" style="padding: 6px 12px; background: #059669; font-size: 0.85rem;" title="다운로드한 TXT 파일 불러오기">📄 불러오기</button>
                                <input type="file" id="file-upload-input" accept=".txt" style="display: none;" onchange="loadAnalysisFromFile(event)">
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="copyImagePrompts()" class="btn-secondary" style="padding: 6px 12px; background: #d946ef; font-size: 0.85rem;" title="이미지 프롬프트를 클립보드에 복사">📋 이미지 전체 복사</button>
                                <button onclick="copyVideoPrompts()" class="btn-secondary" style="padding: 6px 12px; background: #0891b2; font-size: 0.85rem;" title="영상 프롬프트를 클립보드에 복사">📋 영상 전체 복사</button>
                                <button onclick="showScenePromptSelector()" class="btn-secondary" style="padding: 6px 12px; background: #a855f7; font-size: 0.85rem;" title="장면별로 개별 프롬프트 복사">🎬 장면별 복사</button>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="generateNewShortsContent()" class="btn-secondary" style="padding: 6px 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 0.85rem; font-weight: 600;" title="AI로 완전히 새로운 쇼츠 콘텐츠 생성">🎬 새 쇼츠 콘텐츠 생성</button>
                                <button onclick="continueGeneratingShortsContent()" class="btn-secondary" style="padding: 6px 12px; background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); font-size: 0.85rem; font-weight: 600;" title="기존 내용에 이어서 추가 콘텐츠 생성">➕ 이어서 생성</button>
                            </div>
                        </div>
                    </div>
                    <textarea id="frame-analysis-content" style="width: 100%; min-height: 300px; padding: 15px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-family: 'Noto Sans KR', sans-serif; font-size: 0.95rem; line-height: 1.6; resize: vertical;" placeholder="✨ 프레임을 선택하고 &quot;🤖 분석 시작&quot; 버튼을 클릭하면 쇼츠 제작을 위한 종합 분석 결과가 여기에 표시됩니다.

📝 포함 내용: 시청자용 콘텐츠 설명, 화면 텍스트(자막), 나레이션 스크립트, AI 이미지 생성 프롬프트, 편집 노트

💡 분석 결과를 직접 수정할 수 있으며, 각 요소별로 추출하거나 전체를 저장할 수 있습니다."></textarea>
                </div>

                <div id="frames-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 10px;"></div>
            </div>
        </div>

    </section>

    {% if error %}
    <div class="alert error">
        <strong>오류:</strong> {{ error }}
    </div>
    {% endif %}

    {% if result %}
    <section class="panel result-panel">
        <h2>자막 정보</h2>
        <div class="subtitle-info">
            <p><strong>영상 파일:</strong> {{ result.video_name }}</p>
            {% if result.subtitle_file %}
            <p><strong>자막 파일:</strong> {{ result.subtitle_file }}</p>
            {% endif %}
            <p><strong>자막 라인 수:</strong> {{ result.subtitle_count }}개</p>
        </div>

        {% if result.subtitles %}
        <div class="subtitle-content">
            <!-- AI 분석 버튼 -->
            <div id="subtitle-analysis-section" style="margin-bottom: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3); scroll-margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <h3 style="margin: 0; color: #8ac5ff;">🤖 AI 자막 분석</h3>
                        <button onclick="toggleSubtitleAnalysisSection()" class="btn-secondary" style="padding: 4px 10px; font-size: 0.85rem; background: #6366f1;">
                            <span id="subtitle-analysis-toggle-icon">▼</span> 펼치기/접기
                        </button>
                    </div>
                </div>

                <div id="subtitle-analysis-content-area" style="display: none;">
                <!-- 모델 및 분석 타입 선택 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">AI 모델 선택</label>
                        <select id="ai-model-select" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                            <option value="gpt-4o-mini">GPT-4o Mini ($0.01 - 가장 저렴)</option>
                            <option value="sonnet" selected>Claude Sonnet ($0.06 - 한국어 최고)</option>
                            <option value="haiku">Claude Haiku ($0.015 - 가성비)</option>
                            <option value="gpt-4o">GPT-4o ($0.05 - 균형)</option>
                        </select>
                    </div>

                    <div>
                        <label style="display: block; color: #a0aec0; font-size: 0.85rem; margin-bottom: 5px;">분석 타입</label>
                        <select id="analysis-type-select" style="width: 100%; padding: 8px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #e0e6ed; font-size: 0.9rem;">
                            <option value="enhanced-shorts" selected>🎬 60초 쇼츠 (삭제 60-70%)</option>
                            <option value="enhanced-summary">📊 긴 영상 요약 (3-5분)</option>
                            <option value="enhanced-education">📚 교육 콘텐츠</option>
                            <option value="enhanced">✨ 기본 Enhanced</option>
                            <option value="shorts">⚡ 기본 Shorts</option>
                        </select>
                    </div>

                    <div style="display: flex; align-items: flex-end;">
                        <button onclick="analyzeSubtitlesWithAI()" class="btn-secondary" style="padding: 10px 20px; font-size: 0.95rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); white-space: nowrap;">🤖 분석 시작</button>
                    </div>
                </div>

                <p style="margin: 0; color: #a0aec0; font-size: 0.85rem;">
                    💡 자막을 AI로 분석하여 쇼츠 최적화, 영상 요약, 교육 콘텐츠 제작을 위한 편집 제안을 받으세요.
                </p>
                </div>
                </div>
            </div>

            <!-- 저장/불러오기 버튼 (항상 표시) -->
            <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #e0e6ed;">💾 작업 관리</h4>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="saveAnalysisResult()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #3b82f6;">💾 저장 (다운로드)</button>
                    <button onclick="saveSubtitleAnalysisToLocalStorage()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #10b981;">💾 브라우저에 저장</button>
                    <button onclick="showSubtitleAnalysisDialog()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #8b5cf6;">📂 불러오기</button>
                    <button onclick="loadAnalysisFromFile()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #6366f1;">📁 파일에서 불러오기</button>
                </div>
                <p style="margin: 10px 0 0 0; color: #a0aec0; font-size: 0.8rem;">
                    💡 분석 작업을 브라우저에 저장하거나 파일로 다운로드할 수 있습니다.
                </p>
            </div>

            <!-- 숨겨진 파일 입력 (불러오기용) -->
            <input type="file" id="load-analysis-input" accept=".json" style="display: none;" onchange="handleAnalysisFileLoad(event)">

            <!-- AI 분석 결과 섹션 (숨김 상태로 시작) -->
            <div id="ai-analysis-result" style="display: none;">
                <!-- 요약 통계 -->
                <div class="analysis-summary" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="stat-card" style="background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 15px;">
                        <div style="color: #10b981; font-size: 0.85rem; margin-bottom: 5px;">원본 전체 길이</div>
                        <div style="color: #fff; font-size: 1.5rem; font-weight: 600;" id="original-duration">-</div>
                    </div>
                    <div class="stat-card" style="background: rgba(59, 130, 246, 0.15); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 15px;">
                        <div style="color: #3b82f6; font-size: 0.85rem; margin-bottom: 5px;">요약본 길이</div>
                        <div style="color: #fff; font-size: 1.5rem; font-weight: 600;" id="summary-duration">-</div>
                    </div>
                    <div class="stat-card" style="background: rgba(168, 85, 247, 0.15); border: 1px solid rgba(168, 85, 247, 0.3); border-radius: 8px; padding: 15px;">
                        <div style="color: #a855f7; font-size: 0.85rem; margin-bottom: 5px;">삭제율</div>
                        <div style="color: #fff; font-size: 1.5rem; font-weight: 600;" id="deletion-rate">-</div>
                    </div>
                </div>

                <!-- 적합도 체크 -->
                <div class="suitability-check" style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e0e6ed;">📊 콘텐츠 적합도</h4>
                    <div style="display: grid; gap: 10px;">
                        <div class="suitability-item" style="display: flex; align-items: center; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px;">
                            <input type="checkbox" id="suitable-shorts" style="margin-right: 10px; width: 18px; height: 18px;">
                            <label for="suitable-shorts" style="color: #e0e6ed; cursor: pointer; flex: 1;">🎬 쇼츠용 적합 (60초 이내)</label>
                            <span id="shorts-score" style="color: #10b981; font-weight: 600;">-</span>
                        </div>
                        <div class="suitability-item" style="display: flex; align-items: center; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px;">
                            <input type="checkbox" id="suitable-summary" style="margin-right: 10px; width: 18px; height: 18px;">
                            <label for="suitable-summary" style="color: #e0e6ed; cursor: pointer; flex: 1;">📊 긴 영상 요약 적합 (3-5분)</label>
                            <span id="summary-score" style="color: #3b82f6; font-weight: 600;">-</span>
                        </div>
                        <div class="suitability-item" style="display: flex; align-items: center; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px;">
                            <input type="checkbox" id="suitable-education" style="margin-right: 10px; width: 18px; height: 18px;">
                            <label for="suitable-education" style="color: #e0e6ed; cursor: pointer; flex: 1;">📚 교육 콘텐츠 적합</label>
                            <span id="education-score" style="color: #a855f7; font-weight: 600;">-</span>
                        </div>
                    </div>
                </div>

                <!-- 자막 편집 버튼 -->
                <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="batchDeleteMarkedForDeletion()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #ef4444;">🗑️ 삭제 표시 일괄 삭제</button>
                    <button onclick="downloadEditedSubtitles()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #10b981;">📥 자막 다운로드 (SRT)</button>
                    <button onclick="clearAllSubtitles()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #ef4444;">🗑️ 전체 삭제</button>
                </div>

                <!-- 4가지 분류별 자막 표시 -->
                <div class="classified-subtitles">
                    <!-- 원본 자막 유지 -->
                    <div class="subtitle-category" style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; padding: 10px; background: rgba(16, 185, 129, 0.2); border-radius: 6px;">
                            <h4 style="margin: 0; color: #10b981;">✅ 원본 자막 유지 (<span id="kept-count">0</span>개)</h4>
                            <button onclick="toggleCategory('kept-originals')" class="btn-secondary" style="padding: 4px 12px; font-size: 0.85rem; background: #10b981;">접기/펼치기</button>
                        </div>
                        <div id="kept-originals" class="category-list"></div>
                    </div>

                    <!-- 삭제 대상 -->
                    <div class="subtitle-category" style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; padding: 10px; background: rgba(239, 68, 68, 0.2); border-radius: 6px;">
                            <h4 style="margin: 0; color: #ef4444;">❌ 삭제 대상 (<span id="deletions-count">0</span>개)</h4>
                            <button onclick="toggleCategory('deletions')" class="btn-secondary" style="padding: 4px 12px; font-size: 0.85rem; background: #ef4444;">접기/펼치기</button>
                        </div>
                        <div id="deletions" class="category-list"></div>
                    </div>

                    <!-- 텍스트 추가 -->
                    <div class="subtitle-category" style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; padding: 10px; background: rgba(59, 130, 246, 0.2); border-radius: 6px;">
                            <h4 style="margin: 0; color: #3b82f6;">➕ 텍스트 추가 (화면만) (<span id="text-additions-count">0</span>개)</h4>
                            <button onclick="toggleCategory('text-additions')" class="btn-secondary" style="padding: 4px 12px; font-size: 0.85rem; background: #3b82f6;">접기/펼치기</button>
                        </div>
                        <div id="text-additions" class="category-list"></div>
                    </div>

                    <!-- 나레이션 추가 -->
                    <div class="subtitle-category" style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; padding: 10px; background: rgba(168, 85, 247, 0.2); border-radius: 6px;">
                            <h4 style="margin: 0; color: #a855f7;">➕🎙️ 나레이션 추가 (음성) (<span id="narration-additions-count">0</span>개)</h4>
                            <button onclick="toggleCategory('narration-additions')" class="btn-secondary" style="padding: 4px 12px; font-size: 0.85rem; background: #a855f7;">접기/펼치기</button>
                        </div>
                        <div id="narration-additions" class="category-list"></div>
                    </div>
                </div>
            </div>

            <!-- 기본 자막 표시 (AI 분석 전) -->
            <div id="default-subtitle-view">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">자막 내용</h3>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="downloadEditedSubtitles()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #10b981;">📥 수정된 자막 다운로드</button>
                        <button onclick="clearAllSubtitles()" class="btn-secondary" style="padding: 8px 16px; font-size: 0.9rem; background: #ef4444;">🗑️ 전체 삭제</button>
                    </div>
                </div>
                <div class="subtitle-list" id="subtitle-list">
                    {% for sub in result.subtitles %}
                    <div class="subtitle-item" data-index="{{ loop.index0 }}" data-start="{{ sub.start }}" data-end="{{ sub.end }}" data-text="{{ sub.text }}">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div class="subtitle-time">
                                    <span class="time-badge">{{ sub.start }} → {{ sub.end }}</span>
                                </div>
                                <div class="subtitle-text">{{ sub.text }}</div>
                            </div>
                            <button onclick="deleteSubtitleItem(this)" class="delete-subtitle-btn" title="이 자막 삭제">🗑️</button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
        {% endif %}

        {% if result.download_url %}
        <div class="download-section">
            <a href="{{ result.download_url }}" class="btn-primary" download>📥 자막 파일 다운로드</a>
        </div>
        {% endif %}
    </section>
    {% endif %}

    <section class="panel info">
        <h2>사용 팁</h2>
        <ul>
            <li><strong>영상폴더</strong>에 경로를 입력하고 Enter를 누르면 해당 폴더의 영상 파일 목록을 볼 수 있습니다.</li>
            <li><strong>영상 파일 목록</strong>에서 영상을 클릭하면 미리보기로 영상 내용을 확인할 수 있습니다.</li>
            <li>원하는 영상을 선택하면 같은 이름의 자막 파일을 자동으로 찾습니다.</li>
            <li>자막 파일(.srt, .vtt 등)을 직접 업로드할 수도 있습니다.</li>
            <li>'자동 검색'을 체크하면 지정한 폴더에서 자막 파일을 찾습니다.</li>
        </ul>
    </section>
</div>

<style>
.panel-sub {
    margin: 0 0 20px 0;
    color: #c8d8e8;
    font-size: 0.95rem;
}

.analyzer-form .field {
    margin-bottom: 20px;
}

.hint-text {
    display: block;
    margin-top: 6px;
    font-size: 0.85rem;
    color: #a0aec0;
}

.result-panel {
    margin-top: 30px;
}

.subtitle-info {
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
}

.subtitle-info p {
    margin: 8px 0;
    color: #e0e6ed;
}

.subtitle-content {
    margin-top: 20px;
}

.subtitle-list {
    max-height: 600px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.28);
    border-radius: 8px;
    padding: 15px;
}

.subtitle-item {
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.subtitle-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.subtitle-time {
    margin-bottom: 8px;
}

.time-badge {
    display: inline-block;
    background: rgba(100, 180, 255, 0.2);
    color: #8ac5ff;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 0.85rem;
    font-family: monospace;
}

.subtitle-text {
    color: #ffffff;
    line-height: 1.6;
    font-size: 1rem;
}

.download-section {
    margin-top: 20px;
    text-align: center;
}

.btn-primary {
    display: inline-block;
    padding: 12px 24px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    transition: transform 0.2s;
}

.btn-primary:hover {
    transform: translateY(-2px);
}

.loading {
    text-align: center;
    color: #666;
    font-style: italic;
    padding: 20px;
}

.video-list {
    display: grid;
    gap: 10px;
    margin-top: 15px;
}

.video-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.2s;
}

.video-item:hover {
    background: rgba(0, 0, 0, 0.3);
    border-color: rgba(100, 180, 255, 0.5);
    transform: translateX(5px);
}

.video-item-info {
    flex: 1;
}

.video-item-name {
    color: #ffffff;
    font-weight: 600;
    margin-bottom: 4px;
}

.video-item-details {
    font-size: 0.85rem;
    color: #a0aec0;
}

.video-item-size {
    color: #8ac5ff;
    margin-right: 10px;
}

.video-item-path {
    font-size: 0.75rem;
    color: #718096;
    margin-top: 4px;
}

.video-item-action {
    padding: 6px 12px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: opacity 0.2s;
}

.video-item-action:hover {
    opacity: 0.8;
}

.empty-state {
    text-align: center;
    color: #888;
    font-style: italic;
    padding: 30px;
}

.video-preview-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.video-preview-info {
    width: 100%;
    max-width: 800px;
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 8px;
}

.video-preview-info p {
    margin: 8px 0;
    color: #e0e6ed;
    word-break: break-all;
}

.video-preview-actions {
    width: 100%;
    max-width: 800px;
}

.btn-secondary {
    display: inline-block;
    padding: 12px 24px;
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    transition: transform 0.2s;
    border: none;
    cursor: pointer;
    font-size: 1rem;
}

.btn-secondary:hover {
    opacity: 0.8;
}

.delete-subtitle-btn {
    background: #ef4444;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 6px 10px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.2s;
    margin-left: 10px;
}

.delete-subtitle-btn:hover {
    background: #dc2626;
    transform: scale(1.1);
}

.subtitle-item {
    transition: all 0.3s;
}

.subtitle-item.removing {
    opacity: 0;
    transform: translateX(-20px);
}

.category-list {
    max-height: 400px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.15);
    border-radius: 6px;
    padding: 10px;
}

.category-list.collapsed {
    display: none;
}

.category-item {
    margin-bottom: 15px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    border-left: 3px solid;
    transition: all 0.3s;
}

.category-item.kept {
    border-left-color: #10b981;
}

.category-item.deletion {
    border-left-color: #ef4444;
    opacity: 0.7;
}

.category-item.text-add {
    border-left-color: #3b82f6;
}

.category-item.narration-add {
    border-left-color: #a855f7;
}

.category-item.removing {
    opacity: 0;
    transform: translateX(-20px);
}

.category-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
}

.category-item-time {
    color: #8ac5ff;
    font-size: 0.85rem;
    font-family: monospace;
}

.category-item-text {
    color: #e0e6ed;
    line-height: 1.6;
    margin-top: 8px;
}

.category-item-reason {
    margin-top: 8px;
    padding: 6px 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    font-size: 0.85rem;
    color: #a0aec0;
}

.item-delete-btn {
    background: #ef4444;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
}

.item-delete-btn:hover {
    background: #dc2626;
    transform: scale(1.05);
}

/* AI 분석 select 박스 스타일 */
select#ai-model-select,
select#analysis-type-select {
    cursor: pointer;
    transition: all 0.2s;
}

select#ai-model-select:hover,
select#analysis-type-select:hover {
    border-color: rgba(102, 126, 234, 0.5);
    background: rgba(0, 0, 0, 0.4);
}

select#ai-model-select:focus,
select#analysis-type-select:focus {
    outline: none;
    border-color: rgba(102, 126, 234, 0.8);
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

select option {
    background: #1a1a2e;
    color: #e0e6ed;
    padding: 8px;
}

/* 반응형 디자인 */
@media (max-width: 768px) {
    .analysis-summary {
        grid-template-columns: 1fr !important;
    }

    #ai-model-select,
    #analysis-type-select {
        font-size: 0.85rem !important;
    }
}

/* ==================== 텍스트 오버레이 효과 ==================== */

/* 기본 자막 오버레이 스타일 */
.custom-subtitle-overlay {
    /* 기본 외곽선 효과 (검은 배경용 흰색 외곽선) */
    text-shadow:
        -0.04em -0.04em 0 #fff,
         0.04em -0.04em 0 #fff,
        -0.04em  0.04em 0 #fff,
         0.04em  0.04em 0 #fff,
        -0.06em  0      0 #fff,
         0.06em  0      0 #fff,
         0      -0.06em 0 #fff,
         0       0.06em 0 #fff;
}

/* 정적 효과 (스타일) */
.effect-outline {
    text-shadow:
        -0.04em -0.04em 0 #000,
         0.04em -0.04em 0 #000,
        -0.04em  0.04em 0 #000,
         0.04em  0.04em 0 #000,
        -0.06em  0      0 #000,
         0.06em  0      0 #000,
         0      -0.06em 0 #000,
         0       0.06em 0 #000 !important;
}

.effect-shadow {
    text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8) !important;
}

.effect-glow {
    text-shadow:
        0 0 10px rgba(255, 255, 255, 0.8),
        0 0 20px rgba(255, 255, 255, 0.6),
        0 0 30px rgba(255, 255, 255, 0.4) !important;
}

.effect-gradient {
    background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.effect-neon {
    text-shadow:
        0 0 5px #fff,
        0 0 10px #fff,
        0 0 20px #fff,
        0 0 40px #ff00de,
        0 0 80px #ff00de,
        0 0 90px #ff00de !important;
}

/* 동적 효과 (모션) */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

.effect-fade {
    animation: fadeIn 1s ease-in-out infinite alternate;
}

@keyframes slideUp {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.effect-slide-up {
    animation: slideUp 1s ease-in-out infinite alternate;
}

@keyframes slideDown {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.effect-slide-down {
    animation: slideDown 1s ease-in-out infinite alternate;
}

@keyframes bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-20px);
    }
}

.effect-bounce {
    animation: bounce 1s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}

.effect-pulse {
    animation: pulse 1.5s ease-in-out infinite;
}

@keyframes slideInRight {
    from {
        transform: translateX(100px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* 슬라이드 인 (왼쪽에서) */
@keyframes slideIn {
    from {
        transform: translateX(-50px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.effect-slide-in {
    animation: slideIn 0.8s ease-out;
}

/* 스케일 (확대/축소) */
@keyframes scaleAnimation {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.15);
    }
}

.effect-scale {
    animation: scaleAnimation 2s ease-in-out infinite;
}

/* 글로우 (빛나는 효과) */
@keyframes glowAnimation {
    0%, 100% {
        text-shadow:
            0 0 5px #fff,
            0 0 10px #fff,
            0 0 15px #fff,
            0 0 20px #ff6b6b;
    }
    50% {
        text-shadow:
            0 0 10px #fff,
            0 0 20px #fff,
            0 0 30px #fff,
            0 0 40px #ff6b6b,
            0 0 50px #ff6b6b,
            0 0 60px #ff6b6b;
    }
}

.effect-glow {
    animation: glowAnimation 2s ease-in-out infinite;
}

</style>

<script>
// localStorage keys
const STORAGE_KEY = 'video_analyzer_settings';
const FRAMES_STORAGE_KEY = 'video_analyzer_frames';
const VIDEO_INFO_STORAGE_KEY = 'video_analyzer_current_video';

// 설정 저장
function saveSettings() {
    const settings = {
        video_path: document.getElementById('video_path').value,
        search_directory: document.getElementById('search_directory').value,
        auto_search: document.querySelector('input[name="auto_search"]').checked,
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
}

// 설정 불러오기
function loadSettings() {
    const savedSettings = localStorage.getItem(STORAGE_KEY);
    const videoPathInput = document.getElementById('video_path');
    const searchDirInput = document.getElementById('search_directory');

    if (savedSettings) {
        try {
            const settings = JSON.parse(savedSettings);

            // 저장된 값이 있으면 입력 필드에 설정
            if (settings.video_path) {
                videoPathInput.value = settings.video_path;
            }
            if (settings.search_directory) {
                searchDirInput.value = settings.search_directory;
            }
            if (settings.auto_search !== undefined) {
                document.querySelector('input[name="auto_search"]').checked = settings.auto_search;
            }
        } catch (e) {
            console.error('Failed to load settings:', e);
        }
    }

    // 저장된 값이 없으면 기본 폴더 설정
    if (!videoPathInput.value) {
        videoPathInput.value = '/home/sk/ws/youtubeanalysis/youtube/download';
        searchDirInput.value = '/home/sk/ws/youtubeanalysis/youtube/download';
        saveSettings();
    }
}

// Load video files list
async function loadVideoFiles(folderPath) {
    console.log('🔍 loadVideoFiles 함수 호출됨, folderPath:', folderPath);
    const container = document.getElementById('video-list-container');
    const statusEl = document.getElementById('folder-status');

    if (!container) {
        console.error('❌ video-list-container 요소를 찾을 수 없습니다');
        return;
    }

    if (!statusEl) {
        console.error('❌ folder-status 요소를 찾을 수 없습니다');
        return;
    }

    try {
        container.innerHTML = '<div class="loading">📁 영상 파일을 불러오는 중...</div>';
        statusEl.textContent = '';
        console.log('📁 영상 파일 불러오기 시작...');

        const url = folderPath
            ? `/api/video-analyzer/videos?folder=${encodeURIComponent(folderPath)}`
            : '/api/video-analyzer/videos';

        console.log('🌐 API 호출:', url);
        const response = await fetch(url);

        if (!response.ok) {
            console.error('❌ 서버 응답 오류:', response.status);
            throw new Error(`서버 응답 오류: ${response.status}`);
        }

        const videos = await response.json();
        console.log(`✅ ${videos.length}개의 영상 파일 받음`);

        // 현재 폴더 경로 저장
        currentFolderPath = folderPath || '';

        // 저장된 순서 불러오기
        const orderedVideos = loadVideoListOrder(videos, currentFolderPath);

        displayVideoList(orderedVideos);

        if (videos.length > 0) {
            statusEl.textContent = `✓ ${videos.length}개의 영상 파일을 찾았습니다.`;
            statusEl.style.color = '#4ade80';
        } else {
            statusEl.textContent = '⚠ 영상 파일을 찾을 수 없습니다.';
            statusEl.style.color = '#fbbf24';
        }
    } catch (error) {
        console.error('❌ loadVideoFiles 오류:', error);
        container.innerHTML = '<div class="alert error">영상 파일을 불러올 수 없습니다: ' + error.message + '</div>';
        statusEl.textContent = '✗ 불러오기 실패';
        statusEl.style.color = '#ef4444';
    }
}

// 영상폴더 필드에서 경로를 가져와서 영상 목록 불러오기
async function loadVideoFilesFromFolder() {
    const folderPath = document.getElementById('video_path').value.trim();

    if (!folderPath) {
        const statusEl = document.getElementById('folder-status');
        statusEl.textContent = '⚠ 영상폴더 경로를 입력하세요.';
        statusEl.style.color = '#fbbf24';

        // 영상폴더 입력 필드에 포커스
        document.getElementById('video_path').focus();
        return;
    }

    await loadVideoFiles(folderPath);
}

// 선택된 영상 목록 관리
let selectedVideos = [];

// 전역 변수: 현재 영상 목록 저장
let currentVideoList = [];
let currentFolderPath = '';

// 영상 목록 드래그 앤 드롭 관련 전역 변수
let videoListDraggedElement = null;
let videoListDraggedIndex = null;

// 영상 순서를 localStorage에 저장
function saveVideoListOrder() {
    if (!currentFolderPath || currentVideoList.length === 0) return;

    const orderKey = 'videoListOrder_' + currentFolderPath;
    const videoPaths = currentVideoList.map(v => v.path);

    try {
        localStorage.setItem(orderKey, JSON.stringify(videoPaths));
        console.log('✅ 영상 순서 저장됨:', videoPaths.length, '개');
    } catch (e) {
        console.error('❌ 영상 순서 저장 실패:', e);
    }
}

// 저장된 영상 순서 불러오기
function loadVideoListOrder(videos, folderPath) {
    if (!folderPath || videos.length === 0) return videos;

    const orderKey = 'videoListOrder_' + folderPath;

    try {
        const savedOrderJson = localStorage.getItem(orderKey);
        if (!savedOrderJson) return videos;

        const savedPaths = JSON.parse(savedOrderJson);
        if (!Array.isArray(savedPaths) || savedPaths.length === 0) return videos;

        console.log('📂 저장된 영상 순서 불러오기:', savedPaths.length, '개');

        // 경로를 키로 하는 맵 생성
        const videoMap = new Map();
        videos.forEach(v => videoMap.set(v.path, v));

        // 저장된 순서대로 재정렬
        const reorderedVideos = [];
        savedPaths.forEach(path => {
            if (videoMap.has(path)) {
                reorderedVideos.push(videoMap.get(path));
                videoMap.delete(path);
            }
        });

        // 저장되지 않은 새로운 영상들은 뒤에 추가
        videoMap.forEach(v => reorderedVideos.push(v));

        console.log('✅ 영상 순서 복원 완료:', reorderedVideos.length, '개');
        return reorderedVideos;

    } catch (e) {
        console.error('❌ 영상 순서 불러오기 실패:', e);
        return videos;
    }
}

// 영상 목록 드래그 앤 드롭 이벤트 핸들러
function handleVideoListDragStart(event) {
    videoListDraggedElement = event.currentTarget;
    videoListDraggedIndex = parseInt(videoListDraggedElement.getAttribute('data-index'));
    event.currentTarget.style.opacity = '0.5';
    event.dataTransfer.effectAllowed = 'move';
}

function handleVideoListDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    return false;
}

function handleVideoListDragEnter(event) {
    const targetElement = event.currentTarget;
    if (targetElement !== videoListDraggedElement && targetElement.classList.contains('video-item')) {
        targetElement.style.borderTop = '3px solid #3b82f6';
    }
}

function handleVideoListDragLeave(event) {
    const targetElement = event.currentTarget;
    targetElement.style.borderTop = '';
}

function handleVideoListDrop(event) {
    event.preventDefault();
    event.stopPropagation();

    const dropTarget = event.currentTarget;
    dropTarget.style.borderTop = '';

    if (videoListDraggedElement === dropTarget) {
        return false;
    }

    const dropIndex = parseInt(dropTarget.getAttribute('data-index'));

    // 배열에서 드래그된 요소 제거
    const [removed] = currentVideoList.splice(videoListDraggedIndex, 1);

    // 새 위치에 삽입
    currentVideoList.splice(dropIndex, 0, removed);

    // 선택 상태 저장
    const selectedPaths = selectedVideos.map(v => v.path);

    // 영상 순서를 localStorage에 저장
    saveVideoListOrder();

    // 화면 갱신
    displayVideoList(currentVideoList);

    // 선택 상태 복원
    restoreVideoSelection(selectedPaths);

    return false;
}

function handleVideoListDragEnd(event) {
    event.currentTarget.style.opacity = '';

    // 모든 테두리 제거
    document.querySelectorAll('.video-item').forEach(item => {
        item.style.borderTop = '';
    });

    videoListDraggedElement = null;
    videoListDraggedIndex = null;
}

// 드래그 앤 드롭 후 선택 상태 복원
function restoreVideoSelection(selectedPaths) {
    const checkboxes = document.querySelectorAll('.video-checkbox');

    checkboxes.forEach(cb => {
        const path = cb.getAttribute('data-path');
        if (selectedPaths.includes(path)) {
            cb.checked = true;
        }
    });

    updateVideoSelection();
}

function displayVideoList(videos) {
    const container = document.getElementById('video-list-container');

    if (videos.length === 0) {
        container.innerHTML = '<div class="empty-state">영상 파일을 찾을 수 없습니다.</div>';
        return;
    }

    // 현재 영상 목록 저장
    currentVideoList = [...videos];

    // 선택 초기화
    selectedVideos = [];
    updateSelectedCount();

    let html = '<div class="video-list">';
    videos.forEach((video, index) => {
        const date = new Date(video.modified).toLocaleString('ko-KR');
        const escapedPath = video.path.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        const escapedDir = video.directory.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        const escapedName = video.name.replace(/'/g, "\\'");

        html += `
            <div class="video-item"
                 draggable="true"
                 data-index="${index}"
                 ondragstart="handleVideoListDragStart(event)"
                 ondragover="handleVideoListDragOver(event)"
                 ondrop="handleVideoListDrop(event)"
                 ondragend="handleVideoListDragEnd(event)"
                 ondragenter="handleVideoListDragEnter(event)"
                 ondragleave="handleVideoListDragLeave(event)">
                <div style="display: flex; align-items: center; gap: 10px; width: 100%;">
                    <span style="cursor: move; font-size: 1.2rem; color: #a0aec0; padding: 5px;" title="드래그하여 순서 변경">⋮⋮</span>
                    <input type="checkbox"
                           id="video-checkbox-${index}"
                           class="video-checkbox"
                           data-path="${escapedPath}"
                           data-name="${escapedName}"
                           data-dir="${escapedDir}"
                           onchange="updateVideoSelection()"
                           style="width: 20px; height: 20px; cursor: pointer;">
                    <div class="video-item-info" onclick="previewVideo('${escapedPath}', '${escapedName}', '${escapedDir}', '${video.subtitle_path ? video.subtitle_path.replace(/\\/g, '\\\\').replace(/'/g, "\\'") : ''}')" style="flex: 1; cursor: pointer;">
                        <div class="video-item-name">
                            📹 ${video.name}
                            ${video.has_subtitle ? '<span style="margin-left: 10px; padding: 2px 8px; background: #10b981; color: white; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">📌 제목자막</span>' : '<span style="margin-left: 10px; padding: 2px 8px; background: #6b7280; color: white; border-radius: 4px; font-size: 0.8rem;">❌ 자막 없음</span>'}
                        </div>
                        <div class="video-item-details">
                            <span class="video-item-size">${video.size_mb} MB</span>
                            <span class="video-item-date">${date}</span>
                        </div>
                        <div class="video-item-path">${video.directory}</div>
                    </div>
                    <button class="video-item-action" onclick="previewVideo('${escapedPath}', '${escapedName}', '${escapedDir}', '${video.subtitle_path ? video.subtitle_path.replace(/\\/g, '\\\\').replace(/'/g, "\\'") : ''}')">
                        영상 보기
                    </button>
                    ${video.has_subtitle ? `<button class="video-item-action" onclick="previewSubtitle('${video.subtitle_path.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}', '${escapedName}'); event.stopPropagation();" style="background: #10b981; margin-left: 5px;">📌 제목자막 미리보기</button>` : ''}
                    <button class="video-item-action" onclick="renameVideoFile('${escapedPath}', '${escapedName}', '${escapedDir}'); event.stopPropagation();" style="background: #3b82f6; margin-left: 5px;">
                        ✏️ 이름 바꾸기
                    </button>
                    <button class="video-item-action" onclick="deleteVideoFile('${escapedPath}', '${escapedName}'); event.stopPropagation();" style="background: #ef4444; margin-left: 5px;">
                        🗑️ 삭제
                    </button>
                </div>
            </div>
        `;
    });
    html += '</div>';

    container.innerHTML = html;
}

function updateVideoSelection() {
    selectedVideos = [];
    const checkboxes = document.querySelectorAll('.video-checkbox:checked');

    checkboxes.forEach(cb => {
        selectedVideos.push({
            path: cb.getAttribute('data-path'),
            name: cb.getAttribute('data-name'),
            directory: cb.getAttribute('data-dir')
        });
    });

    updateSelectedCount();
}

function updateSelectedCount() {
    const countEl = document.getElementById('selected-count');
    const mergeBtn = document.getElementById('merge-videos-btn');

    countEl.textContent = selectedVideos.length;

    // 2개 이상 선택되어야 합치기 버튼 표시
    if (selectedVideos.length >= 2) {
        mergeBtn.style.display = 'inline-block';
    } else {
        mergeBtn.style.display = 'none';
    }
}

// 전역 변수로 현재 선택된 영상 정보 저장
let currentVideoInfo = {
    path: '',
    name: '',
    directory: '',
    isLocal: false  // 로컬 파일인지 서버 파일인지 구분
};

async function previewVideo(videoPath, videoName, directory, subtitlePath) {
    // 현재 영상 정보 저장
    currentVideoInfo = {
        path: videoPath,
        name: videoName,
        directory: directory,
        isLocal: false,  // 서버 파일
        subtitlePath: subtitlePath || null
    };

    // 비디오 플레이어 설정
    const videoPlayer = document.getElementById('video-preview-player');
    const videoSource = document.getElementById('video-preview-source');
    const subtitleTrack = document.getElementById('video-subtitle-track');

    // 영상 파일을 서버에서 제공하는 URL로 변경
    // videoPath를 URL 인코딩하여 서버에 요청
    const encodedPath = encodeURIComponent(videoPath);
    videoSource.src = `/api/video-analyzer/stream?path=${encodedPath}`;

    // 자막 파일이 있으면 로드
    if (subtitlePath) {
        const encodedSubtitlePath = encodeURIComponent(subtitlePath);
        subtitleTrack.src = `/api/video-analyzer/stream?path=${encodedSubtitlePath}`;

        // 자막 트랙 활성화 - load() 호출 전에 설정
        subtitleTrack.default = true;
        subtitleTrack.mode = 'showing';

        console.log('📌 제목자막 로드됨:', subtitlePath);

        // 자막 파일을 loadedSubtitles에도 자동 로드
        try {
            const response = await fetch(`/api/video-analyzer/stream?path=${encodedSubtitlePath}`);
            if (response.ok) {
                const content = await response.text();
                parseSubtitle(content, 'main');  // 제목 자막을 main 트랙에 로드
                console.log('✅ 제목자막이 main 트랙에 자동 로드되었습니다');

                // 자막 체크박스 자동 활성화
                const mainSubtitleCheckbox = document.getElementById('track-main-subtitle-enable');
                if (mainSubtitleCheckbox) {
                    mainSubtitleCheckbox.checked = true;
                }
            }
        } catch (error) {
            console.error('❌ 제목자막 자동 로드 실패:', error);
        }
    } else {
        subtitleTrack.src = '';
        subtitleTrack.default = false;
        subtitleTrack.mode = 'hidden';
    }

    // 비디오 로드
    videoPlayer.load();

    // loadedmetadata 이벤트에서 자막 트랙 강제 활성화
    videoPlayer.addEventListener('loadedmetadata', () => {
        if (subtitlePath) {
            // 모든 자막 트랙을 확인하고 활성화
            const tracks = videoPlayer.textTracks;
            console.log('자막 트랙 개수:', tracks.length);

            for (let i = 0; i < tracks.length; i++) {
                tracks[i].mode = 'showing';
                console.log(`자막 트랙 ${i} 활성화:`, tracks[i]);
            }
        }
    }, { once: true });

    // 미리보기 정보 표시
    document.getElementById('preview-filename').textContent = videoName;
    document.getElementById('preview-filepath').textContent = videoPath;

    // 미리보기 섹션 표시
    document.getElementById('video-preview-section').style.display = 'block';

    // 미리보기 섹션으로 스크롤
    document.getElementById('video-preview-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

    // 비디오 정보 저장
    saveCurrentVideoInfo();
}

function useThisVideo() {
    // 로컬 파일인 경우 폼 제출
    if (currentVideoInfo.isLocal) {
        // 로컬 파일은 이미 video_file input에 선택되어 있으므로 폼 제출
        const form = document.querySelector('.analyzer-form');
        if (form) {
            alert('로컬 파일이 선택되어 있습니다. 자막 불러오기 버튼을 클릭하여 자막을 추출하세요.');
            // 페이지 맨 위로 스크롤
            window.scrollTo({ top: 0, behavior: 'smooth' });
            // 미리보기 닫기
            closeVideoPreview();
        }
        return;
    }

    // 서버 파일인 경우 경로 설정
    // 영상 파일의 전체 경로를 video_path에 설정
    document.getElementById('video_path').value = currentVideoInfo.path;

    // 자막 검색 디렉토리도 자동으로 설정
    document.getElementById('search_directory').value = currentVideoInfo.directory;

    // 자동 검색 체크박스 활성화
    document.querySelector('input[name="auto_search"]').checked = true;

    // 설정 저장
    saveSettings();

    // 자막 불러오기 폼 자동 제출
    const form = document.querySelector('.analyzer-form');
    if (form) {
        // 폼 제출 - 선택한 영상의 자막을 바로 불러옴
        form.submit();
    }
}

function closeVideoPreview() {
    const videoPlayer = document.getElementById('video-preview-player');
    videoPlayer.pause();
    videoPlayer.currentTime = 0;

    document.getElementById('video-preview-section').style.display = 'none';
}

// 진행률 모달 표시/숨김 함수
function showProgressModal() {
    document.getElementById('progress-modal').style.display = 'flex';
    updateProgress(0, '프리뷰 영상 생성 준비 중...');
}

function hideProgressModal() {
    document.getElementById('progress-modal').style.display = 'none';
}

function updateProgress(percentage, message) {
    document.getElementById('progress-percentage').textContent = percentage + '%';
    document.getElementById('progress-bar').style.width = percentage + '%';
    document.getElementById('progress-message').textContent = message;
}

function parsePixelValue(value) {
    const numeric = parseFloat(value);
    return Number.isFinite(numeric) ? numeric : 0;
}

function extractOutlineColor(computedStyle, overlayType) {
    if (!computedStyle) {
        return (overlayType === 'korean' || overlayType === 'english')
            ? 'rgba(255, 255, 255, 1)'
            : 'rgba(0, 0, 0, 0.85)';
    }

    const textShadow = computedStyle.textShadow;
    if (textShadow && textShadow !== 'none') {
        const matches = textShadow.match(/(rgba?\([^)]*\)|#[0-9a-fA-F]{3,8})/g);
        if (matches && matches.length) {
            const solid = matches.find((color) => !/rgba?\([^)]*,\s*0(?:\.0+)?\)/.test(color.trim()));
            return (solid || matches[0]).trim();
        }
    }

    return (overlayType === 'korean' || overlayType === 'english')
        ? 'rgba(255, 255, 255, 1)'
        : 'rgba(0, 0, 0, 0.85)';
}

async function createPreviewVideo() {
    if (!currentVideoInfo || !currentVideoInfo.path) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    // 비디오 플레이어 정보 가져오기
    const videoPlayer = document.getElementById('video-preview-player');
    const videoWidth = videoPlayer.videoWidth;
    const videoHeight = videoPlayer.videoHeight;
    const displayWidth = videoPlayer.offsetWidth;
    const displayHeight = videoPlayer.offsetHeight;

    if (!videoWidth || !videoHeight) {
        alert('영상이 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
        return;
    }

    console.log('📐 비디오 정보:', { videoWidth, videoHeight, displayWidth, displayHeight });

    // 진행률 모달 표시
    showProgressModal();

    // 오버레이 설정 수집 함수
    function getOverlaySettings(elementId, overlayType) {
        const element = document.getElementById(elementId);
        if (!element || element.style.display === 'none' || element.style.opacity === '0') {
            return null;
        }

        const rect = element.getBoundingClientRect();
        const videoRect = videoPlayer.getBoundingClientRect();

        // 비디오 플레이어 기준 상대 위치 계산
        const relativeX = (rect.left + rect.width / 2 - videoRect.left) / videoRect.width;
        const relativeY = (rect.top + rect.height / 2 - videoRect.top) / videoRect.height;

        // 텍스트 내용
        const text = element.textContent.trim();
        if (!text) {
            return null;
        }

        // 스타일 정보
        const computedStyle = window.getComputedStyle(element);
        const fontSize = parseInt(computedStyle.fontSize);
        const color = computedStyle.color;
        const fontWeight = computedStyle.fontWeight;
        const outlineColor = extractOutlineColor(computedStyle, overlayType);
        const fontFamily = computedStyle.fontFamily;
        const fontStyle = computedStyle.fontStyle;
        const letterSpacing = computedStyle.letterSpacing;
        const textShadow = computedStyle.textShadow;
        const backgroundColor = computedStyle.backgroundColor;
        const opacity = parseFloat(computedStyle.opacity || element.style.opacity || '1');
        const textAlign = computedStyle.textAlign;
        const textTransform = computedStyle.textTransform;
        const lineHeight = computedStyle.lineHeight;
        const padding = {
            top: parsePixelValue(computedStyle.paddingTop),
            right: parsePixelValue(computedStyle.paddingRight),
            bottom: parsePixelValue(computedStyle.paddingBottom),
            left: parsePixelValue(computedStyle.paddingLeft)
        };

        return {
            text: text,
            x: Math.round(relativeX * videoWidth),
            y: Math.round(relativeY * videoHeight),
            fontSize: Math.round(fontSize * videoWidth / displayWidth),
            color: color,
            fontWeight: fontWeight,
            outlineColor: outlineColor,
            fontFamily: fontFamily,
            fontStyle: fontStyle,
            letterSpacing: letterSpacing,
            textShadow: textShadow,
            backgroundColor: backgroundColor,
            opacity: Number.isFinite(opacity) ? opacity : 1,
            textAlign: textAlign,
            textTransform: textTransform,
            lineHeight: lineHeight,
            padding: padding,
            type: overlayType
        };
    }

    // 모든 오버레이 설정 수집
    const overlays = {
        title: getOverlaySettings('video-title-overlay', 'title'),
        subtitle: getOverlaySettings('video-subtitle-overlay', 'subtitle'),
        korean: getOverlaySettings('korean-subtitle-overlay', 'korean'),
        japanese: getOverlaySettings('japanese-subtitle-overlay', 'japanese'),
        english: getOverlaySettings('english-subtitle-overlay', 'english')
    };

    // 검정 배경 설정 수집
    const blackBars = {
        top: {
            enabled: document.getElementById('top-bar-enable').checked,
            height: parseInt(document.getElementById('top-bar-height').value),
            opacity: parseInt(document.getElementById('top-bar-opacity').value) / 100
        },
        bottom: {
            enabled: document.getElementById('bottom-bar-enable').checked,
            height: parseInt(document.getElementById('bottom-bar-height').value),
            opacity: parseInt(document.getElementById('bottom-bar-opacity').value) / 100
        }
    };

    // 트랙 체크박스 상태 확인 및 파일 경로 수집
    const tracks = {
        video: {
            enabled: document.getElementById('track-video-enable')?.checked || false,
            muted: document.getElementById('video-audio-mute')?.classList.contains('muted') || false
        },
        audio: {
            enabled: document.getElementById('track-audio-enable')?.checked || false,
            file: loadedMedia.audio?.file || null,
            fileName: loadedMedia.audio?.fileName || null
        },
        commentary: {
            enabled: document.getElementById('track-commentary-enable')?.checked || false,
            file: loadedMedia.commentary?.file || null,
            fileName: loadedMedia.commentary?.fileName || null
        },
        bgm: {
            enabled: document.getElementById('track-bgm-enable')?.checked || false,
            file: loadedMedia.bgm?.file || null,
            fileName: loadedMedia.bgm?.fileName || null
        },
        mainSubtitle: {
            enabled: document.getElementById('track-main-subtitle-enable')?.checked || false,
            data: loadedSubtitles.main || null
        },
        translationSubtitle: {
            enabled: document.getElementById('track-translation-subtitle-enable')?.checked || false,
            data: loadedSubtitles.translation || null
        },
        descriptionSubtitle: {
            enabled: document.getElementById('track-description-subtitle-enable')?.checked || false,
            data: loadedSubtitles.description || null
        }
    };

    console.log('📋 트랙 상태:', tracks);

    // API 요청 데이터
    const requestData = {
        video_path: currentVideoInfo.path,
        subtitle_path: currentVideoInfo.subtitlePath || null,
        video_width: videoWidth,
        video_height: videoHeight,
        overlays: overlays,
        black_bars: blackBars,
        tracks: {
            video: {
                enabled: tracks.video.enabled,
                muted: tracks.video.muted
            },
            mainSubtitle: tracks.mainSubtitle,
            translationSubtitle: tracks.translationSubtitle,
            descriptionSubtitle: tracks.descriptionSubtitle
        }
    };

    console.log('🎬 프리뷰 영상 생성 요청:', requestData);

    // 가짜 진행률 시뮬레이션 (실제 FFmpeg 진행률 대신)
    let progress = 0;
    const progressInterval = setInterval(() => {
        if (progress < 90) {
            progress += Math.random() * 10;
            if (progress > 90) progress = 90;
            updateProgress(Math.floor(progress), 'FFmpeg 처리 중...');
        }
    }, 500);

    try {
        updateProgress(10, '영상 처리 시작...');

        const response = await fetch('/api/video-analyzer/create-preview-video', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        });

        clearInterval(progressInterval);

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || '프리뷰 영상 생성 실패');
        }

        const result = await response.json();
        console.log('✅ 프리뷰 영상 생성 완료:', result);

        // 100% 완료 표시
        updateProgress(100, '완료!');

        // 잠시 후 모달 닫기
        setTimeout(() => {
            hideProgressModal();

            // 성공 메시지와 함께 다운로드 링크 제공
            const downloadPath = result.preview_path;
            const fileName = result.file_name;

            if (confirm(`프리뷰 영상이 생성되었습니다!\n파일명: ${fileName}\n\n지금 다운로드하시겠습니까?`)) {
                // 다운로드
                const encodedPath = encodeURIComponent(downloadPath);
                window.location.href = `/api/video-analyzer/download?path=${encodedPath}`;
            }

            // 생성된 프리뷰 영상을 영상 목록에서 확인할 수 있도록 안내
            alert('프리뷰 영상이 생성되었습니다.\n영상 목록을 새로고침하여 확인하세요.');
        }, 1000);

    } catch (error) {
        clearInterval(progressInterval);
        hideProgressModal();

        console.error('❌ 프리뷰 영상 생성 오류:', error);
        alert(`프리뷰 영상 생성 중 오류가 발생했습니다:\n${error.message}`);
    }
}

// 최종 영상 제작 (체크된 트랙만 포함)
async function createFinalVideo() {
    if (!currentVideoInfo || !currentVideoInfo.path) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    // 비디오 플레이어 정보 가져오기
    const videoPlayer = document.getElementById('video-preview-player');
    const videoWidth = videoPlayer.videoWidth;
    const videoHeight = videoPlayer.videoHeight;
    const displayWidth = videoPlayer.offsetWidth;
    const displayHeight = videoPlayer.offsetHeight;

    if (!videoWidth || !videoHeight) {
        alert('영상이 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
        return;
    }

    console.log('📐 비디오 정보:', { videoWidth, videoHeight, displayWidth, displayHeight });

    // 진행률 모달 표시
    showProgressModal();

    // 저장된 설정에서 원본 폰트 크기 가져오기
    let savedSettings = null;
    try {
        const saved = localStorage.getItem('videoAnalyzerTextOverlay');
        if (saved) {
            savedSettings = JSON.parse(saved);
        }
    } catch (e) {
        console.error('설정 로드 실패:', e);
    }

    // 오버레이 설정 수집 함수
    function getOverlaySettings(elementId, overlayType, savedSize) {
        const element = document.getElementById(elementId);
        if (!element || element.style.display === 'none' || element.style.opacity === '0') {
            return null;
        }

        const rect = element.getBoundingClientRect();
        const videoRect = videoPlayer.getBoundingClientRect();

        // 비디오 플레이어 기준 상대 위치 계산
        const relativeX = (rect.left + rect.width / 2 - videoRect.left) / videoRect.width;
        const relativeY = (rect.top + rect.height / 2 - videoRect.top) / videoRect.height;

        // 텍스트 내용
        const text = element.textContent.trim();
        if (!text) {
            return null;
        }

        // 스타일 정보
        const computedStyle = window.getComputedStyle(element);
        const color = computedStyle.color;
        const fontWeight = computedStyle.fontWeight;
        const outlineColor = extractOutlineColor(computedStyle, overlayType);
        const fontFamily = computedStyle.fontFamily;
        const fontStyle = computedStyle.fontStyle;
        const letterSpacing = computedStyle.letterSpacing;
        const textShadow = computedStyle.textShadow;
        const backgroundColor = computedStyle.backgroundColor;
        const opacity = parseFloat(computedStyle.opacity || element.style.opacity || '1');
        const textAlign = computedStyle.textAlign;
        const textTransform = computedStyle.textTransform;
        const lineHeight = computedStyle.lineHeight;
        const padding = {
            top: parsePixelValue(computedStyle.paddingTop),
            right: parsePixelValue(computedStyle.paddingRight),
            bottom: parsePixelValue(computedStyle.paddingBottom),
            left: parsePixelValue(computedStyle.paddingLeft)
        };

        // 폰트 크기: 저장된 설정 값 사용 (스케일링 없이 원본 크기 유지)
        // 저장된 설정이 없으면 현재 표시된 크기를 비디오 해상도에 맞게 스케일링
        let fontSize;
        if (savedSize) {
            fontSize = parseInt(savedSize);
            console.log(`📏 ${overlayType} 폰트 크기: ${fontSize}px (저장된 설정 사용)`);
        } else {
            const displayFontSize = parseInt(computedStyle.fontSize);
            fontSize = Math.round(displayFontSize * videoWidth / displayWidth);
            console.log(`📏 ${overlayType} 폰트 크기: ${fontSize}px (스케일링: ${displayFontSize}px → ${fontSize}px)`);
        }

        return {
            text: text,
            x: Math.round(relativeX * videoWidth),
            y: Math.round(relativeY * videoHeight),
            fontSize: fontSize,
            color: color,
            fontWeight: fontWeight,
            type: overlayType,
            outlineColor: outlineColor,
            fontFamily: fontFamily,
            fontStyle: fontStyle,
            letterSpacing: letterSpacing,
            textShadow: textShadow,
            backgroundColor: backgroundColor,
            opacity: Number.isFinite(opacity) ? opacity : 1,
            textAlign: textAlign,
            textTransform: textTransform,
            lineHeight: lineHeight,
            padding: padding
        };
    }

    const canvasElement = document.getElementById('video-canvas-preview');
    const isCanvasActive = canvasElement && canvasElement.style.display !== 'none';

    const overlays = {};

    // Canvas가 활성화되어 있으면 Canvas 오버레이만 사용
    if (canvasPreview && isCanvasActive && Array.isArray(canvasPreview.overlays) && canvasPreview.overlays.length > 0) {
        console.log('🎨 Canvas 오버레이 사용 (CSS 오버레이 무시)');
        console.log('📦 canvasPreview.overlays 원본:', canvasPreview.overlays);

        // Canvas 오버레이 데이터를 직접 사용
        canvasPreview.overlays.forEach((overlay, index) => {
            const overlayType = overlay.type || `overlay_${index}`;

            const canvasData = {
                text: overlay.text,
                x: Math.round(overlay.x ?? videoWidth / 2),
                y: Math.round(overlay.y ?? videoHeight / 2),
                fontSize: overlay.fontSize || 48,
                color: overlay.color || '#ffffff',
                fontWeight: overlay.fontWeight || 'bold',
                type: overlayType,
                outlineColor: overlay.borderColor || '#000000',
                fontFamily: overlay.fontFamily || 'Noto Sans KR',
                opacity: overlay.opacity !== undefined ? overlay.opacity : 1
            };

            overlays[overlayType] = canvasData;
            console.log(`  ✅ [${index}] ${overlayType}: text="${overlay.text?.substring(0, 20)}...", pos=(${canvasData.x}, ${canvasData.y}), y%=${(canvasData.y/videoHeight*100).toFixed(1)}%`);
        });
    } else {
        // Canvas가 비활성화되어 있으면 CSS 오버레이 사용
        console.log('📄 CSS 오버레이 사용 (Canvas 비활성화)');

        const appendOverlayFromDom = (elementId, overlayType, savedSize) => {
            const overlayData = getOverlaySettings(elementId, overlayType, savedSize);
            if (overlayData) {
                overlays[overlayType] = overlayData;
            }
        };

        appendOverlayFromDom('video-title-overlay', 'title', savedSettings?.title?.size);
        appendOverlayFromDom('video-subtitle-overlay', 'subtitle', savedSettings?.subtitle?.size);
        appendOverlayFromDom('korean-subtitle-overlay', 'korean', savedSettings?.korean?.size);
        appendOverlayFromDom('japanese-subtitle-overlay', 'japanese', savedSettings?.japanese?.size);
        appendOverlayFromDom('english-subtitle-overlay', 'english', savedSettings?.english?.size);
        appendOverlayFromDom('source-overlay', 'source', savedSettings?.source?.size);
    }

    const filteredOverlays = Object.fromEntries(
        Object.entries(overlays).filter(([, value]) => value && typeof value.text === 'string' && value.text.trim().length > 0)
    );

    console.log('📝 수집된 오버레이 (필터링 전):', overlays);
    console.log('📝 수집된 오버레이 (필터링 후):', filteredOverlays);
    console.log('🎨 Canvas 활성화 상태:', isCanvasActive);
    console.log('🎨 Canvas 오버레이 개수:', canvasPreview?.overlays?.length || 0);

    // 검정 배경 설정 수집
    const blackBars = {
        top: {
            enabled: document.getElementById('top-bar-enable').checked,
            height: parseInt(document.getElementById('top-bar-height').value),
            opacity: parseInt(document.getElementById('top-bar-opacity').value) / 100
        },
        bottom: {
            enabled: document.getElementById('bottom-bar-enable').checked,
            height: parseInt(document.getElementById('bottom-bar-height').value),
            opacity: parseInt(document.getElementById('bottom-bar-opacity').value) / 100
        }
    };

    // 트랙 체크박스 상태 확인 및 파일 경로 수집
    const tracks = {
        video: {
            enabled: document.getElementById('track-video-enable')?.checked || false,
            muted: document.getElementById('video-audio-mute')?.classList.contains('muted') || false
        },
        audio: {
            enabled: document.getElementById('track-audio-enable')?.checked || false,
            file: loadedMedia.audio?.file || null,
            fileName: loadedMedia.audio?.fileName || null
        },
        commentary: {
            enabled: document.getElementById('track-commentary-enable')?.checked || false,
            file: loadedMedia.commentary?.file || null,
            fileName: loadedMedia.commentary?.fileName || null
        },
        bgm: {
            enabled: document.getElementById('track-bgm-enable')?.checked || false,
            file: loadedMedia.bgm?.file || null,
            fileName: loadedMedia.bgm?.fileName || null
        },
        mainSubtitle: {
            enabled: document.getElementById('track-main-subtitle-enable')?.checked || false,
            data: loadedSubtitles.main || null
        },
        translationSubtitle: {
            enabled: document.getElementById('track-translation-subtitle-enable')?.checked || false,
            data: loadedSubtitles.translation || null
        },
        descriptionSubtitle: {
            enabled: document.getElementById('track-description-subtitle-enable')?.checked || false,
            data: loadedSubtitles.description || null
        }
    };

    console.log('📋 트랙 상태:', tracks);

    // 자막 템플릿 설정 수집
    const subtitleTemplate = document.querySelector('input[name="subtitle-template-video"]:checked')?.value || 'classic';
    const bannerPrimaryText = document.getElementById('banner-primary-video')?.value || '';
    const bannerSecondaryText = document.getElementById('banner-secondary-video')?.value || '';

    const subtitleStyleSettings = {
        template: subtitleTemplate,
        banner_primary_text: bannerPrimaryText || null,
        banner_secondary_text: bannerSecondaryText || null
    };

    console.log('🎭 자막 템플릿 설정:', subtitleStyleSettings);

    // Canvas 자막 위치 정보 수집
    const canvasSubtitlePositions = canvasPreview ? {
        main: {
            yPosition: canvasPreview.subtitleStyles.main.yPosition,
            fontSize: canvasPreview.subtitleStyles.main.fontSize,
            color: canvasPreview.subtitleStyles.main.color,
            borderWidth: canvasPreview.subtitleStyles.main.borderWidth,
            borderColor: canvasPreview.subtitleStyles.main.borderColor
        },
        translation: {
            yPosition: canvasPreview.subtitleStyles.translation.yPosition,
            fontSize: canvasPreview.subtitleStyles.translation.fontSize,
            color: canvasPreview.subtitleStyles.translation.color,
            borderWidth: canvasPreview.subtitleStyles.translation.borderWidth,
            borderColor: canvasPreview.subtitleStyles.translation.borderColor
        },
        description: {
            yPosition: canvasPreview.subtitleStyles.description.yPosition,
            fontSize: canvasPreview.subtitleStyles.description.fontSize,
            color: canvasPreview.subtitleStyles.description.color,
            borderWidth: canvasPreview.subtitleStyles.description.borderWidth,
            borderColor: canvasPreview.subtitleStyles.description.borderColor
        }
    } : null;

    console.log('📍 Canvas 자막 위치 정보:', canvasSubtitlePositions);

    // FormData 생성 (파일 업로드를 위해)
    const formData = new FormData();
    formData.append('video_path', currentVideoInfo.path);
    formData.append('video_width', videoWidth);
    formData.append('video_height', videoHeight);
    formData.append('overlays', JSON.stringify(filteredOverlays));
    formData.append('black_bars', JSON.stringify(blackBars));
    formData.append('subtitle_style', JSON.stringify(subtitleStyleSettings));
    formData.append('canvas_subtitle_positions', JSON.stringify(canvasSubtitlePositions));
    formData.append('tracks', JSON.stringify({
        video: tracks.video,
        mainSubtitle: tracks.mainSubtitle,
        translationSubtitle: tracks.translationSubtitle,
        descriptionSubtitle: tracks.descriptionSubtitle
    }));

    // 음성 파일 추가 (체크된 트랙만)
    if (tracks.audio.enabled && tracks.audio.file) {
        formData.append('audio_file', tracks.audio.file, tracks.audio.fileName);
    }
    if (tracks.commentary.enabled && tracks.commentary.file) {
        formData.append('commentary_file', tracks.commentary.file, tracks.commentary.fileName);
    }
    if (tracks.bgm.enabled && tracks.bgm.file) {
        formData.append('bgm_file', tracks.bgm.file, tracks.bgm.fileName);
    }

    // 가짜 진행률 시뮬레이션
    let progress = 0;
    const progressInterval = setInterval(() => {
        if (progress < 90) {
            progress += Math.random() * 10;
            if (progress > 90) progress = 90;
            updateProgress(Math.floor(progress), 'FFmpeg로 영상 합성 중...');
        }
    }, 500);

    try {
        updateProgress(10, '최종 영상 제작 시작...');

        const response = await fetch('/api/video-analyzer/create-final-video', {
            method: 'POST',
            body: formData
        });

        clearInterval(progressInterval);

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || '최종 영상 생성 실패');
        }

        const result = await response.json();
        console.log('✅ 최종 영상 생성 완료:', result);

        // 100% 완료 표시
        updateProgress(100, '완료!');

        // 잠시 후 모달 닫기
        setTimeout(() => {
            hideProgressModal();

            // 성공 메시지와 함께 다운로드 링크 제공
            const downloadPath = result.output_path;
            const fileName = result.file_name;
            const subtitles = result.subtitles || {};

            // 자막 파일 정보 생성
            let subtitleInfo = '';
            const subtitleTypes = {
                'translation': '주자막 (2-1)',
                'description': '보조자막 (2-2)',
                'japanese': '일본어자막',
                'main': '메인자막'
            };

            if (Object.keys(subtitles).length > 0) {
                subtitleInfo = '\n\n📝 생성된 자막 파일:\n';
                Object.keys(subtitles).forEach(type => {
                    const label = subtitleTypes[type] || type;
                    subtitleInfo += `  - ${label}\n`;
                });
            }

            if (confirm(`최종 영상이 생성되었습니다!\n파일명: ${fileName}${subtitleInfo}\n\n지금 비디오를 다운로드하시겠습니까?`)) {
                // 비디오 다운로드
                const encodedPath = encodeURIComponent(downloadPath);
                window.location.href = `/api/video-analyzer/download?path=${encodedPath}`;

                // 자막 파일도 다운로드
                if (Object.keys(subtitles).length > 0) {
                    setTimeout(() => {
                        if (confirm('자막 파일도 다운로드하시겠습니까?')) {
                            Object.entries(subtitles).forEach(([type, path], index) => {
                                setTimeout(() => {
                                    const encodedSubPath = encodeURIComponent(path);
                                    const link = document.createElement('a');
                                    link.href = `/api/video-analyzer/download?path=${encodedSubPath}`;
                                    link.download = '';
                                    link.click();
                                }, index * 500); // 500ms 간격으로 다운로드
                            });
                        }
                    }, 1000);
                }
            }

            alert('최종 영상이 생성되었습니다.\n영상 목록을 새로고침하여 확인하세요.');
        }, 1000);

    } catch (error) {
        clearInterval(progressInterval);
        hideProgressModal();

        console.error('❌ 최종 영상 생성 오류:', error);
        alert(`최종 영상 생성 중 오류가 발생했습니다:\n${error.message}`);
    }
}

function selectVideo(videoPath, directory) {
    // 이전 함수 호환성을 위해 유지
    document.getElementById('video_path').value = videoPath;
    document.getElementById('search_directory').value = directory;
    document.querySelector('input[name="auto_search"]').checked = true;
    saveSettings();
    window.scrollTo({ top: 0, behavior: 'smooth' });

    const videoPathInput = document.getElementById('video_path');
    videoPathInput.style.background = 'rgba(100, 180, 255, 0.1)';
    setTimeout(() => {
        videoPathInput.style.background = '';
    }, 1000);
}

// 입력 필드 변경 시 자동 저장
function setupAutoSave() {
    const videoPathInput = document.getElementById('video_path');
    const searchDirInput = document.getElementById('search_directory');
    const autoSearchCheckbox = document.querySelector('input[name="auto_search"]');

    // 입력 필드가 변경되면 저장
    videoPathInput.addEventListener('input', saveSettings);
    searchDirInput.addEventListener('input', saveSettings);
    autoSearchCheckbox.addEventListener('change', saveSettings);

    // 영상폴더 입력 필드에서 Enter 키를 누르면 목록 불러오기
    videoPathInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            loadVideoFilesFromFolder();
        }
    });
}

// 영상 파일 선택 시 미리보기
function handleVideoFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    // 비디오 파일인지 확인
    if (!file.type.startsWith('video/')) {
        alert('비디오 파일을 선택해주세요.');
        return;
    }

    // 로컬 파일 URL 생성
    const fileURL = URL.createObjectURL(file);

    // 미리보기 섹션 표시
    const videoPlayer = document.getElementById('video-preview-player');
    const videoSource = document.getElementById('video-preview-source');

    videoSource.src = fileURL;
    videoPlayer.load();

    // 미리보기 정보 표시
    document.getElementById('preview-filename').textContent = file.name;
    document.getElementById('preview-filepath').textContent = '로컬 파일: ' + file.name;

    // 미리보기 섹션 표시
    document.getElementById('video-preview-section').style.display = 'block';

    // 현재 영상 정보 저장
    currentVideoInfo = {
        path: file.name,
        name: file.name,
        directory: '',
        isLocal: true  // 로컬 파일
    };

    // 미리보기 섹션으로 스크롤
    document.getElementById('video-preview-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

    // 영상 파일 목록에 선택된 파일만 표시
    displaySingleVideoInList(file);

    // 비디오 정보 저장 (로컬 파일은 경로만 저장)
    saveCurrentVideoInfo();
}

// 선택된 영상 파일만 목록에 표시
function displaySingleVideoInList(file) {
    const container = document.getElementById('video-list-container');
    const statusEl = document.getElementById('folder-status');

    const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
    const date = new Date(file.lastModified).toLocaleString('ko-KR');

    const html = `
        <div class="video-list">
            <div class="video-item" style="border: 2px solid #667eea;">
                <div class="video-item-info">
                    <div class="video-item-name">📹 ${file.name} <span style="color: #4ade80; margin-left: 10px;">✓ 선택됨</span></div>
                    <div class="video-item-details">
                        <span class="video-item-size">${sizeMB} MB</span>
                        <span class="video-item-date">${date}</span>
                    </div>
                    <div class="video-item-path">로컬 파일</div>
                </div>
            </div>
        </div>
    `;

    container.innerHTML = html;
    statusEl.textContent = '✓ 선택된 영상 파일';
    statusEl.style.color = '#4ade80';
}

// 프레임 추출 함수들
async function extractFirstFrame() {
    const videoPath = currentVideoInfo.path;
    if (!videoPath) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    // 로컬 파일인 경우 브라우저에서 직접 프레임 추출
    if (currentVideoInfo.isLocal) {
        extractFrameFromVideoElement(0, '맨 앞 프레임 (0초)');
        return;
    }

    // 서버 파일인 경우 API 호출
    try {
        const response = await fetch('/api/video-analyzer/extract-frame', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                frame_type: 'first'
            })
        });

        if (!response.ok) {
            throw new Error('프레임 추출 실패');
        }

        const result = await response.json();
        displayExtractedFrame(result.frame_data, '맨 앞 프레임 (0초)');
    } catch (error) {
        console.error('Error:', error);
        alert('맨 앞 프레임 추출에 실패했습니다.');
    }
}

async function extractLastFrame() {
    const videoPath = currentVideoInfo.path;
    if (!videoPath) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    // 로컬 파일인 경우 브라우저에서 직접 프레임 추출
    if (currentVideoInfo.isLocal) {
        const video = document.getElementById('video-preview-player');
        const lastTime = video.duration - 0.1;
        extractFrameFromVideoElement(lastTime, `맨 뒤 프레임 (${lastTime.toFixed(1)}초)`);
        return;
    }

    // 서버 파일인 경우 API 호출
    try {
        const response = await fetch('/api/video-analyzer/extract-frame', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                frame_type: 'last'
            })
        });

        if (!response.ok) {
            throw new Error('프레임 추출 실패');
        }

        const result = await response.json();
        displayExtractedFrame(result.frame_data, `맨 뒤 프레임 (${result.timestamp}초)`);
    } catch (error) {
        console.error('Error:', error);
        alert('맨 뒤 프레임 추출에 실패했습니다.');
    }
}

// 간격 증가 함수
function increaseInterval() {
    const input = document.getElementById('frame-interval');
    let currentValue = parseInt(input.value) || 5;
    if (currentValue < 60) {
        input.value = currentValue + 1;
    }
}

// 간격 감소 함수
function decreaseInterval() {
    const input = document.getElementById('frame-interval');
    let currentValue = parseInt(input.value) || 5;
    if (currentValue > 1) {
        input.value = currentValue - 1;
    }
}

// 각 영상마다 추출할 프레임 개수 증가
function increaseSegmentFrames() {
    const input = document.getElementById('frames-per-segment');
    let currentValue = parseInt(input.value) || 2;
    if (currentValue < 10) {
        input.value = currentValue + 1;
    }
}

// 각 영상마다 추출할 프레임 개수 감소
function decreaseSegmentFrames() {
    const input = document.getElementById('frames-per-segment');
    let currentValue = parseInt(input.value) || 2;
    if (currentValue > 1) {
        input.value = currentValue - 1;
    }
}

// 각 영상 구간마다 균등하게 프레임 추출
async function extractFramesBySegments() {
    const videoPath = currentVideoInfo.path;
    if (!videoPath) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    const framesPerSegment = parseInt(document.getElementById('frames-per-segment').value) || 2;

    if (framesPerSegment < 1 || framesPerSegment > 10) {
        alert('개수는 1개에서 10개 사이로 설정해주세요.');
        return;
    }

    // 자막 파일 경로 자동 생성 또는 입력받기
    let subtitlePath = currentVideoInfo.directory ?
        `${currentVideoInfo.directory}/${currentVideoInfo.name.replace(/\.[^.]+$/, '.srt')}` :
        '';

    subtitlePath = prompt('자막 파일 경로를 입력하세요 (merge된 영상의 자막 파일):', subtitlePath);

    if (!subtitlePath) {
        return; // 취소한 경우
    }

    // 기존 프레임 갤러리 초기화
    const framesGrid = document.getElementById('frames-grid');
    framesGrid.innerHTML = '';

    try {
        // 서버 API 호출
        const response = await fetch('/api/video-analyzer/extract-frames-by-segments', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                subtitle_path: subtitlePath,
                frames_per_segment: framesPerSegment
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || '프레임 추출 실패');
        }

        const result = await response.json();

        // 모든 프레임 표시
        result.frames.forEach((frame) => {
            const label = `[${frame.segment_index}] ${frame.timestamp}초 (${frame.frame_in_segment}/${framesPerSegment})`;
            displayExtractedFrame(frame.frame_data, label);
        });

        alert(`총 ${result.total_segments}개 영상에서 각각 ${framesPerSegment}개씩, 총 ${result.total_frames}개의 프레임을 추출했습니다.`);
    } catch (error) {
        console.error('Error:', error);
        alert('각 영상마다 프레임 추출에 실패했습니다: ' + error.message);
    }
}

// 현재 설정된 간격으로 프레임 추출
async function extractFramesByCurrentInterval() {
    const input = document.getElementById('frame-interval');
    const intervalSeconds = parseInt(input.value) || 5;

    if (intervalSeconds < 1 || intervalSeconds > 60) {
        alert('간격은 1초에서 60초 사이로 설정해주세요.');
        return;
    }

    await extractFramesByInterval(intervalSeconds);
}

async function extractFramesByInterval(intervalSeconds) {
    const videoPath = currentVideoInfo.path;
    if (!videoPath) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    // 기존 프레임 갤러리 초기화
    const framesGrid = document.getElementById('frames-grid');
    framesGrid.innerHTML = '';

    // 로컬 파일인 경우 브라우저에서 직접 프레임 추출
    if (currentVideoInfo.isLocal) {
        const video = document.getElementById('video-preview-player');
        const duration = video.duration;
        let frameCount = 0;
        let times = [];

        // 0초부터 interval 간격으로 추가
        for (let time = 0; time < duration; time += intervalSeconds) {
            times.push(time);
        }

        // 마지막 프레임 추가 (duration이 interval의 배수가 아닐 경우)
        if (times[times.length - 1] < duration - 0.1) {
            times.push(duration - 0.1);
        }

        // 모든 프레임 추출
        for (let time of times) {
            await extractFrameFromVideoElement(time, `${time.toFixed(1)}초`);
            frameCount++;
        }

        alert(`${frameCount}개의 프레임을 ${intervalSeconds}초 간격으로 추출했습니다.`);
        return;
    }

    // 서버 파일인 경우 API 호출
    try {
        const response = await fetch('/api/video-analyzer/extract-frames-interval', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                interval: intervalSeconds
            })
        });

        if (!response.ok) {
            throw new Error('프레임 추출 실패');
        }

        const result = await response.json();

        // 모든 프레임 표시
        result.frames.forEach((frame, index) => {
            displayExtractedFrame(frame.frame_data, `${frame.timestamp}초`);
        });

        alert(`${result.frames.length}개의 프레임을 ${intervalSeconds}초 간격으로 추출했습니다.`);
    } catch (error) {
        console.error('Error:', error);
        alert('프레임 추출에 실패했습니다.');
    }
}

// 자막 기준 프레임 추출
async function extractFramesBySubtitles() {
    const videoPath = currentVideoInfo.path;
    if (!videoPath) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    // 자막 파일 경로 입력 받기
    let subtitlePath = prompt('자막 파일 경로를 입력하세요:', currentVideoInfo.directory ? `${currentVideoInfo.directory}/${currentVideoInfo.name.replace(/\.[^.]+$/, '.srt')}` : '');

    if (!subtitlePath) {
        return; // 취소한 경우
    }

    // 기존 프레임 갤러리 초기화
    const framesGrid = document.getElementById('frames-grid');
    framesGrid.innerHTML = '';

    try {
        // 자막 정보 가져오기
        const response = await fetch('/api/video-analyzer/get-subtitle-times', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                subtitle_path: subtitlePath
            })
        });

        if (!response.ok) {
            throw new Error('자막 파일을 읽을 수 없습니다.');
        }

        const result = await response.json();
        const times = result.times;

        if (times.length === 0) {
            alert('자막 시간 정보를 찾을 수 없습니다.');
            return;
        }

        // 로컬 파일인 경우 브라우저에서 직접 프레임 추출
        if (currentVideoInfo.isLocal) {
            let frameCount = 0;
            for (let time of times) {
                await extractFrameFromVideoElement(time, `${time.toFixed(1)}초 (자막)`);
                frameCount++;
            }
            alert(`${frameCount}개의 프레임을 추출했습니다.`);
            return;
        }

        // 서버 파일인 경우 API 호출
        const extractResponse = await fetch('/api/video-analyzer/extract-frames-by-times', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                times: times
            })
        });

        if (!extractResponse.ok) {
            throw new Error('프레임 추출 실패');
        }

        const extractResult = await extractResponse.json();

        // 모든 프레임 표시
        extractResult.frames.forEach((frame, index) => {
            displayExtractedFrame(frame.frame_data, `${frame.timestamp.toFixed(1)}초 (자막)`);
        });

        alert(`${extractResult.frames.length}개의 프레임을 추출했습니다.`);
    } catch (error) {
        console.error('Error:', error);
        alert('자막 기준 프레임 추출에 실패했습니다: ' + error.message);
    }
}

// 자막 기준 영상 자르기
async function extractVideoClipsBySubtitles() {
    const videoPath = currentVideoInfo.path;
    if (!videoPath) {
        alert('먼저 영상을 선택해주세요.');
        return;
    }

    if (currentVideoInfo.isLocal) {
        alert('로컬 파일은 지원하지 않습니다. 서버에 있는 영상 파일을 선택해주세요.');
        return;
    }

    // 자막 파일 경로 입력 받기
    let subtitlePath = prompt('자막 파일 경로를 입력하세요:', currentVideoInfo.directory ? `${currentVideoInfo.directory}/${currentVideoInfo.name.replace(/\.[^.]+$/, '.srt')}` : '');

    if (!subtitlePath) {
        return; // 취소한 경우
    }

    try {
        alert('영상을 자르는 중입니다. 시간이 걸릴 수 있습니다...');

        // 서버에서 자막 기준 영상 자르기
        const response = await fetch('/api/video-analyzer/cut-by-subtitles', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                subtitle_path: subtitlePath
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || '영상 자르기 실패');
        }

        // ZIP 파일 다운로드
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${currentVideoInfo.name.replace(/\.[^.]+$/, '')}_clips.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);

        alert('영상 클립이 성공적으로 다운로드되었습니다!');
    } catch (error) {
        console.error('Error:', error);
        alert('영상 자르기에 실패했습니다: ' + error.message);
    }
}

// 비디오 요소에서 특정 시간의 프레임을 추출하는 함수
async function extractFrameFromVideoElement(time, label) {
    return new Promise((resolve, reject) => {
        const video = document.getElementById('video-preview-player');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // 비디오가 준비되지 않은 경우
        if (video.readyState < 2) {
            alert('비디오가 아직 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
            reject('Video not ready');
            return;
        }

        // 캔버스 크기를 비디오 크기로 설정
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        // 특정 시간으로 이동
        video.currentTime = time;

        // seeked 이벤트: 비디오가 특정 시간으로 이동했을 때
        const onSeeked = () => {
            video.removeEventListener('seeked', onSeeked);

            // 캔버스에 현재 프레임 그리기
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 캔버스를 Base64 이미지로 변환
            canvas.toBlob((blob) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // data:image/jpeg;base64, 부분 제거
                    const base64data = reader.result.split(',')[1];
                    displayExtractedFrame(base64data, label, time);
                    resolve();
                };
                reader.readAsDataURL(blob);
            }, 'image/jpeg', 0.95);
        };

        video.addEventListener('seeked', onSeeked);
    });
}

function displayExtractedFrame(frameData, label, time) {
    const framesGrid = document.getElementById('frames-grid');
    const gallery = document.getElementById('extracted-frames-gallery');

    const frameItem = document.createElement('div');
    frameItem.className = 'frame-item';
    frameItem.draggable = true;
    frameItem.style.cssText = 'border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden; background: rgba(0,0,0,0.3); cursor: move; transition: all 0.2s;';
    frameItem.dataset.frame = frameData;
    frameItem.dataset.label = label;
    frameItem.dataset.time = time; // 타임스탬프 저장

    frameItem.innerHTML = `
        <div style="background: rgba(102, 126, 234, 0.2); padding: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: #667eea;">
            <input type="checkbox" class="frame-select-checkbox" checked style="margin-left: 5px; width: 16px; height: 16px; cursor: pointer;" onchange="updateFrameAnalysisCost()">
            <span style="cursor: move; flex: 1; text-align: center;">⋮⋮ 드래그하여 순서 변경</span>
        </div>
        <img src="data:image/jpeg;base64,${frameData}" style="width: 100%; height: auto; display: block;" alt="${label}">
        <div style="padding: 8px; text-align: center;">
            <div style="color: #e0e6ed; font-size: 0.9rem; margin-bottom: 8px;">${label}</div>
            <div style="display: flex; gap: 5px; justify-content: center;">
                <button onclick="downloadFrame(this)" class="btn-secondary" style="padding: 4px 8px; font-size: 0.85rem; background: #667eea;" data-frame="${frameData}">📥 다운로드</button>
                <button onclick="deleteFrame(this)" class="btn-secondary" style="padding: 4px 8px; font-size: 0.85rem; background: #ef4444;">🗑️ 삭제</button>
            </div>
        </div>
    `;

    // 드래그 이벤트 핸들러 추가
    frameItem.addEventListener('dragstart', handleDragStart);
    frameItem.addEventListener('dragover', handleDragOver);
    frameItem.addEventListener('drop', handleDrop);
    frameItem.addEventListener('dragenter', handleDragEnter);
    frameItem.addEventListener('dragleave', handleDragLeave);
    frameItem.addEventListener('dragend', handleDragEnd);

    framesGrid.appendChild(frameItem);
    gallery.style.display = 'block';

    // 프레임 저장
    saveExtractedFrames();
}

function downloadFrame(button) {
    const frameData = button.getAttribute('data-frame');
    const link = document.createElement('a');
    link.href = `data:image/jpeg;base64,${frameData}`;
    link.download = `frame_${Date.now()}.jpg`;
    link.click();
}

function deleteFrame(button) {
    // 프레임 아이템 찾기
    const frameItem = button.closest('.frame-item');

    if (frameItem) {
        // 삭제 확인
        if (confirm('이 프레임을 삭제하시겠습니까?')) {
            frameItem.remove();

            // 갤러리가 비어있으면 숨기기
            const framesGrid = document.getElementById('frames-grid');
            const gallery = document.getElementById('extracted-frames-gallery');

            if (framesGrid.children.length === 0) {
                gallery.style.display = 'none';
            }

            // 프레임 저장
            saveExtractedFrames();
        }
    }
}

// 추출된 프레임 일괄 저장
async function downloadAllFrames() {
    const frameItems = document.querySelectorAll('.frame-item');

    // 프레임이 없으면 리턴
    if (frameItems.length === 0) {
        alert('저장할 프레임이 없습니다.');
        return;
    }

    // 저장 방식 선택 (개별 파일 또는 ZIP 압축)
    const useZip = frameItems.length > 5; // 5개 초과 시 ZIP 사용 권장
    let downloadMethod = 'zip'; // 기본값: ZIP

    if (frameItems.length <= 5) {
        // 5개 이하일 때는 사용자에게 선택권 제공
        const userChoice = confirm(
            `${frameItems.length}개의 프레임을 저장합니다.\n\n` +
            `[확인] ZIP 파일로 압축하여 저장 (권장)\n` +
            `[취소] 개별 파일로 저장`
        );
        downloadMethod = userChoice ? 'zip' : 'individual';
    } else {
        // 5개 초과 시 ZIP만 사용 (브라우저 다운로드 제한 방지)
        if (!confirm(`${frameItems.length}개의 프레임을 ZIP 파일로 압축하여 저장하시겠습니까?\n\n💡 프레임이 많아 브라우저 다운로드 제한을 방지하기 위해 ZIP 파일로 저장합니다.`)) {
            return;
        }
    }

    // 현재 영상 이름 가져오기 (파일명으로 사용)
    const videoName = currentVideoInfo.name || 'video';
    const baseName = videoName.replace(/\.[^/.]+$/, ''); // 확장자 제거

    if (downloadMethod === 'zip') {
        // ZIP 파일로 다운로드
        try {
            // JSZip이 로드되었는지 확인
            if (typeof JSZip === 'undefined') {
                alert('⚠️ ZIP 압축 기능을 사용할 수 없습니다. 개별 파일로 다운로드를 시도합니다.');
                downloadMethod = 'individual';
            } else {
                const zip = new JSZip();
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);

                // 모든 프레임을 ZIP에 추가
                for (let i = 0; i < frameItems.length; i++) {
                    const frameItem = frameItems[i];
                    const frameData = frameItem.dataset.frame;
                    const label = frameItem.dataset.label || `frame_${i + 1}`;

                    // Base64 데이터를 Blob으로 변환
                    const byteString = atob(frameData);
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    for (let j = 0; j < byteString.length; j++) {
                        ia[j] = byteString.charCodeAt(j);
                    }

                    // 파일명: 프레임번호_레이블.jpg
                    const fileName = `${String(i + 1).padStart(3, '0')}_${label.replace(/[^a-zA-Z0-9가-힣_-]/g, '_')}.jpg`;
                    zip.file(fileName, ab);
                }

                // ZIP 파일 생성
                const zipBlob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                // ZIP 파일 다운로드
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}_frames_${timestamp}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert(`✅ ${frameItems.length}개의 프레임이 ZIP 파일로 저장되었습니다.\n\n파일명: ${baseName}_frames_${timestamp}.zip`);
                return;
            }
        } catch (error) {
            console.error('ZIP 생성 실패:', error);
            alert(`⚠️ ZIP 파일 생성에 실패했습니다: ${error.message}\n\n개별 파일로 다운로드를 시도합니다.`);
            downloadMethod = 'individual';
        }
    }

    if (downloadMethod === 'individual') {
        // 개별 파일로 다운로드 (기존 방식)
        let downloadedCount = 0;

        // 브라우저 다운로드 권한 안내
        if (frameItems.length > 3) {
            alert('⚠️ 여러 파일을 다운로드합니다.\n\n브라우저에서 "여러 파일 다운로드 허용" 메시지가 표시되면 [허용]을 선택해주세요.');
        }

        for (let i = 0; i < frameItems.length; i++) {
            const frameItem = frameItems[i];
            const frameData = frameItem.dataset.frame;
            const label = frameItem.dataset.label || `frame_${i + 1}`;

            try {
                // Base64 데이터를 Blob으로 변환
                const byteString = atob(frameData);
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let j = 0; j < byteString.length; j++) {
                    ia[j] = byteString.charCodeAt(j);
                }
                const blob = new Blob([ab], { type: 'image/jpeg' });

                // 다운로드 링크 생성
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                // 파일명: 영상이름_프레임번호_레이블.jpg
                const fileName = `${baseName}_${String(i + 1).padStart(3, '0')}_${label.replace(/[^a-zA-Z0-9가-힣_-]/g, '_')}.jpg`;
                a.href = url;
                a.download = fileName;

                // 다운로드 실행
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // URL 해제
                URL.revokeObjectURL(url);

                downloadedCount++;

                // 브라우저가 다운로드를 처리할 시간 주기 (200ms 간격으로 증가)
                await new Promise(resolve => setTimeout(resolve, 200));
            } catch (error) {
                console.error(`프레임 ${i + 1} 다운로드 실패:`, error);
            }
        }

        alert(`${downloadedCount}개의 프레임이 저장되었습니다.`);
    }
}

// 추출된 프레임 전체 삭제
function clearAllFrames() {
    const framesGrid = document.getElementById('frames-grid');
    const gallery = document.getElementById('extracted-frames-gallery');

    // 프레임이 없으면 리턴
    if (framesGrid.children.length === 0) {
        alert('삭제할 프레임이 없습니다.');
        return;
    }

    // 삭제 확인
    if (confirm(`${framesGrid.children.length}개의 모든 프레임을 삭제하시겠습니까?`)) {
        // 모든 프레임 삭제
        framesGrid.innerHTML = '';

        // 갤러리 숨기기
        gallery.style.display = 'none';

        // 프레임 저장 (빈 상태로)
        saveExtractedFrames();

        alert('모든 프레임이 삭제되었습니다.');
    }
}

// 추출된 프레임들을 localStorage에 저장
function saveExtractedFrames() {
    const frameItems = document.querySelectorAll('.frame-item');
    const frames = [];

    frameItems.forEach(item => {
        frames.push({
            frameData: item.dataset.frame,
            label: item.dataset.label
        });
    });

    try {
        localStorage.setItem(FRAMES_STORAGE_KEY, JSON.stringify(frames));
    } catch (e) {
        console.error('프레임 저장 실패 (용량 초과일 수 있음):', e);

        // 사용자에게 경고 메시지 표시
        if (e.name === 'QuotaExceededError' || e.code === 22) {
            // localStorage 용량 초과 시
            const sizeInMB = (JSON.stringify(frames).length / (1024 * 1024)).toFixed(2);
            alert(`⚠️ 저장 실패: 브라우저 저장 공간이 부족합니다.\n\n` +
                  `- 추출된 프레임 수: ${frames.length}개\n` +
                  `- 필요한 용량: 약 ${sizeInMB}MB\n` +
                  `- 브라우저 제한: 약 5-10MB\n\n` +
                  `💡 해결 방법:\n` +
                  `1. "💾 일괄 저장" 버튼으로 즉시 파일로 다운로드하세요\n` +
                  `2. 일부 프레임을 삭제한 후 다시 시도하세요\n` +
                  `3. 한 번에 추출하는 프레임 수를 줄이세요`);
            return false;
        }
    }
    return true;
}

// 현재 비디오 정보 저장
function saveCurrentVideoInfo() {
    try {
        localStorage.setItem(VIDEO_INFO_STORAGE_KEY, JSON.stringify(currentVideoInfo));
    } catch (e) {
        console.error('비디오 정보 저장 실패:', e);
    }
}

// localStorage에서 프레임들 복원
function restoreExtractedFrames() {
    try {
        const savedFrames = localStorage.getItem(FRAMES_STORAGE_KEY);
        if (!savedFrames) return;

        const frames = JSON.parse(savedFrames);
        if (!frames || frames.length === 0) return;

        // 프레임 갤러리 초기화
        const framesGrid = document.getElementById('frames-grid');
        framesGrid.innerHTML = '';

        // 저장된 프레임들 복원
        frames.forEach(frame => {
            displayExtractedFrameWithoutSave(frame.frameData, frame.label);
        });

        console.log(`${frames.length}개의 프레임을 복원했습니다.`);
    } catch (e) {
        console.error('프레임 복원 실패:', e);
    }
}

// 저장하지 않고 프레임만 표시 (복원 시 사용)
function displayExtractedFrameWithoutSave(frameData, label) {
    const framesGrid = document.getElementById('frames-grid');
    const gallery = document.getElementById('extracted-frames-gallery');

    const frameItem = document.createElement('div');
    frameItem.className = 'frame-item';
    frameItem.draggable = true;
    frameItem.style.cssText = 'border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden; background: rgba(0,0,0,0.3); cursor: move; transition: all 0.2s;';
    frameItem.dataset.frame = frameData;
    frameItem.dataset.label = label;

    frameItem.innerHTML = `
        <div style="background: rgba(102, 126, 234, 0.2); padding: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: #667eea;">
            <input type="checkbox" class="frame-select-checkbox" checked style="margin-left: 5px; width: 16px; height: 16px; cursor: pointer;" onchange="updateFrameAnalysisCost()">
            <span style="cursor: move; flex: 1; text-align: center;">⋮⋮ 드래그하여 순서 변경</span>
        </div>
        <img src="data:image/jpeg;base64,${frameData}" style="width: 100%; height: auto; display: block;" alt="${label}">
        <div style="padding: 8px; text-align: center;">
            <div style="color: #e0e6ed; font-size: 0.9rem; margin-bottom: 8px;">${label}</div>
            <div style="display: flex; gap: 5px; justify-content: center;">
                <button onclick="downloadFrame(this)" class="btn-secondary" style="padding: 4px 8px; font-size: 0.85rem; background: #667eea;" data-frame="${frameData}">📥 다운로드</button>
                <button onclick="deleteFrame(this)" class="btn-secondary" style="padding: 4px 8px; font-size: 0.85rem; background: #ef4444;">🗑️ 삭제</button>
            </div>
        </div>
    `;

    // 드래그 이벤트 핸들러 추가
    frameItem.addEventListener('dragstart', handleDragStart);
    frameItem.addEventListener('dragover', handleDragOver);
    frameItem.addEventListener('drop', handleDrop);
    frameItem.addEventListener('dragenter', handleDragEnter);
    frameItem.addEventListener('dragleave', handleDragLeave);
    frameItem.addEventListener('dragend', handleDragEnd);

    framesGrid.appendChild(frameItem);
    gallery.style.display = 'block';
}

// 비디오 정보 복원
function restoreCurrentVideoInfo() {
    try {
        const savedVideoInfo = localStorage.getItem(VIDEO_INFO_STORAGE_KEY);
        if (!savedVideoInfo) return;

        const videoInfo = JSON.parse(savedVideoInfo);
        if (!videoInfo || !videoInfo.path) return;

        // 비디오 정보 복원
        currentVideoInfo = videoInfo;

        // 서버 파일인 경우 미리보기 표시
        if (!videoInfo.isLocal && videoInfo.path) {
            const videoPlayer = document.getElementById('video-preview-player');
            const videoSource = document.getElementById('video-preview-source');

            const encodedPath = encodeURIComponent(videoInfo.path);
            videoSource.src = `/api/video-analyzer/stream?path=${encodedPath}`;
            videoPlayer.load();

            document.getElementById('preview-filename').textContent = videoInfo.name;
            document.getElementById('preview-filepath').textContent = videoInfo.path;

            document.getElementById('video-preview-section').style.display = 'block';

            console.log('비디오 정보를 복원했습니다:', videoInfo.name);
        }
    } catch (e) {
        console.error('비디오 정보 복원 실패:', e);
    }
}

// 자막 삭제 함수
function deleteSubtitleItem(button) {
    const subtitleItem = button.closest('.subtitle-item');

    if (!subtitleItem) {
        return;
    }

    // 삭제 애니메이션
    subtitleItem.classList.add('removing');

    // 애니메이션 완료 후 요소 제거
    setTimeout(() => {
        subtitleItem.remove();
        updateSubtitleCount();
    }, 300);
}

// 전체 자막 삭제
function clearAllSubtitles() {
    if (!confirm('모든 자막을 삭제하시겠습니까?')) {
        return;
    }

    const subtitleList = document.getElementById('subtitle-list');
    if (subtitleList) {
        subtitleList.innerHTML = '';
        updateSubtitleCount();
    }
}

// 자막 개수 업데이트
function updateSubtitleCount() {
    const subtitleItems = document.querySelectorAll('.subtitle-item');
    const countElement = document.querySelector('.subtitle-info p:last-child strong');

    if (countElement) {
        const parent = countElement.parentElement;
        parent.innerHTML = `<strong>자막 라인 수:</strong> ${subtitleItems.length}개`;
    }
}

// 수정된 자막 다운로드 (SRT 형식)
function downloadEditedSubtitles() {
    const subtitleItems = document.querySelectorAll('.subtitle-item');

    if (subtitleItems.length === 0) {
        alert('다운로드할 자막이 없습니다.');
        return;
    }

    // SRT 형식으로 변환
    let srtContent = '';
    subtitleItems.forEach((item, index) => {
        const start = item.dataset.start;
        const end = item.dataset.end;
        const text = item.dataset.text;

        srtContent += `${index + 1}\n`;
        srtContent += `${start} --> ${end}\n`;
        srtContent += `${text}\n\n`;
    });

    // 파일 다운로드
    const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `edited_subtitles_${Date.now()}.srt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);

    alert('수정된 자막이 다운로드되었습니다!');
}

// 드래그 앤 드롭 관련 변수
let draggedElement = null;

function handleDragStart(e) {
    draggedElement = this;
    this.style.opacity = '0.5';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    if (this !== draggedElement) {
        this.style.borderColor = '#667eea';
        this.style.borderWidth = '2px';
        this.style.transform = 'scale(1.05)';
    }
}

function handleDragLeave(e) {
    this.style.borderColor = 'rgba(255,255,255,0.2)';
    this.style.borderWidth = '1px';
    this.style.transform = 'scale(1)';
}

function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }

    // 자기 자신에게 드롭하는 경우 무시
    if (draggedElement !== this) {
        // 드래그된 요소와 드롭 대상의 위치를 교환
        const allItems = Array.from(document.querySelectorAll('.frame-item'));
        const draggedIndex = allItems.indexOf(draggedElement);
        const targetIndex = allItems.indexOf(this);

        const framesGrid = document.getElementById('frames-grid');

        if (draggedIndex < targetIndex) {
            // 뒤로 이동: 타겟 다음에 삽입
            framesGrid.insertBefore(draggedElement, this.nextSibling);
        } else {
            // 앞으로 이동: 타겟 앞에 삽입
            framesGrid.insertBefore(draggedElement, this);
        }

        // 순서가 변경되었으므로 저장
        saveExtractedFrames();
    }

    // 스타일 복원
    this.style.borderColor = 'rgba(255,255,255,0.2)';
    this.style.borderWidth = '1px';
    this.style.transform = 'scale(1)';

    return false;
}

function handleDragEnd(e) {
    this.style.opacity = '1';

    // 모든 프레임 아이템의 스타일 복원
    document.querySelectorAll('.frame-item').forEach(item => {
        item.style.borderColor = 'rgba(255,255,255,0.2)';
        item.style.borderWidth = '1px';
        item.style.transform = 'scale(1)';
    });
}

// ============================================
// AI 프레임 분석 관련 함수들
// ============================================

// 프레임 전체 선택
function selectAllFrames() {
    const checkboxes = document.querySelectorAll('.frame-select-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = true;
    });
    updateFrameAnalysisCost();
}

// 프레임 전체 선택 해제
function deselectAllFrames() {
    const checkboxes = document.querySelectorAll('.frame-select-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = false;
    });
    updateFrameAnalysisCost();
}

// AI 프레임 분석 비용 계산 및 업데이트
function updateFrameAnalysisCost() {
    const selectedFrames = document.querySelectorAll('.frame-select-checkbox:checked').length;
    const selectedModel = document.getElementById('frame-ai-model-select').value;
    const costDisplay = document.getElementById('frame-analysis-cost');

    // 모델별 비용 (1000 토큰당 USD 기준)
    const modelCosts = {
        'gpt-4o-mini': { input: 0.00015, output: 0.0006, imageTokens: 2833 },  // GPT-4o Mini: 이미지당 약 2833 토큰
        'sonnet': { input: 0.003, output: 0.015, imageTokens: 1600 },  // Claude Sonnet: 이미지당 약 1600 토큰
        'haiku': { input: 0.0008, output: 0.004, imageTokens: 1600 },  // Claude Haiku: 이미지당 약 1600 토큰
        'gpt-4o': { input: 0.0025, output: 0.01, imageTokens: 2833 }   // GPT-4o: 이미지당 약 2833 토큰
    };

    const cost = modelCosts[selectedModel];
    if (!cost) {
        costDisplay.textContent = '예상 비용: 계산 불가';
        return;
    }

    // 입력 비용: 프레임 이미지 토큰 + 프롬프트 토큰 (약 500 토큰)
    const inputTokens = (selectedFrames * cost.imageTokens) + 500;
    const outputTokens = 2000; // 예상 출력 토큰

    const inputCost = (inputTokens / 1000) * cost.input;
    const outputCost = (outputTokens / 1000) * cost.output;
    const totalCost = inputCost + outputCost;

    // USD를 원화로 변환 (약 1300원)
    const totalCostKRW = totalCost * 1300;

    if (selectedFrames === 0) {
        costDisplay.textContent = '예상 비용: 선택된 프레임이 없습니다';
        costDisplay.style.color = '#ef4444';
    } else {
        costDisplay.textContent = `예상 비용: ${selectedFrames}개 프레임 - 약 $${totalCost.toFixed(4)} (₩${totalCostKRW.toFixed(0)})`;
        costDisplay.style.color = '#fbbf24';
    }
}

// 프레임 분석 템플릿 로드
function loadFrameAnalysisTemplate() {
    const templateSelect = document.getElementById('frame-analysis-template');
    const selectedTemplate = templateSelect.value;

    if (!selectedTemplate) {
        return; // '새 분석' 선택 시 아무것도 하지 않음
    }

    // localStorage에서 템플릿 불러오기
    const templates = JSON.parse(localStorage.getItem('frameAnalysisTemplates') || '{}');
    const template = templates[selectedTemplate];

    if (template) {
        // 템플릿 설정 적용
        document.getElementById('frame-ai-model-select').value = template.model;
        document.getElementById('frame-analysis-type').value = template.analysisType;

        if (template.analysisType === 'custom' && template.customPrompt) {
            document.getElementById('custom-prompt-input').value = template.customPrompt;
            document.getElementById('custom-prompt-container').style.display = 'block';
        }

        updateFrameAnalysisCost();
    }
}

// 프레임 분석 템플릿 저장
function saveFrameAnalysisTemplate() {
    const templateName = prompt('템플릿 이름을 입력하세요:');
    if (!templateName) {
        return;
    }

    // 현재 설정 수집
    const template = {
        model: document.getElementById('frame-ai-model-select').value,
        analysisType: document.getElementById('frame-analysis-type').value,
        customPrompt: document.getElementById('custom-prompt-input').value
    };

    // localStorage에 저장
    const templates = JSON.parse(localStorage.getItem('frameAnalysisTemplates') || '{}');
    templates[templateName] = template;
    localStorage.setItem('frameAnalysisTemplates', JSON.stringify(templates));

    // 템플릿 드롭다운에 추가
    const templateSelect = document.getElementById('frame-analysis-template');
    const option = document.createElement('option');
    option.value = templateName;
    option.textContent = templateName;
    templateSelect.appendChild(option);
    templateSelect.value = templateName;

    alert(`템플릿 '${templateName}'이(가) 저장되었습니다.`);
}

// 페이지 로드 시 저장된 템플릿 불러오기
function loadSavedTemplates() {
    const templates = JSON.parse(localStorage.getItem('frameAnalysisTemplates') || '{}');
    const templateSelect = document.getElementById('frame-analysis-template');

    // 기존 옵션 제거 (첫 번째 '새 분석' 옵션 제외)
    while (templateSelect.options.length > 1) {
        templateSelect.remove(1);
    }

    // 저장된 템플릿 추가
    Object.keys(templates).forEach(templateName => {
        const option = document.createElement('option');
        option.value = templateName;
        option.textContent = templateName;
        templateSelect.appendChild(option);
    });
}

// 프레임 분석 설정 저장
function saveFrameAnalysisSettings() {
    const settings = {
        model: document.getElementById('frame-ai-model-select').value,
        analysisType: document.getElementById('frame-analysis-type').value,
        subtitleLanguagePrimary: document.getElementById('subtitle-language-primary').value,
        subtitleLanguageSecondary: document.getElementById('subtitle-language-secondary').value
    };
    localStorage.setItem('frameAnalysisSettings', JSON.stringify(settings));
}

// 프레임 분석 설정 불러오기
function loadFrameAnalysisSettings() {
    const savedSettings = localStorage.getItem('frameAnalysisSettings');
    if (!savedSettings) return;

    try {
        const settings = JSON.parse(savedSettings);

        const modelSelect = document.getElementById('frame-ai-model-select');
        const typeSelect = document.getElementById('frame-analysis-type');
        const languagePrimarySelect = document.getElementById('subtitle-language-primary');
        const languageSecondarySelect = document.getElementById('subtitle-language-secondary');

        if (settings.model && modelSelect) {
            modelSelect.value = settings.model;
        }

        if (settings.analysisType && typeSelect) {
            typeSelect.value = settings.analysisType;

            // 커스텀 프롬프트인 경우 입력창 표시
            if (settings.analysisType === 'custom') {
                document.getElementById('custom-prompt-container').style.display = 'block';
            }
        }

        if (settings.subtitleLanguagePrimary && languagePrimarySelect) {
            languagePrimarySelect.value = settings.subtitleLanguagePrimary;
        }

        if (settings.subtitleLanguageSecondary !== undefined && languageSecondarySelect) {
            languageSecondarySelect.value = settings.subtitleLanguageSecondary;
        }

        // 비용 업데이트
        updateFrameAnalysisCost();
    } catch (e) {
        console.error('설정 불러오기 실패:', e);
    }
}

// 자막 추출 (SRT 형식)
function exportSubtitles() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "화면 텍스트" 또는 "자막" 섹션 추출
    const subtitleRegex = /###\s*2\.\s*화면\s*텍스트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = content.matchAll(subtitleRegex);

    let srtContent = '';
    let index = 1;
    let startTime = 0;

    for (const match of matches) {
        const text = match[1].trim()
            .replace(/^-\s*/gm, '')  // 리스트 마커 제거
            .split('\n')
            .filter(line => line.trim() && !line.includes('강조'))
            .join(' ')
            .trim();

        if (text) {
            const endTime = startTime + 3; // 3초 간격
            srtContent += `${index}\n`;
            srtContent += `00:00:${String(startTime).padStart(2, '0')},000 --> 00:00:${String(endTime).padStart(2, '0')},000\n`;
            srtContent += `${text}\n\n`;
            index++;
            startTime = endTime;
        }
    }

    if (!srtContent) {
        alert('자막 내용을 찾을 수 없습니다.');
        return;
    }

    downloadFile(srtContent, 'subtitles.srt', 'text/plain;charset=utf-8');
    alert('💬 자막 파일이 다운로드되었습니다. (SRT 형식)\n\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
}

// 한글자막2-0 다운로드 (AI 분석 결과의 "2-0. 한글 자막" 섹션)
function exportKoreanSubtitles() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "2-0. 한글 자막" 섹션 추출 (다양한 형식 지원)
    // ### 2-0. 한글 자막, ### 2-0.한글자막, ### 2-0 한글자막 등 모두 지원
    const subtitleRegex = /###\s*2[-.]?\s*0\s*[.:)~-]?\s*한글\s*자막[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = Array.from(content.matchAll(subtitleRegex));

    if (matches.length === 0) {
        alert('한글자막 내용을 찾을 수 없습니다.\n\n분석 결과에 "### 2-0. 한글 자막" 섹션이 있는지 확인해주세요.');
        return;
    }

    let srtContent = '';
    let index = 1;

    // 로드된 자막 정보가 있는지 확인
    const hasLoadedSubtitles = loadedSubtitles.main && loadedSubtitles.main.length > 0;

    if (hasLoadedSubtitles && loadedSubtitles.main.length === matches.length) {
        // 자막 불러오기에서 로드된 시간 정보 사용
        console.log(`✅ 로드된 자막 ${loadedSubtitles.main.length}개의 시간 정보를 사용합니다.`);

        matches.forEach((match, idx) => {
            const text = match[1].trim()
                .replace(/^-\s*/gm, '')  // 리스트 마커 제거
                .replace(/^[""\"]|[""\"]$/g, '')  // 따옴표 제거
                .split('\n')
                .filter(line => line.trim() && !line.includes('강조') && !line.includes('배치'))
                .join(' ')
                .trim();

            if (text && idx < loadedSubtitles.main.length) {
                const subtitle = loadedSubtitles.main[idx];
                srtContent += `${index}\n`;
                srtContent += `${subtitle.start} --> ${subtitle.end}\n`;
                srtContent += `${text}\n\n`;
                index++;
            }
        });
    } else {
        // 자막 정보가 없으면 기본 시간 간격 사용 (3초)
        console.log('⚠️ 로드된 자막 정보가 없어 기본 시간 간격(3초)을 사용합니다.');

        let startTime = 0;
        matches.forEach((match) => {
            const text = match[1].trim()
                .replace(/^-\s*/gm, '')  // 리스트 마커 제거
                .replace(/^[""\"]|[""\"]$/g, '')  // 따옴표 제거
                .split('\n')
                .filter(line => line.trim() && !line.includes('강조') && !line.includes('배치'))
                .join(' ')
                .trim();

            if (text) {
                const endTime = startTime + 3; // 3초 간격
                srtContent += `${index}\n`;
                srtContent += `00:00:${String(startTime).padStart(2, '0')},000 --> 00:00:${String(endTime).padStart(2, '0')},000\n`;
                srtContent += `${text}\n\n`;
                index++;
                startTime = endTime;
            }
        });
    }

    if (!srtContent) {
        alert('한글자막 내용을 찾을 수 없습니다.');
        return;
    }

    downloadFile(srtContent, 'korean_subtitles_2-0.srt', 'text/plain;charset=utf-8');

    if (hasLoadedSubtitles) {
        alert('📥 한글자막2-0 파일이 다운로드되었습니다.\n\n✅ 로드된 자막의 시간 정보를 사용했습니다.\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
    } else {
        alert('📥 한글자막2-0 파일이 다운로드되었습니다.\n\n⚠️ 기본 시간 간격(3초)을 사용했습니다.\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
    }
}

// 주자막2-1 다운로드 (AI 분석 결과의 "2-1. 주 자막" 섹션)
function exportMainSubtitles() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "2-1. 주 자막" 섹션 추출 (다양한 형식 지원)
    // ### 2-1. 주 자막, ### 2-1.주자막, ### 2-1 주자막 등 모두 지원
    const subtitleRegex = /###\s*2[-.]?\s*1\s*[.:)~-]?\s*주\s*자막[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = Array.from(content.matchAll(subtitleRegex));

    if (matches.length === 0) {
        alert('주자막 내용을 찾을 수 없습니다.');
        return;
    }

    let srtContent = '';
    let index = 1;

    // 로드된 자막 정보가 있는지 확인
    const hasLoadedSubtitles = loadedSubtitles.main && loadedSubtitles.main.length > 0;

    if (hasLoadedSubtitles && loadedSubtitles.main.length === matches.length) {
        // 자막 불러오기에서 로드된 시간 정보 사용
        console.log(`✅ 로드된 자막 ${loadedSubtitles.main.length}개의 시간 정보를 사용합니다.`);

        matches.forEach((match, idx) => {
            const text = match[1].trim()
                .replace(/^-\s*/gm, '')  // 리스트 마커 제거
                .split('\n')
                .filter(line => line.trim() && !line.includes('강조'))
                .join(' ')
                .trim();

            if (text && idx < loadedSubtitles.main.length) {
                const subtitle = loadedSubtitles.main[idx];
                srtContent += `${index}\n`;
                srtContent += `${subtitle.start} --> ${subtitle.end}\n`;
                srtContent += `${text}\n\n`;
                index++;
            }
        });
    } else {
        // 자막 정보가 없으면 기본 시간 간격 사용 (3초)
        console.log('⚠️ 로드된 자막 정보가 없어 기본 시간 간격(3초)을 사용합니다.');

        let startTime = 0;
        matches.forEach((match) => {
            const text = match[1].trim()
                .replace(/^-\s*/gm, '')  // 리스트 마커 제거
                .split('\n')
                .filter(line => line.trim() && !line.includes('강조'))
                .join(' ')
                .trim();

            if (text) {
                const endTime = startTime + 3; // 3초 간격
                srtContent += `${index}\n`;
                srtContent += `00:00:${String(startTime).padStart(2, '0')},000 --> 00:00:${String(endTime).padStart(2, '0')},000\n`;
                srtContent += `${text}\n\n`;
                index++;
                startTime = endTime;
            }
        });
    }

    if (!srtContent) {
        alert('주자막 내용을 찾을 수 없습니다.');
        return;
    }

    downloadFile(srtContent, 'main_subtitles_2-1.srt', 'text/plain;charset=utf-8');

    if (hasLoadedSubtitles) {
        alert('📥 주자막2-1 파일이 다운로드되었습니다.\n\n✅ 로드된 자막의 시간 정보를 사용했습니다.\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
    } else {
        alert('📥 주자막2-1 파일이 다운로드되었습니다.\n\n⚠️ 기본 시간 간격(3초)을 사용했습니다.\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
    }
}

// 보조 자막2-2 다운로드 (AI 분석 결과의 "2-2. 보조 자막" 섹션)
function exportSecondarySubtitles() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "2-2. 보조 자막" 섹션 추출 (다양한 형식 지원)
    // ### 2-2. 보조 자막, ### 2-2.보조자막, ### 2-2 보조자막 등 모두 지원
    const descriptionRegex = /###\s*2[-.]?\s*2\s*[.:)~-]?\s*보조\s*자막[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = Array.from(content.matchAll(descriptionRegex));

    if (matches.length === 0) {
        alert('보조 자막 내용을 찾을 수 없습니다.');
        return;
    }

    let srtContent = '';
    let index = 1;

    // 로드된 자막 정보가 있는지 확인
    const hasLoadedSubtitles = loadedSubtitles.main && loadedSubtitles.main.length > 0;

    if (hasLoadedSubtitles && loadedSubtitles.main.length === matches.length) {
        // 자막 불러오기에서 로드된 시간 정보 사용
        console.log(`✅ 로드된 자막 ${loadedSubtitles.main.length}개의 시간 정보를 사용합니다.`);

        matches.forEach((match, idx) => {
            const text = match[1].trim()
                .replace(/^-\s*/gm, '')  // 리스트 마커 제거
                .split('\n')
                .filter(line => line.trim())
                .join(' ')
                .trim();

            if (text && idx < loadedSubtitles.main.length) {
                const subtitle = loadedSubtitles.main[idx];
                srtContent += `${index}\n`;
                srtContent += `${subtitle.start} --> ${subtitle.end}\n`;
                srtContent += `${text}\n\n`;
                index++;
            }
        });
    } else {
        // 자막 정보가 없으면 기본 시간 간격 사용 (4초)
        console.log('⚠️ 로드된 자막 정보가 없어 기본 시간 간격(4초)을 사용합니다.');

        let startTime = 0;
        matches.forEach((match) => {
            const text = match[1].trim()
                .replace(/^-\s*/gm, '')  // 리스트 마커 제거
                .split('\n')
                .filter(line => line.trim())
                .join(' ')
                .trim();

            if (text) {
                const endTime = startTime + 4; // 4초 간격 (설명이 더 길 수 있으므로)
                srtContent += `${index}\n`;
                srtContent += `00:00:${String(startTime).padStart(2, '0')},000 --> 00:00:${String(endTime).padStart(2, '0')},000\n`;
                srtContent += `${text}\n\n`;
                index++;
                startTime = endTime;
            }
        });
    }

    if (!srtContent) {
        alert('보조 자막 내용을 찾을 수 없습니다.');
        return;
    }

    downloadFile(srtContent, 'secondary_subtitles_2-2.srt', 'text/plain;charset=utf-8');

    if (hasLoadedSubtitles) {
        alert('📥 보조 자막2-2 파일이 다운로드되었습니다.\n\n✅ 로드된 자막의 시간 정보를 사용했습니다.\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
    } else {
        alert('📥 보조 자막2-2 파일이 다운로드되었습니다.\n\n⚠️ 기본 시간 간격(4초)을 사용했습니다.\n프리미어 프로, 다빈치 리졸브 등에서 사용 가능합니다.');
    }
}

// 나레이션 추출 (TXT 형식)
function exportNarration() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "나레이션 스크립트" 섹션 추출
    const narrationRegex = /###\s*3\.\s*나레이션\s*스크립트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = content.matchAll(narrationRegex);

    let narrationContent = '';
    let frameNum = 1;

    for (const match of matches) {
        const text = match[1].trim()
            .replace(/^-\s*/gm, '')
            .split('\n')
            .filter(line => line.trim() && !line.includes('예상') && !line.includes('읽기'))
            .join(' ')
            .trim();

        if (text) {
            narrationContent += `[프레임 ${frameNum}]\n${text}\n\n`;
            frameNum++;
        }
    }

    if (!narrationContent) {
        alert('나레이션 내용을 찾을 수 없습니다.');
        return;
    }

    downloadFile(narrationContent, 'narration.txt', 'text/plain;charset=utf-8');
    alert('🎙️ 나레이션 스크립트가 다운로드되었습니다.\n\nTypecast, VREW 등 TTS 서비스에서 사용 가능합니다.');
}

// 이미지 프롬프트 추출 (TXT 형식)
function exportImagePrompts() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "AI 이미지 생성 프롬프트" 섹션 추출
    const promptRegex = /###\s*4\.\s*AI\s*이미지\s*생성\s*프롬프트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = content.matchAll(promptRegex);

    let promptsContent = '';
    let frameNum = 1;

    for (const match of matches) {
        const text = match[1].trim()
            .replace(/^-\s*/gm, '')
            .split('\n')
            .filter(line => line.trim() && !line.includes('DALL-E') && !line.includes('예시'))
            .join(' ')
            .trim();

        if (text) {
            promptsContent += `Frame ${frameNum}:\n${text}\n\n`;
            frameNum++;
        }
    }

    if (!promptsContent) {
        alert('이미지 프롬프트를 찾을 수 없습니다.');
        return;
    }

    downloadFile(promptsContent, 'image_prompts.txt', 'text/plain;charset=utf-8');
    alert('🎨 이미지 생성 프롬프트가 다운로드되었습니다.\n\nDALL-E, Midjourney 등에서 사용 가능합니다.');
}

// 이미지 프롬프트 복사
function copyImagePrompts() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "AI 이미지 생성 프롬프트" 섹션 추출
    const promptRegex = /###\s*4\.\s*AI\s*이미지\s*생성\s*프롬프트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = content.matchAll(promptRegex);

    let promptsContent = '';
    let frameNum = 1;

    for (const match of matches) {
        const text = match[1].trim()
            .replace(/^-\s*/gm, '')
            .split('\n')
            .filter(line => line.trim() && !line.includes('DALL-E') && !line.includes('예시') && !line.includes('IMPORTANT'))
            .join(' ')
            .trim();

        if (text) {
            promptsContent += `Frame ${frameNum}:\n${text}\n\n`;
            frameNum++;
        }
    }

    if (!promptsContent) {
        alert('이미지 프롬프트를 찾을 수 없습니다.');
        return;
    }

    // 클립보드에 복사
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(promptsContent)
            .then(() => {
                alert(`📋 이미지 프롬프트가 클립보드에 복사되었습니다!\n\n총 ${frameNum - 1}개 프레임의 프롬프트가 복사되었습니다.\nDALL-E, Midjourney 등에 바로 붙여넣기 하세요.`);
            })
            .catch(err => {
                console.error('클립보드 복사 실패:', err);
                // 폴백: textarea를 사용한 복사
                fallbackCopyToClipboard(promptsContent);
            });
    } else {
        // 구형 브라우저용 폴백
        fallbackCopyToClipboard(promptsContent);
    }
}

// 영상 프롬프트 추출 (TXT 형식)
function exportVideoPrompts() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "AI 영상 생성 프롬프트" 섹션 추출
    const promptRegex = /###\s*5\.\s*AI\s*영상\s*생성\s*프롬프트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = content.matchAll(promptRegex);

    let promptsContent = '';
    let frameNum = 1;

    for (const match of matches) {
        const text = match[1]
            .split('\n')
            .filter(line => line.trim() && !line.startsWith('---'))
            .map(line => line.replace(/^[-*]\s*/, '').trim())
            .join('\n')
            .trim();

        if (text) {
            promptsContent += `Scene ${frameNum}:\n${text}\n\n`;
            frameNum++;
        }
    }

    if (!promptsContent) {
        alert('영상 프롬프트를 찾을 수 없습니다.');
        return;
    }

    downloadFile(promptsContent, 'video_prompts.txt', 'text/plain;charset=utf-8');
    alert('🎥 영상 생성 프롬프트가 다운로드되었습니다.\n\nSora, Kling, Runway 등에서 사용 가능합니다.');
}

// 영상 프롬프트 복사
function copyVideoPrompts() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "AI 영상 생성 프롬프트" 섹션 추출
    const promptRegex = /###\s*5\.\s*AI\s*영상\s*생성\s*프롬프트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const matches = content.matchAll(promptRegex);

    let promptsContent = '';
    let frameNum = 1;

    for (const match of matches) {
        const text = match[1].trim()
            .replace(/^-\s*/gm, '')
            .split('\n')
            .filter(line => line.trim() && !line.includes('Sora') && !line.includes('예시') && !line.includes('IMPORTANT'))
            .join(' ')
            .trim();

        if (text) {
            promptsContent += `Scene ${frameNum}:\n${text}\n\n`;
            frameNum++;
        }
    }

    if (!promptsContent) {
        alert('영상 프롬프트를 찾을 수 없습니다.');
        return;
    }

    // 클립보드에 복사
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(promptsContent)
            .then(() => {
                alert(`📋 영상 프롬프트가 클립보드에 복사되었습니다!\n\n총 ${frameNum - 1}개 장면의 프롬프트가 복사되었습니다.\nSora, Kling, Runway 등에 바로 붙여넣기 하세요.`);
            })
            .catch(err => {
                console.error('클립보드 복사 실패:', err);
                fallbackCopyToClipboard(promptsContent);
            });
    } else {
        fallbackCopyToClipboard(promptsContent);
    }
}

// 폴백 클립보드 복사 함수
function fallbackCopyToClipboard(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();

    try {
        document.execCommand('copy');
        alert('📋 이미지 프롬프트가 클립보드에 복사되었습니다!');
    } catch (err) {
        console.error('복사 실패:', err);
        alert('❌ 클립보드 복사에 실패했습니다.\n수동으로 텍스트를 선택하여 복사해주세요.');
    } finally {
        document.body.removeChild(textarea);
    }
}

// 장면별 프롬프트 선택기 표시
function showScenePromptSelector() {
    const content = document.getElementById('frame-analysis-content').value;

    if (!content || content.trim() === '') {
        alert('분석 결과가 없습니다.');
        return;
    }

    // "AI 이미지 생성 프롬프트" 섹션 추출
    const imagePromptRegex = /###\s*4\.\s*AI\s*이미지\s*생성\s*프롬프트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const imageMatches = content.matchAll(imagePromptRegex);

    // "AI 영상 생성 프롬프트" 섹션 추출
    const videoPromptRegex = /###\s*5\.\s*AI\s*영상\s*생성\s*프롬프트[^\n]*\n([\s\S]*?)(?=###|$)/gi;
    const videoMatches = content.matchAll(videoPromptRegex);

    const imagePrompts = [];
    const videoPrompts = [];
    let frameNum = 1;

    // 이미지 프롬프트 추출
    for (const match of imageMatches) {
        const text = match[1]
            .split('\n')
            .filter(line => line.trim() && !line.startsWith('---'))
            .map(line => line.replace(/^[-*]\s*/, '').trim())
            .join('\n')
            .trim();

        if (text) {
            imagePrompts.push({
                frameNum: frameNum,
                text: text
            });
            frameNum++;
        }
    }

    // 영상 프롬프트 추출
    frameNum = 1;
    for (const match of videoMatches) {
        const text = match[1]
            .split('\n')
            .filter(line => line.trim() && !line.startsWith('---'))
            .map(line => line.replace(/^[-*]\s*/, '').trim())
            .join('\n')
            .trim();

        if (text) {
            videoPrompts.push({
                frameNum: frameNum,
                text: text
            });
            frameNum++;
        }
    }

    if (imagePrompts.length === 0 && videoPrompts.length === 0) {
        alert('프롬프트를 찾을 수 없습니다.');
        return;
    }

    const totalScenes = Math.max(imagePrompts.length, videoPrompts.length);

    // 다이얼로그 생성
    const backdrop = document.createElement('div');
    backdrop.id = 'scene-prompt-backdrop';
    backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
    `;

    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 16px;
        padding: 24px;
        max-width: 900px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
    `;

    // 헤더
    const header = document.createElement('div');
    header.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
    `;
    header.innerHTML = `
        <h3 style="margin: 0; color: #fff; font-size: 1.3rem; font-weight: 600;">
            🎬 장면별 프롬프트 (총 ${totalScenes}개)
        </h3>
        <button onclick="document.getElementById('scene-prompt-backdrop').remove()"
                style="background: rgba(255, 255, 255, 0.1); border: none; color: #fff;
                       padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;
                       transition: all 0.2s;">
            ✕ 닫기
        </button>
    `;

    // 프롬프트 카드들
    const promptsContainer = document.createElement('div');
    promptsContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 12px;
    `;

    for (let i = 0; i < totalScenes; i++) {
        const imagePrompt = imagePrompts[i];
        const videoPrompt = videoPrompts[i];
        const card = document.createElement('div');
        card.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s;
        `;
        card.onmouseenter = () => {
            card.style.background = 'rgba(255, 255, 255, 0.08)';
            card.style.borderColor = 'rgba(168, 85, 247, 0.5)';
            card.style.transform = 'translateY(-2px)';
        };
        card.onmouseleave = () => {
            card.style.background = 'rgba(255, 255, 255, 0.05)';
            card.style.borderColor = 'rgba(255, 255, 255, 0.1)';
            card.style.transform = 'translateY(0)';
        };

        const cardHeader = document.createElement('div');
        cardHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        `;

        const title = document.createElement('div');
        title.style.cssText = `
            color: #a855f7;
            font-weight: 600;
            font-size: 0.95rem;
        `;
        title.textContent = `장면 ${i + 1}`;

        cardHeader.appendChild(title);
        card.appendChild(cardHeader);

        // 이미지 프롬프트 섹션
        if (imagePrompt) {
            const imageSection = document.createElement('div');
            imageSection.style.cssText = `
                margin-bottom: 12px;
                padding: 12px;
                background: rgba(236, 72, 153, 0.1);
                border-radius: 8px;
                border: 1px solid rgba(236, 72, 153, 0.2);
            `;

            const imageHeader = document.createElement('div');
            imageHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            `;

            const imageLabel = document.createElement('div');
            imageLabel.style.cssText = `
                color: #ec4899;
                font-weight: 600;
                font-size: 0.85rem;
            `;
            imageLabel.textContent = '🎨 이미지 프롬프트';

            const imageCopyBtn = document.createElement('button');
            imageCopyBtn.style.cssText = `
                background: linear-gradient(135deg, #ec4899 0%, #d946ef 100%);
                border: none;
                color: white;
                padding: 4px 10px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.8rem;
                font-weight: 500;
                transition: all 0.2s;
            `;
            imageCopyBtn.innerHTML = '📋 복사';
            imageCopyBtn.onclick = () => copyScenePrompt(imagePrompt.text, imagePrompt.frameNum, imageCopyBtn, '이미지');

            imageHeader.appendChild(imageLabel);
            imageHeader.appendChild(imageCopyBtn);

            const imageText = document.createElement('div');
            imageText.style.cssText = `
                color: #e0e6ed;
                font-size: 0.85rem;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
            `;
            imageText.textContent = imagePrompt.text.length > 150
                ? imagePrompt.text.substring(0, 150) + '...'
                : imagePrompt.text;

            imageSection.appendChild(imageHeader);
            imageSection.appendChild(imageText);
            card.appendChild(imageSection);
        }

        // 영상 프롬프트 섹션
        if (videoPrompt) {
            const videoSection = document.createElement('div');
            videoSection.style.cssText = `
                padding: 12px;
                background: rgba(6, 182, 212, 0.1);
                border-radius: 8px;
                border: 1px solid rgba(6, 182, 212, 0.2);
            `;

            const videoHeader = document.createElement('div');
            videoHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            `;

            const videoLabel = document.createElement('div');
            videoLabel.style.cssText = `
                color: #06b6d4;
                font-weight: 600;
                font-size: 0.85rem;
            `;
            videoLabel.textContent = '🎥 영상 프롬프트';

            const videoCopyBtn = document.createElement('button');
            videoCopyBtn.style.cssText = `
                background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
                border: none;
                color: white;
                padding: 4px 10px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.8rem;
                font-weight: 500;
                transition: all 0.2s;
            `;
            videoCopyBtn.innerHTML = '📋 복사';
            videoCopyBtn.onclick = () => copyScenePrompt(videoPrompt.text, videoPrompt.frameNum, videoCopyBtn, '영상');

            videoHeader.appendChild(videoLabel);
            videoHeader.appendChild(videoCopyBtn);

            const videoText = document.createElement('div');
            videoText.style.cssText = `
                color: #e0e6ed;
                font-size: 0.85rem;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
            `;
            videoText.textContent = videoPrompt.text.length > 150
                ? videoPrompt.text.substring(0, 150) + '...'
                : videoPrompt.text;

            videoSection.appendChild(videoHeader);
            videoSection.appendChild(videoText);
            card.appendChild(videoSection);
        }

        promptsContainer.appendChild(card);
    }

    dialog.appendChild(header);
    dialog.appendChild(promptsContainer);
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    // ESC 키로 닫기
    const handleEscape = (e) => {
        if (e.key === 'Escape') {
            backdrop.remove();
            document.removeEventListener('keydown', handleEscape);
        }
    };
    document.addEventListener('keydown', handleEscape);

    // 배경 클릭으로 닫기
    backdrop.onclick = (e) => {
        if (e.target === backdrop) {
            backdrop.remove();
            document.removeEventListener('keydown', handleEscape);
        }
    };
}

// 개별 장면 프롬프트 복사
function copyScenePrompt(text, frameNum, buttonElement, promptType = '이미지') {
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
            .then(() => {
                const originalText = buttonElement.innerHTML;
                const originalBg = buttonElement.style.background;

                buttonElement.innerHTML = '✓ 복사됨!';
                buttonElement.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';

                setTimeout(() => {
                    buttonElement.innerHTML = originalText;
                    buttonElement.style.background = originalBg || (
                        promptType === '영상'
                            ? 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)'
                            : 'linear-gradient(135deg, #ec4899 0%, #d946ef 100%)'
                    );
                }, 2000);
            })
            .catch(err => {
                console.error('클립보드 복사 실패:', err);
                fallbackCopyToClipboard(text);
            });
    } else {
        fallbackCopyToClipboard(text);
    }
}

// 파일 다운로드 헬퍼 함수
function downloadFile(content, filename, mimeType) {
    const videoName = currentVideoInfo.name || 'video';
    const baseName = videoName.replace(/\.[^/.]+$/, '');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const finalFilename = `${baseName}_${filename.replace('.', '_' + timestamp + '.')}`;

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = finalFilename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// 프레임 분석 결과 전체 저장 (파일로)
function saveFrameAnalysisResult() {
    const resultContent = document.getElementById('frame-analysis-content').value;

    if (!resultContent || resultContent.trim() === '' || resultContent.includes('분석 중')) {
        alert('저장할 분석 결과가 없습니다.');
        return;
    }

    downloadFile(resultContent, 'AI분석결과.txt', 'text/plain;charset=utf-8');
    alert('📥 전체 분석 결과가 다운로드되었습니다.');
}

// 분석 결과를 로컬 스토리지에 저장
function saveAnalysisToStorage() {
    try {
        const resultContent = document.getElementById('frame-analysis-content').value;
        console.log('저장 시도:', resultContent.substring(0, 100) + '...');

        if (!resultContent || resultContent.trim() === '' || resultContent.includes('분석 중')) {
            alert('저장할 분석 결과가 없습니다.');
            return;
        }

        // 저장할 이름 입력
        const name = prompt('저장할 이름을 입력하세요:', currentVideoInfo.name || '쇼츠 분석');
        if (!name) {
            console.log('저장 취소됨');
            return;
        }

        // 저장할 데이터 구성
        const analysisData = {
            id: Date.now(),
            timestamp: new Date().toISOString(),
            name: name,
            videoName: currentVideoInfo.name || 'unknown',
            content: resultContent,
            frameCount: document.querySelectorAll('.frame-item').length
        };

        // 기존 저장 목록 가져오기
        const savedAnalyses = JSON.parse(localStorage.getItem('savedAnalyses') || '[]');
        console.log('기존 저장 개수:', savedAnalyses.length);

        // 새 분석 추가
        savedAnalyses.push(analysisData);
        console.log('새로 추가 후 개수:', savedAnalyses.length);

        // 저장 (최대 20개까지만 유지)
        if (savedAnalyses.length > 20) {
            savedAnalyses.shift(); // 가장 오래된 것 삭제
        }

        localStorage.setItem('savedAnalyses', JSON.stringify(savedAnalyses));
        console.log('localStorage에 저장 완료');

        // 저장 확인
        const verification = localStorage.getItem('savedAnalyses');
        console.log('저장 확인:', verification ? '성공' : '실패');

        alert(`📌 "${name}" 분석 결과가 보관함에 저장되었습니다.\n\n현재 총 ${savedAnalyses.length}개의 분석 결과가 보관함에 있습니다.\n\n💡 "📂 보관함 열기" 버튼으로 언제든지 불러올 수 있습니다.`);
    } catch (error) {
        console.error('저장 오류:', error);
        alert('❌ 저장 중 오류가 발생했습니다:\n' + error.message);
    }
}

// 저장된 분석 결과 불러오기 다이얼로그 표시
function showLoadAnalysisDialog() {
    let savedAnalyses;

    try {
        const savedData = localStorage.getItem('savedAnalyses');
        console.log('localStorage에서 읽은 데이터:', savedData);

        savedAnalyses = JSON.parse(savedData || '[]');
        console.log('파싱된 분석 결과 개수:', savedAnalyses.length);

        if (savedAnalyses.length === 0) {
            alert('📂 보관함이 비어 있습니다.\n\n💡 팁: "📌 보관함에 저장" 버튼을 클릭하여 AI 분석 결과를 브라우저에 임시 보관할 수 있습니다.\n\n⚠️ 브라우저 캐시를 삭제하면 보관함의 데이터도 함께 삭제됩니다.');
            return;
        }
    } catch (error) {
        console.error('불러오기 오류:', error);
        alert('❌ 불러오기 중 오류가 발생했습니다:\n' + error.message);
        return;
    }

    // 최신순으로 정렬
    savedAnalyses.sort((a, b) => b.id - a.id);

    // 다이얼로그 HTML 생성
    let dialogHtml = '<div style="max-height: 400px; overflow-y: auto;">';
    savedAnalyses.forEach((analysis, index) => {
        const date = new Date(analysis.timestamp).toLocaleString('ko-KR');
        dialogHtml += `
            <div style="padding: 10px; margin-bottom: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #10b981; margin-bottom: 4px;">${analysis.name}</div>
                        <div style="font-size: 0.85rem; color: #a0aec0;">
                            📅 ${date}<br>
                            🎬 ${analysis.videoName} (${analysis.frameCount}개 프레임)
                        </div>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="loadAnalysisFromStorage(${analysis.id}); document.getElementById('load-analysis-dialog').remove();" style="padding: 4px 10px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">불러오기</button>
                        <button onclick="deleteAnalysisFromStorage(${analysis.id}); showLoadAnalysisDialog(); document.getElementById('load-analysis-dialog').remove();" style="padding: 4px 10px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">삭제</button>
                    </div>
                </div>
            </div>
        `;
    });
    dialogHtml += '</div>';

    // 기존 다이얼로그 제거
    const existingDialog = document.getElementById('load-analysis-dialog');
    if (existingDialog) existingDialog.remove();

    // 다이얼로그 생성
    const dialog = document.createElement('div');
    dialog.id = 'load-analysis-dialog';
    dialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; max-width: 90%; background: #1a1a2e; padding: 20px; border-radius: 12px; border: 2px solid rgba(102, 126, 234, 0.5); box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5); z-index: 10000;';
    dialog.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; color: #667eea;">📂 저장된 분석 결과</h3>
            <button onclick="this.closest('#load-analysis-dialog').remove()" style="padding: 5px 10px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">✕ 닫기</button>
        </div>
        ${dialogHtml}
    `;

    // 백드롭 생성
    const backdrop = document.createElement('div');
    backdrop.id = 'dialog-backdrop';
    backdrop.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 9999;';
    backdrop.onclick = () => {
        dialog.remove();
        backdrop.remove();
    };

    document.body.appendChild(backdrop);
    document.body.appendChild(dialog);
}

// 저장된 분석 결과 불러오기
function loadAnalysisFromStorage(id) {
    const savedAnalyses = JSON.parse(localStorage.getItem('savedAnalyses') || '[]');
    const analysis = savedAnalyses.find(a => a.id === id);

    if (!analysis) {
        alert('분석 결과를 찾을 수 없습니다.');
        return;
    }

    // 결과 표시
    const resultDiv = document.getElementById('frame-analysis-result');
    const contentDiv = document.getElementById('frame-analysis-content');
    resultDiv.style.display = 'block';
    contentDiv.value = analysis.content;

    // 백드롭 제거
    const backdrop = document.getElementById('dialog-backdrop');
    if (backdrop) backdrop.remove();

    alert(`📂 "${analysis.name}" 분석 결과를 불러왔습니다.\n\n이제 편집하거나 다운로드할 수 있습니다.`);
}

// 저장된 분석 결과 삭제
function deleteAnalysisFromStorage(id) {
    if (!confirm('이 분석 결과를 삭제하시겠습니까?')) {
        return;
    }

    let savedAnalyses = JSON.parse(localStorage.getItem('savedAnalyses') || '[]');
    savedAnalyses = savedAnalyses.filter(a => a.id !== id);
    localStorage.setItem('savedAnalyses', JSON.stringify(savedAnalyses));

    alert('삭제되었습니다.');
}

// 파일에서 분석 결과 불러오기
function loadAnalysisFromFile(event) {
    const file = event.target.files[0];

    if (!file) {
        return;
    }

    // 파일 확장자 확인
    if (!file.name.endsWith('.txt')) {
        alert('❌ TXT 파일만 불러올 수 있습니다.');
        event.target.value = ''; // 파일 선택 초기화
        return;
    }

    const reader = new FileReader();

    reader.onload = function(e) {
        try {
            const content = e.target.result;

            if (!content || content.trim() === '') {
                alert('❌ 파일이 비어있습니다.');
                return;
            }

            // 결과 표시
            const resultDiv = document.getElementById('frame-analysis-result');
            const contentDiv = document.getElementById('frame-analysis-content');
            resultDiv.style.display = 'block';
            contentDiv.value = content;

            alert(`📄 파일을 불러왔습니다.\n\n파일명: ${file.name}\n크기: ${(file.size / 1024).toFixed(2)} KB\n\n이제 편집하거나 다운로드할 수 있습니다.`);
        } catch (error) {
            console.error('파일 읽기 오류:', error);
            alert('❌ 파일을 읽는 중 오류가 발생했습니다:\n' + error.message);
        } finally {
            // 파일 선택 초기화 (같은 파일 다시 선택 가능하도록)
            event.target.value = '';
        }
    };

    reader.onerror = function() {
        alert('❌ 파일을 읽을 수 없습니다.');
        event.target.value = '';
    };

    // 텍스트 파일로 읽기
    reader.readAsText(file, 'UTF-8');
}

// 새로운 쇼츠 콘텐츠 생성 (AI 기반)
async function generateNewShortsContent() {
    const frameItems = document.querySelectorAll('.frame-item');

    if (frameItems.length === 0) {
        alert('생성할 프레임이 없습니다. 먼저 영상에서 프레임을 추출하세요.');
        return;
    }

    // 선택된 프레임만 수집
    const frames = [];
    frameItems.forEach((item, index) => {
        const checkbox = item.querySelector('.frame-select-checkbox');
        if (checkbox && checkbox.checked) {
            const frameData = item.dataset.frame;
            const label = item.dataset.label || `frame_${index + 1}`;
            frames.push({
                index: index + 1,
                label: label,
                image_data: frameData
            });
        }
    });

    if (frames.length === 0) {
        alert('프레임을 선택하세요. 체크박스를 클릭하여 쇼츠에 사용할 프레임을 선택할 수 있습니다.');
        return;
    }

    // AI 모델과 자막 언어 선택
    const selectedModel = document.getElementById('frame-ai-model-select').value;
    const selectedLanguagePrimary = document.getElementById('subtitle-language-primary').value;
    const selectedLanguageSecondary = document.getElementById('subtitle-language-secondary').value;

    const modelNames = {
        'gpt-4o-mini': 'GPT-4o Mini',
        'sonnet': 'Claude Sonnet',
        'haiku': 'Claude Haiku',
        'gpt-4o': 'GPT-4o'
    };

    const languageNames = {
        'korean': '한국어',
        'english': 'English',
        'japanese': '日本語'
    };

    // 자막 언어 메시지 구성
    let subtitleLangMsg = languageNames[selectedLanguagePrimary];
    if (selectedLanguageSecondary) {
        subtitleLangMsg += ` + ${languageNames[selectedLanguageSecondary]}`;
    }

    // 확인
    if (!confirm(`${frames.length}개의 프레임으로 새로운 쇼츠 콘텐츠를 생성하시겠습니까?\n\n${modelNames[selectedModel]} 모델을 사용하여 완전히 새로운 시나리오, 자막(${subtitleLangMsg}), 나레이션, 이미지 프롬프트를 생성합니다.`)) {
        return;
    }

    // 결과 영역 표시
    const resultDiv = document.getElementById('frame-analysis-result');
    const contentDiv = document.getElementById('frame-analysis-content');
    resultDiv.style.display = 'block';

    // 예상 시간 계산
    const estimatedSeconds = Math.ceil(frames.length * 4);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const estimatedTime = estimatedMinutes > 0
        ? `약 ${estimatedMinutes}분 ${remainingSeconds}초`
        : `약 ${estimatedSeconds}초`;

    contentDiv.value = `🎬 새로운 쇼츠 콘텐츠 생성 중...\n\n📊 진행 상황:\n- 선택된 프레임: ${frames.length}개\n- 사용 모델: ${modelNames[selectedModel]}\n- 예상 소요 시간: ${estimatedTime}\n\n⏳ AI가 창의적인 쇼츠 콘텐츠를 생성하고 있습니다...`;

    // 진행률 애니메이션
    let dots = 0;
    const progressInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        const dotString = '.'.repeat(dots);
        contentDiv.value = `🎬 새로운 쇼츠 콘텐츠 생성 중${dotString}\n\n📊 진행 상황:\n- 선택된 프레임: ${frames.length}개\n- 사용 모델: ${modelNames[selectedModel]}\n- 예상 소요 시간: ${estimatedTime}\n\n⏳ AI가 창의적인 쇼츠 콘텐츠를 생성하고 있습니다${dotString}`;
    }, 500);

    try {
        // 새로운 쇼츠 콘텐츠 생성을 위한 특별 프롬프트
        const customPrompt = `다음 ${frames.length}개의 이미지를 활용하여 완전히 새로운 유튜브 쇼츠 영상 콘텐츠를 기획해주세요.

🎯 **목표**: 60초 이내의 임팩트 있는 쇼츠 영상 제작

다음 형식으로 작성해주세요:

## 📋 전체 시나리오 (60초 쇼츠)

### 🎬 콘셉트
- 메인 주제 및 컨셉 설명
- 타겟 시청자층
- 기대 효과 및 메시지

### ⏱️ 타임라인 (각 프레임별)

#### [프레임 1] (0-${Math.floor(60/frames.length)}초)
**📝 화면 텍스트 (자막)**
- 화면에 표시될 임팩트 있는 텍스트 (15자 이내)
- 강조할 키워드

**🎙️ 나레이션 대사**
- 자연스러운 구어체 대사 (3-5초 분량)
- 감정 표현 지시사항

**🎨 AI 이미지 생성 프롬프트**
- DALL-E/Midjourney용 상세 영문 프롬프트
- 예시: "A vibrant YouTube shorts scene, close-up shot, dynamic lighting, person expressing excitement, modern minimalist background, high contrast, 9:16 vertical format, professional quality"

**🎞️ 편집 지시사항**
- 전환 효과 (페이드, 컷, 줌 등)
- BGM 분위기
- 특수 효과

${frames.length > 1 ? `\n#### [프레임 2-${frames.length}] (계속...)\n(위와 동일한 형식으로 각 프레임별 상세 내용 작성)` : ''}

### 🎵 음악 & 사운드
- BGM 장르 및 분위기
- 효과음 제안

### 🎯 핵심 요소
- 훅(Hook): 처음 3초에서 시청자를 사로잡는 요소
- 클라이맥스: 가장 임팩트 있는 순간
- CTA(Call To Action): 마지막 행동 유도

**중요**: 각 프레임을 창의적으로 활용하여 완전히 새로운 스토리를 만들어주세요. 단순 분석이 아닌, 실제 쇼츠 영상 제작에 바로 사용할 수 있는 구체적인 콘텐츠를 생성해주세요.`;

        // API 호출
        const response = await fetch('/api/video-analyzer/analyze-frames-with-ai', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                frames: frames,
                model: selectedModel,
                analysis_type: 'custom',
                custom_prompt: customPrompt,
                video_name: currentVideoInfo.name || 'new_shorts',
                subtitle_language_primary: selectedLanguagePrimary,
                subtitle_language_secondary: selectedLanguageSecondary
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || '쇼츠 콘텐츠 생성 실패');
        }

        const result = await response.json();

        // 진행률 애니메이션 중지
        clearInterval(progressInterval);

        // 결과 표시
        contentDiv.value = result.analysis_result;

        // 성공 알림
        alert('✅ 새로운 쇼츠 콘텐츠가 생성되었습니다!\n\n이제 자막, 나레이션, 이미지 프롬프트를 각각 추출하여 영상 제작에 활용하세요.');

    } catch (error) {
        // 진행률 애니메이션 중지
        clearInterval(progressInterval);

        console.error('쇼츠 콘텐츠 생성 오류:', error);
        contentDiv.value = `❌ 오류 발생: ${error.message}`;
        alert(`쇼츠 콘텐츠 생성 중 오류가 발생했습니다:\n${error.message}`);
    }
}

// 이어서 쇼츠 콘텐츠 생성
async function continueGeneratingShortsContent() {
    const contentDiv = document.getElementById('frame-analysis-content');
    const existingContent = contentDiv.value;

    // 기존 내용이 비어있는지 확인
    if (!existingContent || existingContent.trim() === '' || existingContent.includes('✨ 프레임을 선택하고')) {
        alert('⚠️ 기존 콘텐츠가 없습니다.\n\n먼저 "🎬 새 쇼츠 콘텐츠 생성" 버튼을 사용하거나 "🤖 AI 프레임 분석 시작"을 통해 기본 콘텐츠를 생성한 후 이어서 생성할 수 있습니다.');
        return;
    }

    const frameItems = document.querySelectorAll('.frame-item');

    if (frameItems.length === 0) {
        alert('생성할 프레임이 없습니다. 먼저 영상에서 프레임을 추출하세요.');
        return;
    }

    // 선택된 프레임만 수집
    const frames = [];
    frameItems.forEach((item, index) => {
        const checkbox = item.querySelector('.frame-select-checkbox');
        if (checkbox && checkbox.checked) {
            const frameData = item.dataset.frame;
            const label = item.dataset.label || `frame_${index + 1}`;
            frames.push({
                index: index + 1,
                label: label,
                image_data: frameData
            });
        }
    });

    if (frames.length === 0) {
        alert('프레임을 선택하세요. 체크박스를 클릭하여 쇼츠에 사용할 프레임을 선택할 수 있습니다.');
        return;
    }

    // AI 모델과 자막 언어 선택
    const selectedModel = document.getElementById('frame-ai-model-select').value;
    const selectedLanguagePrimary = document.getElementById('subtitle-language-primary').value;
    const selectedLanguageSecondary = document.getElementById('subtitle-language-secondary').value;

    const modelNames = {
        'gpt-4o-mini': 'GPT-4o Mini',
        'sonnet': 'Claude Sonnet',
        'haiku': 'Claude Haiku',
        'gpt-4o': 'GPT-4o'
    };

    const languageNames = {
        'korean': '한국어',
        'english': 'English',
        'japanese': '日本語'
    };

    // 자막 언어 메시지 구성
    let subtitleLangMsg = languageNames[selectedLanguagePrimary];
    if (selectedLanguageSecondary) {
        subtitleLangMsg += ` + ${languageNames[selectedLanguageSecondary]}`;
    }

    // 확인
    if (!confirm(`${frames.length}개의 프레임으로 추가 쇼츠 콘텐츠를 생성하시겠습니까?\n\n${modelNames[selectedModel]} 모델을 사용하여 기존 내용에 이어서 추가 시나리오, 자막(${subtitleLangMsg}), 나레이션, 이미지 프롬프트를 생성합니다.\n\n⚠️ 기존 내용은 유지됩니다.`)) {
        return;
    }

    // 결과 영역 표시
    const resultDiv = document.getElementById('frame-analysis-result');
    resultDiv.style.display = 'block';

    // 예상 시간 계산
    const estimatedSeconds = Math.ceil(frames.length * 4);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const estimatedTime = estimatedMinutes > 0
        ? `약 ${estimatedMinutes}분 ${remainingSeconds}초`
        : `약 ${estimatedSeconds}초`;

    // 기존 내용 저장 후 진행 메시지 표시
    const savedContent = existingContent;
    contentDiv.value = `${savedContent}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n➕ 추가 콘텐츠 생성 중...\n\n📊 진행 상황:\n- 선택된 프레임: ${frames.length}개\n- 사용 모델: ${modelNames[selectedModel]}\n- 예상 소요 시간: ${estimatedTime}\n\n⏳ AI가 추가 콘텐츠를 생성하고 있습니다...`;

    // 진행률 애니메이션
    let dots = 0;
    const progressInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        const dotString = '.'.repeat(dots);
        contentDiv.value = `${savedContent}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n➕ 추가 콘텐츠 생성 중${dotString}\n\n📊 진행 상황:\n- 선택된 프레임: ${frames.length}개\n- 사용 모델: ${modelNames[selectedModel]}\n- 예상 소요 시간: ${estimatedTime}\n\n⏳ AI가 추가 콘텐츠를 생성하고 있습니다${dotString}`;
    }, 500);

    try {
        // 이어서 생성을 위한 프롬프트 (기존 컨텍스트 포함)
        const customPrompt = `다음은 기존에 작성된 쇼츠 콘텐츠입니다:

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${savedContent}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

위 내용에 이어서, 다음 ${frames.length}개의 새로운 이미지를 활용하여 추가 쇼츠 콘텐츠를 생성해주세요.

🎯 **목표**: 기존 콘텐츠의 흐름을 유지하면서 자연스럽게 이어지는 추가 장면 제작

다음 형식으로 작성해주세요:

## 📋 추가 시나리오 (이어지는 부분)

${frames.map((frame, idx) => `
#### [프레임 ${idx + 1}]
**📝 화면 텍스트 (자막)**
- 화면에 표시될 임팩트 있는 텍스트 (15자 이내)
- 강조할 키워드

**🎙️ 나레이션 대사**
- 자연스러운 구어체 대사 (3-5초 분량)
- 감정 표현 지시사항

**🎨 AI 이미지 생성 프롬프트 (ONLY in English!)**
- DALL-E/Midjourney용 상세 영문 프롬프트
- 예시: "A vibrant YouTube shorts scene, close-up shot, dynamic lighting, person expressing excitement, modern minimalist background, high contrast, 9:16 vertical format, professional quality"

**🎞️ 편집 지시사항**
- 전환 효과 (페이드, 컷, 줌 등)
- BGM 분위기
- 특수 효과
`).join('\n')}

**중요**:
1. 기존 콘텐츠의 톤, 스타일, 메시지와 일관성을 유지하세요.
2. 자연스럽게 이어지는 스토리를 만들어주세요.
3. 실제 쇼츠 영상 제작에 바로 사용할 수 있는 구체적인 콘텐츠를 생성해주세요.`;

        // API 호출
        const response = await fetch('/api/video-analyzer/analyze-frames-with-ai', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                frames: frames,
                model: selectedModel,
                analysis_type: 'custom',
                custom_prompt: customPrompt,
                video_name: currentVideoInfo.name || 'shorts_continued',
                subtitle_language_primary: selectedLanguagePrimary,
                subtitle_language_secondary: selectedLanguageSecondary
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || '추가 콘텐츠 생성 실패');
        }

        const result = await response.json();

        // 진행률 애니메이션 중지
        clearInterval(progressInterval);

        // 결과 표시 (기존 내용 + 구분선 + 새 내용)
        contentDiv.value = `${savedContent}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n${result.analysis_result}`;

        // 성공 알림
        alert('✅ 추가 콘텐츠가 생성되었습니다!\n\n기존 내용에 이어서 새로운 장면이 추가되었습니다.');

    } catch (error) {
        // 진행률 애니메이션 중지
        clearInterval(progressInterval);

        console.error('추가 콘텐츠 생성 오류:', error);
        contentDiv.value = `${savedContent}\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n❌ 추가 콘텐츠 생성 오류: ${error.message}`;
        alert(`추가 콘텐츠 생성 중 오류가 발생했습니다:\n${error.message}`);
    }
}

// 자막 파일에서 원본 제목 추출 (시간 구간 포함)
function extractOriginalTitlesFromSubtitles() {
    // loadedSubtitles 객체에서 메인 자막 가져오기
    const mainSubtitles = loadedSubtitles.main || [];
    const titles = [];

    console.log(`📝 자막에서 제목 추출 중... (자막 수: ${mainSubtitles.length}개)`);

    mainSubtitles.forEach((subtitle, index) => {
        const text = subtitle.text;
        const start = subtitle.start;  // SRT 형식: 00:00:00,000
        const end = subtitle.end;

        if (text) {
            // 형식: [1] funny cat and dog fights#shorts [iZHTZZv5_cg]
            // 대괄호 안의 제목 추출
            const match = text.match(/\[(\d+)\]\s*(.+?)\s*\[([^\]]+)\]/);
            if (match) {
                const frameNum = match[1];
                const title = match[2].trim();
                const videoId = match[3];

                // SRT 시간을 초로 변환
                const startSeconds = srtTimeToSeconds(start);
                const endSeconds = srtTimeToSeconds(end);

                titles.push({
                    frame: parseInt(frameNum),
                    title: title,
                    videoId: videoId,
                    startTime: startSeconds,
                    endTime: endSeconds
                });

                console.log(`  ✅ 제목 추출 성공: [${frameNum}] "${title}" (${startSeconds}초~${endSeconds}초)`);
            } else {
                console.log(`  ⚠️ 제목 형식 매칭 실패 (자막 ${index + 1}): "${text}"`);
            }
        }
    });

    console.log(`📊 총 ${titles.length}개의 제목 추출 완료`);
    return titles;
}

// AI 프레임 분석 실행
async function analyzeFramesWithAI() {
    const frameItems = document.querySelectorAll('.frame-item');

    if (frameItems.length === 0) {
        alert('분석할 프레임이 없습니다.');
        return;
    }

    // 선택된 프레임만 수집
    const frames = [];
    frameItems.forEach((item, index) => {
        const checkbox = item.querySelector('.frame-select-checkbox');
        if (checkbox && checkbox.checked) {
            const frameData = item.dataset.frame;
            const label = item.dataset.label || `frame_${index + 1}`;
            const time = parseFloat(item.dataset.time) || 0; // 타임스탬프
            frames.push({
                index: index + 1,
                label: label,
                image_data: frameData,
                time: time  // 타임스탬프 추가
            });
        }
    });

    if (frames.length === 0) {
        alert('분석할 프레임을 선택하세요. 체크박스를 클릭하여 프레임을 선택할 수 있습니다.');
        return;
    }

    // 드롭다운에서 선택한 값 가져오기
    const selectedModel = document.getElementById('frame-ai-model-select').value;
    const selectedType = document.getElementById('frame-analysis-type').value;
    const selectedLanguagePrimary = document.getElementById('subtitle-language-primary').value;
    const selectedLanguageSecondary = document.getElementById('subtitle-language-secondary').value;

    // 모델 이름 매핑
    const modelNames = {
        'gpt-4o-mini': 'GPT-4o Mini',
        'sonnet': 'Claude Sonnet',
        'haiku': 'Claude Haiku',
        'gpt-4o': 'GPT-4o'
    };

    const languageNames = {
        'korean': '한국어',
        'english': 'English',
        'japanese': '日本語'
    };

    const typeNames = {
        'shorts-production': '쇼츠 제작용',
        'scene-description': '장면 설명',
        'object-detection': '객체 인식',
        'text-extraction': '텍스트 추출',
        'story-flow': '스토리 흐름',
        'thumbnail-suggest': '썸네일 추천',
        'custom': '커스텀 프롬프트'
    };

    // 커스텀 프롬프트 처리
    let customPrompt = null;
    if (selectedType === 'custom') {
        customPrompt = document.getElementById('custom-prompt-input').value.trim();
        if (!customPrompt) {
            alert('커스텀 프롬프트를 입력하세요.');
            return;
        }
    }

    // 확인
    if (!confirm(`${frames.length}개의 프레임을 ${modelNames[selectedModel]}로 분석하시겠습니까?\n분석 유형: ${typeNames[selectedType]}`)) {
        return;
    }

    // 결과 영역 표시
    const resultDiv = document.getElementById('frame-analysis-result');
    const contentDiv = document.getElementById('frame-analysis-content');
    resultDiv.style.display = 'block';

    // 예상 시간 계산 (프레임당 약 3초)
    const estimatedSeconds = Math.ceil(frames.length * 3);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const estimatedTime = estimatedMinutes > 0
        ? `약 ${estimatedMinutes}분 ${remainingSeconds}초`
        : `약 ${estimatedSeconds}초`;

    contentDiv.value = `🔄 AI 분석 중...\n\n📊 진행 상황:\n- 선택된 프레임: ${frames.length}개\n- 사용 모델: ${modelNames[selectedModel]}\n- 예상 소요 시간: ${estimatedTime}\n\n⏳ 분석이 진행 중입니다. 잠시만 기다려주세요...`;

    // 진행률 애니메이션 시작
    let dots = 0;
    const progressInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        const dotString = '.'.repeat(dots);
        contentDiv.value = `🔄 AI 분석 중${dotString}\n\n📊 진행 상황:\n- 선택된 프레임: ${frames.length}개\n- 사용 모델: ${modelNames[selectedModel]}\n- 예상 소요 시간: ${estimatedTime}\n\n⏳ 분석이 진행 중입니다. 잠시만 기다려주세요${dotString}`;
    }, 500);

    try {
        // 체크박스 값 가져오기
        const includeExtractedFrames = document.getElementById('include-extracted-frames').checked;
        const includeTitleSubtitle = document.getElementById('include-title-subtitle').checked;

        // 자막에서 원본 제목 추출
        const originalTitles = extractOriginalTitlesFromSubtitles();

        // API 호출
        const requestBody = {
            frames: frames,
            model: selectedModel,
            analysis_type: selectedType,
            video_name: currentVideoInfo.name || 'unknown',
            subtitle_language_primary: selectedLanguagePrimary,
            subtitle_language_secondary: selectedLanguageSecondary,
            include_extracted_frames: includeExtractedFrames,
            include_title_subtitle: includeTitleSubtitle,
            original_titles: originalTitles  // 원본 제목 추가
        };

        // 커스텀 프롬프트가 있으면 추가
        if (customPrompt) {
            requestBody.custom_prompt = customPrompt;
        }

        const response = await fetch('/api/video-analyzer/analyze-frames-with-ai', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'AI 분석 실패');
        }

        const result = await response.json();

        // 진행률 애니메이션 중지
        clearInterval(progressInterval);

        // 결과 표시
        contentDiv.value = result.analysis_result;

        // 성공 알림
        alert('✅ AI 프레임 분석이 완료되었습니다!');

    } catch (error) {
        // 진행률 애니메이션 중지
        clearInterval(progressInterval);

        console.error('AI 프레임 분석 오류:', error);
        contentDiv.value = `❌ 오류 발생: ${error.message}`;
        alert(`AI 프레임 분석 중 오류가 발생했습니다:\n${error.message}`);
    }
}

// ============================================
// AI 자막 분석 관련 함수들
// ============================================

// AI 자막 분석 실행
async function analyzeSubtitlesWithAI() {
    // 현재 자막 데이터 가져오기
    const subtitleItems = document.querySelectorAll('.subtitle-item');

    if (subtitleItems.length === 0) {
        alert('분석할 자막이 없습니다.');
        return;
    }

    // 드롭다운에서 선택한 값 가져오기
    const selectedModel = document.getElementById('ai-model-select').value;
    const selectedType = document.getElementById('analysis-type-select').value;

    // 모델 이름 매핑 (표시용)
    const modelNames = {
        'gpt-4o-mini': 'GPT-4o Mini',
        'sonnet': 'Claude Sonnet',
        'haiku': 'Claude Haiku',
        'gpt-4o': 'GPT-4o'
    };

    const typeNames = {
        'enhanced-shorts': '60초 쇼츠',
        'enhanced-summary': '긴 영상 요약',
        'enhanced-education': '교육 콘텐츠',
        'enhanced': 'Enhanced',
        'shorts': 'Shorts'
    };

    // 자막 데이터를 SRT 형식으로 변환
    let srtContent = '';
    subtitleItems.forEach((item, index) => {
        const start = item.dataset.start;
        const end = item.dataset.end;
        const text = item.dataset.text;

        srtContent += `${index + 1}\n`;
        srtContent += `${start} --> ${end}\n`;
        srtContent += `${text}\n\n`;
    });

    try {
        // 사용자에게 분석 시작 알림
        const confirmMsg = `AI 분석을 시작합니다.\n\n` +
            `📌 모델: ${modelNames[selectedModel]}\n` +
            `📌 타입: ${typeNames[selectedType]}\n` +
            `📌 자막 수: ${subtitleItems.length}개\n\n` +
            `분석에 10-30초 정도 걸릴 수 있습니다.\n계속하시겠습니까?`;

        if (!confirm(confirmMsg)) {
            return;
        }

        // 분석 버튼 비활성화 및 로딩 표시
        const analyzeBtn = event.target;
        const originalText = analyzeBtn.textContent;
        analyzeBtn.disabled = true;
        analyzeBtn.textContent = '🔄 분석 중...';
        analyzeBtn.style.opacity = '0.6';

        // API 호출
        const response = await fetch('/api/video-analyzer/analyze-subtitles-with-ai', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                subtitle_content: srtContent,
                model: selectedModel,
                analysis_type: selectedType
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'AI 분석 실패');
        }

        const data = await response.json();
        const result = data.result;

        // 분석 결과 표시
        displayAnalysisResult(result);

        // 버튼 복원
        analyzeBtn.disabled = false;
        analyzeBtn.textContent = originalText;
        analyzeBtn.style.opacity = '1';

    } catch (error) {
        console.error('AI 분석 실패:', error);
        alert('AI 분석에 실패했습니다: ' + error.message);

        // 버튼 복원
        const analyzeBtn = event.target;
        analyzeBtn.disabled = false;
        analyzeBtn.textContent = '🤖 분석 시작';
        analyzeBtn.style.opacity = '1';
    }
}

// 목업 분석 결과 생성 (테스트용)
function generateMockAnalysisResult(subtitleItems, analysisType) {
    const totalCount = subtitleItems.length;

    // 타입별 삭제율 조정
    let deleteRate, textAddRate, narrationAddRate;

    switch (analysisType) {
        case 'enhanced-shorts':
            deleteRate = 0.65; // 60-70% 삭제
            textAddRate = 0.10; // 텍스트 추가 많이
            narrationAddRate = 0.08;
            break;
        case 'enhanced-summary':
            deleteRate = 0.45; // 40-50% 삭제
            textAddRate = 0.05;
            narrationAddRate = 0.10; // 나레이션 많이
            break;
        case 'enhanced-education':
            deleteRate = 0.25; // 20-30% 삭제 (적게)
            textAddRate = 0.15; // 텍스트 강조 많이
            narrationAddRate = 0.05;
            break;
        default:
            deleteRate = 0.50;
            textAddRate = 0.05;
            narrationAddRate = 0.05;
    }

    const keptCount = Math.floor(totalCount * (1 - deleteRate));
    const deleteCount = totalCount - keptCount;
    const textAddCount = Math.floor(totalCount * textAddRate);
    const narrationAddCount = Math.floor(totalCount * narrationAddRate);

    const result = {
        video_type: analysisType,
        kept_originals: [],
        deletions: [],
        text_additions: [],
        narration_additions: [],
        statistics: {
            original_count: totalCount,
            kept_count: keptCount,
            delete_count: deleteCount,
            text_add_count: textAddCount,
            narration_add_count: narrationAddCount
        }
    };

    // 목업 데이터 생성
    subtitleItems.forEach((item, index) => {
        const start = item.dataset.start;
        const end = item.dataset.end;
        const text = item.dataset.text;

        if (index < keptCount) {
            result.kept_originals.push({
                index: index,
                time: `${start} --> ${end}`,
                text: text,
                reason: '핵심 내용',
                importance: 'high'
            });
        } else if (index < keptCount + deleteCount) {
            result.deletions.push({
                index: index,
                time: `${start} --> ${end}`,
                text: text,
                reason: '반복 내용 / 불필요',
                category: '반복'
            });
        }
    });

    // 타입별 텍스트 추가 예시
    for (let i = 0; i < textAddCount; i++) {
        let textContent, textType;

        switch (analysisType) {
            case 'enhanced-shorts':
                textContent = [`💥 주목!`, `🔥 핵심`, `💡 팁`, `⚡ 중요`, `✨ 포인트`][i % 5];
                textType = '후킹';
                break;
            case 'enhanced-summary':
                textContent = [`[챕터 ${i + 1}]`, `[핵심 요약]`, `[주요 포인트]`][i % 3];
                textType = '챕터제목';
                break;
            case 'enhanced-education':
                textContent = [`📌 개념 ${i + 1}`, `📝 예시`, `💡 복습 포인트`, `🎯 핵심 공식`][i % 4];
                textType = '개념정의';
                break;
            default:
                textContent = `[화면 전환 ${i + 1}]`;
                textType = '강조';
        }

        result.text_additions.push({
            insert_after: Math.floor(i * totalCount / textAddCount),
            estimated_time: '00:00:10',
            text: textContent,
            type: textType,
            position: 'top'
        });
    }

    // 타입별 나레이션 추가 예시
    for (let i = 0; i < narrationAddCount; i++) {
        let narrationText, purpose, tone;

        switch (analysisType) {
            case 'enhanced-shorts':
                narrationText = `이제 가장 중요한 부분입니다!`;
                purpose = '오프닝';
                tone = '열정적';
                break;
            case 'enhanced-summary':
                narrationText = `지금까지 살펴본 내용을 정리하면...`;
                purpose = '섹션요약';
                tone = '전문적';
                break;
            case 'enhanced-education':
                narrationText = `이 개념을 이해하기 위해서는...`;
                purpose = '개념설명';
                tone = '차분한';
                break;
            default:
                narrationText = `요약: 이 부분의 핵심은...`;
                purpose = '전환';
                tone = '전문적';
        }

        result.narration_additions.push({
            insert_after: Math.floor(i * totalCount / narrationAddCount),
            estimated_time: '00:00:15',
            narration_text: narrationText,
            subtitle_text: '나레이션',
            purpose: purpose,
            tone: tone
        });
    }

    return result;
}

// 분석 결과 표시
function displayAnalysisResult(result) {
    // 전역 변수 업데이트
    currentAnalysisResult = result;

    // 기본 자막 뷰 숨기기
    document.getElementById('default-subtitle-view').style.display = 'none';

    // AI 분석 결과 표시
    document.getElementById('ai-analysis-result').style.display = 'block';

    // 통계 업데이트
    const stats = result.statistics || {};
    const originalCount = stats.original_count || result.kept_originals.length + result.deletions.length;
    const finalCount = result.kept_originals.length + result.text_additions.length + result.narration_additions.length;
    const deletionRate = originalCount > 0 ? ((result.deletions.length / originalCount) * 100).toFixed(1) : 0;

    // 시간 계산 (간단 추정: 1자막 = 3초)
    const originalDuration = originalCount * 3;
    const finalDuration = finalCount * 3;

    document.getElementById('original-duration').textContent = formatDuration(originalDuration);
    document.getElementById('summary-duration').textContent = formatDuration(finalDuration);
    document.getElementById('deletion-rate').textContent = `${deletionRate}%`;

    // 적합도 체크 (저장된 값 또는 자동 판단)
    let isShortsCandidate, isSummaryCandidate, isEducationCandidate;

    if (result.suitability) {
        // 불러온 파일에 적합도 정보가 있으면 사용
        isShortsCandidate = result.suitability.shorts;
        isSummaryCandidate = result.suitability.summary;
        isEducationCandidate = result.suitability.education;
    } else {
        // 없으면 자동 판단
        isShortsCandidate = finalDuration <= 60;
        isSummaryCandidate = finalDuration > 60 && finalDuration <= 300;
        isEducationCandidate = result.video_type === 'education';
    }

    document.getElementById('suitable-shorts').checked = isShortsCandidate;
    document.getElementById('suitable-summary').checked = isSummaryCandidate;
    document.getElementById('suitable-education').checked = isEducationCandidate;

    document.getElementById('shorts-score').textContent = isShortsCandidate ? '✓ 적합' : '- 부적합';
    document.getElementById('summary-score').textContent = isSummaryCandidate ? '✓ 적합' : '- 부적합';
    document.getElementById('education-score').textContent = isEducationCandidate ? '✓ 적합' : '- 보통';

    // 각 카테고리 표시
    displayCategoryItems('kept-originals', result.kept_originals, 'kept');
    displayCategoryItems('deletions', result.deletions, 'deletion');
    displayCategoryItems('text-additions', result.text_additions, 'text-add');
    displayCategoryItems('narration-additions', result.narration_additions, 'narration-add');

    // 카운트 업데이트
    document.getElementById('kept-count').textContent = result.kept_originals.length;
    document.getElementById('deletions-count').textContent = result.deletions.length;
    document.getElementById('text-additions-count').textContent = result.text_additions.length;
    document.getElementById('narration-additions-count').textContent = result.narration_additions.length;

    alert('AI 분석이 완료되었습니다!');
}

// 시간 포맷 (초 -> MM:SS)
function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// 카테고리별 아이템 표시
function displayCategoryItems(categoryId, items, cssClass) {
    const container = document.getElementById(categoryId);
    container.innerHTML = '';

    if (items.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">항목이 없습니다.</div>';
        return;
    }

    items.forEach((item, index) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = `category-item ${cssClass}`;
        itemDiv.dataset.index = item.index || index;

        let content = `
            <div class="category-item-header">
                <div>
                    ${item.time ? `<div class="category-item-time">${item.time}</div>` : ''}
                    ${item.estimated_time ? `<div class="category-item-time">예상 시간: ${item.estimated_time}</div>` : ''}
                </div>
                <button onclick="deleteCategoryItem(this)" class="item-delete-btn" title="삭제">🗑️</button>
            </div>
            <div class="category-item-text">
                ${item.text || item.narration_text || '-'}
            </div>
        `;

        // 추가 정보
        if (item.reason) {
            content += `<div class="category-item-reason">이유: ${item.reason}</div>`;
        }
        if (item.importance) {
            content += `<div class="category-item-reason">중요도: ${item.importance}</div>`;
        }
        if (item.type) {
            content += `<div class="category-item-reason">타입: ${item.type}</div>`;
        }
        if (item.purpose) {
            content += `<div class="category-item-reason">목적: ${item.purpose}</div>`;
        }
        if (item.subtitle_text && item.subtitle_text !== item.narration_text) {
            content += `<div class="category-item-reason">자막: ${item.subtitle_text}</div>`;
        }

        itemDiv.innerHTML = content;
        container.appendChild(itemDiv);
    });
}

// 카테고리 접기/펼치기
function toggleCategory(categoryId) {
    const category = document.getElementById(categoryId);
    category.classList.toggle('collapsed');
}

// 개별 항목 삭제
function deleteCategoryItem(button) {
    const item = button.closest('.category-item');

    if (!item) return;

    // 삭제 애니메이션
    item.classList.add('removing');

    setTimeout(() => {
        item.remove();
        updateCategoryCounts();
    }, 300);
}

// 삭제 표시 일괄 삭제
function batchDeleteMarkedForDeletion() {
    const deletionItems = document.querySelectorAll('#deletions .category-item');

    if (deletionItems.length === 0) {
        alert('삭제할 항목이 없습니다.');
        return;
    }

    if (!confirm(`${deletionItems.length}개의 삭제 표시 항목을 제거하시겠습니까?`)) {
        return;
    }

    deletionItems.forEach(item => {
        item.classList.add('removing');
    });

    setTimeout(() => {
        deletionItems.forEach(item => item.remove());
        updateCategoryCounts();
        alert('삭제 표시 항목이 일괄 제거되었습니다.');
    }, 300);
}

// 카테고리 카운트 업데이트
function updateCategoryCounts() {
    document.getElementById('kept-count').textContent =
        document.querySelectorAll('#kept-originals .category-item').length;
    document.getElementById('deletions-count').textContent =
        document.querySelectorAll('#deletions .category-item').length;
    document.getElementById('text-additions-count').textContent =
        document.querySelectorAll('#text-additions .category-item').length;
    document.getElementById('narration-additions-count').textContent =
        document.querySelectorAll('#narration-additions .category-item').length;
}

// ============================================
// 분석 결과 저장/불러오기 기능
// ============================================

// 전역 변수: 현재 분석 결과와 파일명
let currentAnalysisResult = null;
let currentAnalysisFileName = null;

// 현재 분석 결과를 수집하는 함수
function collectCurrentAnalysisResult() {
    const result = {
        video_type: 'unknown',
        video_info: {
            original_duration: document.getElementById('original-duration').textContent,
            summary_duration: document.getElementById('summary-duration').textContent,
            deletion_rate: document.getElementById('deletion-rate').textContent,
        },
        suitability: {
            shorts: document.getElementById('suitable-shorts').checked,
            summary: document.getElementById('suitable-summary').checked,
            education: document.getElementById('suitable-education').checked,
        },
        kept_originals: [],
        deletions: [],
        text_additions: [],
        narration_additions: [],
        timestamp: new Date().toISOString()
    };

    // 각 카테고리의 아이템 수집
    document.querySelectorAll('#kept-originals .category-item').forEach(item => {
        result.kept_originals.push({
            index: item.dataset.index,
            text: item.querySelector('.category-item-text')?.textContent || '',
            time: item.querySelector('.category-item-time')?.textContent || ''
        });
    });

    document.querySelectorAll('#deletions .category-item').forEach(item => {
        result.deletions.push({
            index: item.dataset.index,
            text: item.querySelector('.category-item-text')?.textContent || '',
            time: item.querySelector('.category-item-time')?.textContent || ''
        });
    });

    document.querySelectorAll('#text-additions .category-item').forEach(item => {
        result.text_additions.push({
            text: item.querySelector('.category-item-text')?.textContent || '',
            time: item.querySelector('.category-item-time')?.textContent || ''
        });
    });

    document.querySelectorAll('#narration-additions .category-item').forEach(item => {
        result.narration_additions.push({
            text: item.querySelector('.category-item-text')?.textContent || '',
            time: item.querySelector('.category-item-time')?.textContent || ''
        });
    });

    result.statistics = {
        kept_count: result.kept_originals.length,
        deletions_count: result.deletions.length,
        text_additions_count: result.text_additions.length,
        narration_additions_count: result.narration_additions.length
    };

    return result;
}

// 저장 (현재 파일명으로)
function saveAnalysisResult() {
    const result = collectCurrentAnalysisResult();

    // 파일명이 없으면 "다른 이름으로 저장" 실행
    if (!currentAnalysisFileName) {
        saveAnalysisResultAs();
        return;
    }

    downloadJSON(result, currentAnalysisFileName);
    alert('✅ 분석 결과가 저장되었습니다!');
}

// 다른 이름으로 저장
function saveAnalysisResultAs() {
    const result = collectCurrentAnalysisResult();

    // 기본 파일명 생성
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    const defaultFileName = currentAnalysisFileName || `subtitle_analysis_${timestamp}.json`;

    // 파일명 입력 받기
    const fileName = prompt('저장할 파일명을 입력하세요:', defaultFileName);

    if (!fileName) {
        return; // 취소한 경우
    }

    // .json 확장자 자동 추가
    const finalFileName = fileName.endsWith('.json') ? fileName : `${fileName}.json`;

    // 현재 파일명 업데이트
    currentAnalysisFileName = finalFileName;
    currentAnalysisResult = result;

    downloadJSON(result, finalFileName);
    alert(`✅ "${finalFileName}"로 저장되었습니다!`);
}

// JSON 다운로드 헬퍼 함수
function downloadJSON(data, filename) {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
}

// 브라우저 localStorage에 저장 (자막 분석용)
function saveSubtitleAnalysisToLocalStorage() {
    const result = collectCurrentAnalysisResult();

    if (!result || (!result.kept_originals && !result.deletions)) {
        alert('저장할 분석 결과가 없습니다.');
        return;
    }

    // 저장된 분석 목록 가져오기
    const savedAnalyses = JSON.parse(localStorage.getItem('savedSubtitleAnalyses') || '[]');

    // 파일명 입력 받기
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    const defaultName = `자막분석_${timestamp}`;
    const name = prompt('저장할 이름을 입력하세요:', defaultName);

    if (!name) {
        return; // 취소한 경우
    }

    // 새 분석 저장
    const newAnalysis = {
        id: Date.now(),
        name: name,
        timestamp: new Date().toISOString(),
        result: result
    };

    // 목록에 추가 (최신 것이 위로)
    savedAnalyses.unshift(newAnalysis);

    // 최대 20개까지만 저장
    if (savedAnalyses.length > 20) {
        savedAnalyses.pop();
    }

    // localStorage에 저장
    localStorage.setItem('savedSubtitleAnalyses', JSON.stringify(savedAnalyses));

    alert(`✅ "${name}"으로 브라우저에 저장되었습니다!\n\n💡 "📂 불러오기" 버튼을 클릭하면 저장된 목록을 볼 수 있습니다.`);
}

// 저장된 분석 목록 다이얼로그 표시 (자막 분석용)
function showSubtitleAnalysisDialog() {
    const savedAnalyses = JSON.parse(localStorage.getItem('savedSubtitleAnalyses') || '[]');

    if (savedAnalyses.length === 0) {
        alert('저장된 분석 결과가 없습니다.\n\n💡 "💾 브라우저에 저장" 버튼을 사용하여 분석 결과를 저장할 수 있습니다.');
        return;
    }

    // 다이얼로그 생성
    const backdrop = document.createElement('div');
    backdrop.id = 'load-dialog-backdrop';
    backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
    `;

    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 16px;
        padding: 24px;
        max-width: 800px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
    `;

    // 헤더
    const header = document.createElement('div');
    header.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
    `;
    header.innerHTML = `
        <h3 style="margin: 0; color: #fff; font-size: 1.3rem; font-weight: 600;">
            📂 저장된 분석 결과 (${savedAnalyses.length}개)
        </h3>
        <button onclick="document.getElementById('load-dialog-backdrop').remove()"
                style="background: rgba(255, 255, 255, 0.1); border: none; color: #fff;
                       padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">
            ✕ 닫기
        </button>
    `;

    // 목록 컨테이너
    const listContainer = document.createElement('div');
    listContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 10px;
    `;

    savedAnalyses.forEach((analysis) => {
        const item = document.createElement('div');
        item.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            transition: all 0.2s;
        `;
        item.onmouseenter = () => {
            item.style.background = 'rgba(255, 255, 255, 0.08)';
            item.style.borderColor = 'rgba(139, 92, 246, 0.5)';
        };
        item.onmouseleave = () => {
            item.style.background = 'rgba(255, 255, 255, 0.05)';
            item.style.borderColor = 'rgba(255, 255, 255, 0.1)';
        };

        const date = new Date(analysis.timestamp);
        const dateStr = date.toLocaleString('ko-KR');

        item.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start;">
                <div style="flex: 1;">
                    <div style="color: #fff; font-weight: 600; font-size: 1rem; margin-bottom: 5px;">
                        ${analysis.name}
                    </div>
                    <div style="color: #a0aec0; font-size: 0.85rem;">
                        ${dateStr}
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="loadSubtitleSavedAnalysis('${analysis.id}')"
                            style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
                                   border: none; color: white; padding: 6px 12px; border-radius: 6px;
                                   cursor: pointer; font-size: 0.85rem; font-weight: 500;">
                        불러오기
                    </button>
                    <button onclick="deleteSubtitleSavedAnalysis('${analysis.id}'); event.stopPropagation();"
                            style="background: #ef4444; border: none; color: white; padding: 6px 12px;
                                   border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                        🗑️
                    </button>
                </div>
            </div>
        `;

        listContainer.appendChild(item);
    });

    dialog.appendChild(header);
    dialog.appendChild(listContainer);
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    // ESC 키로 닫기
    const handleEscape = (e) => {
        if (e.key === 'Escape') {
            backdrop.remove();
            document.removeEventListener('keydown', handleEscape);
        }
    };
    document.addEventListener('keydown', handleEscape);

    // 배경 클릭으로 닫기
    backdrop.onclick = (e) => {
        if (e.target === backdrop) {
            backdrop.remove();
            document.removeEventListener('keydown', handleEscape);
        }
    };
}

// 저장된 분석 불러오기 (자막 분석용)
function loadSubtitleSavedAnalysis(id) {
    const savedAnalyses = JSON.parse(localStorage.getItem('savedSubtitleAnalyses') || '[]');
    const analysis = savedAnalyses.find(a => a.id.toString() === id.toString());

    if (!analysis) {
        alert('분석 결과를 찾을 수 없습니다.');
        return;
    }

    // 분석 결과 표시
    displayAnalysisResult(analysis.result);

    // 다이얼로그 닫기
    const backdrop = document.getElementById('load-dialog-backdrop');
    if (backdrop) backdrop.remove();

    alert(`✅ "${analysis.name}"을(를) 불러왔습니다!`);
}

// 저장된 분석 삭제 (자막 분석용)
function deleteSubtitleSavedAnalysis(id) {
    if (!confirm('이 분석 결과를 삭제하시겠습니까?')) {
        return;
    }

    let savedAnalyses = JSON.parse(localStorage.getItem('savedSubtitleAnalyses') || '[]');
    savedAnalyses = savedAnalyses.filter(a => a.id.toString() !== id.toString());
    localStorage.setItem('savedSubtitleAnalyses', JSON.stringify(savedAnalyses));

    // 다이얼로그 새로고침
    const backdrop = document.getElementById('load-dialog-backdrop');
    if (backdrop) backdrop.remove();
    showSubtitleAnalysisDialog();
}

// 파일에서 불러오기 (기존 기능)
function loadAnalysisFromFile() {
    document.getElementById('load-analysis-input').click();
}

// 불러오기
function loadAnalysisResult() {
    document.getElementById('load-analysis-input').click();
}

// 파일 로드 처리
function handleAnalysisFileLoad(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = function(e) {
        try {
            const result = JSON.parse(e.target.result);

            // 파일명 저장
            currentAnalysisFileName = file.name;
            currentAnalysisResult = result;

            // 분석 결과 표시
            displayAnalysisResult(result);

            alert(`✅ "${file.name}"을(를) 불러왔습니다!`);
        } catch (error) {
            console.error('파일 로드 오류:', error);
            alert('❌ JSON 파일을 읽을 수 없습니다: ' + error.message);
        }
    };

    reader.readAsText(file);

    // 파일 입력 초기화 (같은 파일을 다시 선택할 수 있도록)
    event.target.value = '';
}

// ============================================
// 영상 합치기 기능
// ============================================

async function mergeSelectedVideos() {
    if (selectedVideos.length < 2) {
        alert('최소 2개의 영상을 선택해주세요.');
        return;
    }

    // 출력 파일명 입력받기
    const defaultName = `merged_video_${new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19)}.mp4`;
    const outputName = prompt('합쳐진 영상 파일명을 입력하세요:', defaultName);

    if (!outputName) {
        return;  // 취소
    }

    // 로딩 표시
    const statusEl = document.getElementById('folder-status');
    statusEl.textContent = `🔄 ${selectedVideos.length}개 영상을 합치는 중...`;
    statusEl.style.color = '#fbbf24';

    try {
        // API 호출
        const response = await fetch('/api/video-analyzer/merge-videos', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_paths: selectedVideos.map(v => v.path),
                output_name: outputName
            })
        });

        const result = await response.json();

        if (!response.ok) {
            throw new Error(result.detail || '영상 합치기 실패');
        }

        statusEl.textContent = `✅ 영상이 성공적으로 합쳐졌습니다: ${result.output_path}`;
        statusEl.style.color = '#10b981';

        alert(`✅ 영상이 성공적으로 합쳐졌습니다!\n\n경로: ${result.output_path}\n파일 크기: ${result.size_mb} MB`);

        // 목록 새로고침
        await loadVideoFilesFromFolder();

    } catch (error) {
        console.error('영상 합치기 오류:', error);
        statusEl.textContent = `❌ 오류: ${error.message}`;
        statusEl.style.color = '#ef4444';
        alert('영상 합치기 중 오류가 발생했습니다:\n' + error.message);
    }
}

// 영상 파일 이름 바꾸기 기능
async function renameVideoFile(videoPath, videoName, directory) {
    // 파일 확장자 추출
    const lastDotIndex = videoName.lastIndexOf('.');
    const extension = lastDotIndex !== -1 ? videoName.substring(lastDotIndex) : '';
    const nameWithoutExt = lastDotIndex !== -1 ? videoName.substring(0, lastDotIndex) : videoName;

    // 새 이름 입력받기
    const newName = prompt('새 파일 이름을 입력하세요 (확장자 제외):', nameWithoutExt);

    if (!newName) {
        return;  // 취소
    }

    if (newName.trim() === '') {
        alert('파일 이름을 입력해주세요.');
        return;
    }

    // 확장자 추가
    const newFullName = newName.trim() + extension;

    if (newFullName === videoName) {
        alert('동일한 이름입니다.');
        return;
    }

    // 로딩 표시
    const statusEl = document.getElementById('folder-status');
    statusEl.textContent = `✏️ 파일 이름 변경 중...`;
    statusEl.style.color = '#fbbf24';

    try {
        // API 호출
        const response = await fetch('/api/video-analyzer/rename-file', {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                old_path: videoPath,
                new_name: newFullName
            })
        });

        const result = await response.json();

        if (!response.ok) {
            throw new Error(result.detail || '파일 이름 변경 실패');
        }

        statusEl.textContent = `✅ 파일 이름이 변경되었습니다: ${newFullName}`;
        statusEl.style.color = '#10b981';

        // 목록 새로고침
        await loadVideoFilesFromFolder();

        // 3초 후 상태 메시지 초기화
        setTimeout(() => {
            statusEl.textContent = '';
        }, 3000);

    } catch (error) {
        console.error('파일 이름 변경 오류:', error);
        statusEl.textContent = `❌ 오류: ${error.message}`;
        statusEl.style.color = '#ef4444';
        alert('파일 이름 변경 중 오류가 발생했습니다:\n' + error.message);
    }
}

// 영상 파일 삭제 기능
async function deleteVideoFile(videoPath, videoName) {
    // 확인 대화상자
    if (!confirm(`정말로 이 영상을 삭제하시겠습니까?\n\n${videoName}\n\n⚠️ 이 작업은 되돌릴 수 없습니다.`)) {
        return;
    }

    // 로딩 표시
    const statusEl = document.getElementById('folder-status');
    statusEl.textContent = `🗑️ 파일 삭제 중...`;
    statusEl.style.color = '#fbbf24';

    try {
        // API 호출
        const response = await fetch('/api/video-analyzer/delete-file', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_path: videoPath
            })
        });

        const result = await response.json();

        if (!response.ok) {
            throw new Error(result.detail || '파일 삭제 실패');
        }

        statusEl.textContent = `✅ 파일이 삭제되었습니다: ${videoName}`;
        statusEl.style.color = '#10b981';

        // 목록 새로고침
        await loadVideoFilesFromFolder();

        // 3초 후 상태 메시지 초기화
        setTimeout(() => {
            statusEl.textContent = '';
        }, 3000);

    } catch (error) {
        console.error('파일 삭제 오류:', error);
        statusEl.textContent = `❌ 오류: ${error.message}`;
        statusEl.style.color = '#ef4444';
        alert('파일 삭제 중 오류가 발생했습니다:\n' + error.message);
    }
}

// ============================================
// 기존 함수들
// ============================================

// Load video files and settings when page loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎬 페이지 로드 완료 - DOMContentLoaded 이벤트 발생');

    loadSettings();
    setupAutoSave();

    // 영상 파일 선택 이벤트 리스너 추가
    const videoFileInput = document.getElementById('video_file');
    if (videoFileInput) {
        videoFileInput.addEventListener('change', handleVideoFileSelect);
    }

    // 저장된 영상 정보와 프레임들 복원
    restoreCurrentVideoInfo();
    restoreExtractedFrames();

    // 저장된 영상폴더 경로가 있으면 자동으로 목록 불러오기
    const videoPathInput = document.getElementById('video_path');
    const savedPath = videoPathInput ? videoPathInput.value.trim() : '';

    console.log('📂 저장된 경로:', savedPath || '(없음)');

    if (savedPath) {
        // 저장된 경로가 있으면 그것으로 불러오기
        console.log('✅ 저장된 경로로 영상 목록 불러오기:', savedPath);
        loadVideoFiles(savedPath);
    } else {
        // 저장된 경로가 없으면 기본 경로로 자동 불러오기
        const defaultPath = '/home/sk/ws/youtubeanalysis/youtube/download';
        console.log('✅ 기본 경로로 영상 목록 불러오기:', defaultPath);

        if (videoPathInput) {
            videoPathInput.value = defaultPath;
        }

        // 자막 검색 디렉토리도 기본값으로 설정
        const searchDirInput = document.getElementById('search_directory');
        if (searchDirInput && !searchDirInput.value.trim()) {
            searchDirInput.value = defaultPath;
        }

        loadVideoFiles(defaultPath);
    }

    // 프레임 분석 템플릿 불러오기
    loadSavedTemplates();

    // 프레임 분석 설정 불러오기
    loadFrameAnalysisSettings();

    // 프레임 분석 유형 변경 이벤트 (커스텀 프롬프트 표시/숨김)
    const frameAnalysisType = document.getElementById('frame-analysis-type');
    if (frameAnalysisType) {
        frameAnalysisType.addEventListener('change', (e) => {
            const customPromptContainer = document.getElementById('custom-prompt-container');
            if (e.target.value === 'custom') {
                customPromptContainer.style.display = 'block';
            } else {
                customPromptContainer.style.display = 'none';
            }
            // 설정 저장
            saveFrameAnalysisSettings();
        });
    }

    // AI 모델 변경 시 설정 저장
    const frameAiModelSelect = document.getElementById('frame-ai-model-select');
    if (frameAiModelSelect) {
        frameAiModelSelect.addEventListener('change', () => {
            saveFrameAnalysisSettings();
            updateFrameAnalysisCost();
        });
    }

    // 자막 언어 변경 시 설정 저장
    const subtitleLanguagePrimarySelect = document.getElementById('subtitle-language-primary');
    if (subtitleLanguagePrimarySelect) {
        subtitleLanguagePrimarySelect.addEventListener('change', () => {
            saveFrameAnalysisSettings();
        });
    }

    const subtitleLanguageSecondarySelect = document.getElementById('subtitle-language-secondary');
    if (subtitleLanguageSecondarySelect) {
        subtitleLanguageSecondarySelect.addEventListener('change', () => {
            saveFrameAnalysisSettings();
        });
    }

    // 초기 비용 계산
    updateFrameAnalysisCost();
});

// ============================================
// 빠른 접근 스크롤 함수들
// ============================================

// AI 프레임 분석 섹션으로 스크롤
function scrollToFrameAnalysis() {
    const section = document.getElementById('frame-analysis-section');

    if (!section) {
        alert('⚠️ 프레임 분석 섹션을 찾을 수 없습니다.\n\n먼저 영상을 선택하고 프레임을 추출해주세요.');
        return;
    }

    // 섹션이 숨겨져 있다면 보이게 함
    const extractedGallery = document.getElementById('extracted-frames-gallery');
    if (extractedGallery && extractedGallery.style.display === 'none') {
        alert('⚠️ 프레임 분석을 하려면 먼저 프레임을 추출해주세요.\n\n영상 미리보기 섹션에서 "⏱️ 추출" 또는 "📝 자막 기준 프레임 추출" 버튼을 클릭하세요.');
        return;
    }

    // 부드럽게 스크롤
    section.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // 섹션 강조 효과
    section.style.boxShadow = '0 0 30px rgba(102, 126, 234, 0.8)';
    setTimeout(() => {
        section.style.boxShadow = '';
    }, 2000);
}

// AI 자막 분석 섹션으로 스크롤
function scrollToSubtitleAnalysis() {
    const section = document.getElementById('subtitle-analysis-section');

    if (!section) {
        alert('⚠️ 자막 분석 섹션을 찾을 수 없습니다.\n\n먼저 영상을 선택하고 "자막 불러오기" 버튼을 클릭해주세요.');
        return;
    }

    // 부드럽게 스크롤
    section.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // 섹션 강조 효과
    section.style.boxShadow = '0 0 30px rgba(102, 126, 234, 0.8)';
    setTimeout(() => {
        section.style.boxShadow = '';
    }, 2000);
}

// AI 프레임 분석 내용 비우기
function clearFrameAnalysisContent() {
    const content = document.getElementById('frame-analysis-content');

    if (!content) {
        alert('프레임 분석 결과 영역을 찾을 수 없습니다.');
        return;
    }

    if (!content.value || content.value.trim() === '') {
        alert('비울 내용이 없습니다.');
        return;
    }

    if (confirm('🗑️ AI 프레임 분석 결과를 모두 지우시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.')) {
        content.value = '';
        alert('✅ AI 프레임 분석 결과가 비워졌습니다.');
    }
}

// AI 자막 분석 내용 비우기
function clearSubtitleAnalysisContent() {
    const aiAnalysisResult = document.getElementById('ai-analysis-result');
    const defaultSubtitleView = document.getElementById('default-subtitle-view');

    if (!aiAnalysisResult) {
        alert('자막 분석 결과 영역을 찾을 수 없습니다.');
        return;
    }

    // AI 분석 결과가 표시되어 있는지 확인
    if (aiAnalysisResult.style.display === 'none' || !aiAnalysisResult.style.display) {
        alert('비울 내용이 없습니다.');
        return;
    }

    if (confirm('🗑️ AI 자막 분석 결과를 모두 지우시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.')) {
        // AI 분석 결과 숨기기
        aiAnalysisResult.style.display = 'none';

        // 기본 자막 뷰 보이기
        if (defaultSubtitleView) {
            defaultSubtitleView.style.display = 'block';
        }

        // 전역 분석 결과 변수 초기화
        if (typeof currentAnalysisResult !== 'undefined') {
            currentAnalysisResult = null;
        }

        alert('✅ AI 자막 분석 결과가 비워졌습니다.');
    }
}

// ==================== 펼치기/접기 기능 ====================

// 프레임 추출 버튼 펼치기/접기
function toggleFrameExtractionButtons() {
    const buttonsArea = document.getElementById('frame-extraction-buttons');
    const toggleIcon = document.getElementById('frame-extraction-toggle-icon');

    if (buttonsArea.style.display === 'none' || buttonsArea.style.display === '') {
        buttonsArea.style.display = 'flex';
        toggleIcon.textContent = '▲';
    } else {
        buttonsArea.style.display = 'none';
        toggleIcon.textContent = '▼';
    }
}

// AI 프레임 분석 섹션 펼치기/접기
function toggleFrameAnalysisSection() {
    const contentArea = document.getElementById('frame-analysis-content-area');
    const toggleIcon = document.getElementById('frame-analysis-toggle-icon');

    if (contentArea.style.display === 'none' || contentArea.style.display === '') {
        contentArea.style.display = 'block';
        toggleIcon.textContent = '▲';
    } else {
        contentArea.style.display = 'none';
        toggleIcon.textContent = '▼';
    }
}

// AI 자막 분석 섹션 펼치기/접기
function toggleSubtitleAnalysisSection() {
    const contentArea = document.getElementById('subtitle-analysis-content-area');
    const toggleIcon = document.getElementById('subtitle-analysis-toggle-icon');

    if (contentArea.style.display === 'none' || contentArea.style.display === '') {
        contentArea.style.display = 'block';
        toggleIcon.textContent = '▲';
    } else {
        contentArea.style.display = 'none';
        toggleIcon.textContent = '▼';
    }
}

// ==================== 텍스트 오버레이 기능 ====================

// 텍스트 오버레이를 드래그 가능하게 만드는 함수
function makeOverlayDraggable(overlayElement) {
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    overlayElement.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;

        if (e.target === overlayElement) {
            isDragging = true;
        }
    }

    function drag(e) {
        if (isDragging) {
            e.preventDefault();

            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;

            xOffset = currentX;
            yOffset = currentY;

            setTranslate(currentX, currentY, overlayElement);
        }
    }

    function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
    }

    function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate(${xPos}px, ${yPos}px)`;
    }
}

// 텍스트 효과 적용 함수
function applyTextEffect(element, staticEffect, dynamicEffect) {
    // 기존 효과 클래스 제거
    element.classList.remove('effect-outline', 'effect-shadow', 'effect-glow',
                           'effect-gradient', 'effect-neon',
                           'effect-fade', 'effect-slide-up', 'effect-slide-down',
                           'effect-bounce', 'effect-pulse');

    // 정적 효과 적용
    if (staticEffect && staticEffect !== 'none') {
        element.classList.add(`effect-${staticEffect}`);
    }

    // 동적 효과 적용
    if (dynamicEffect && dynamicEffect !== 'none') {
        element.classList.add(`effect-${dynamicEffect}`);
    }
}

// 텍스트 오버레이 업데이트 함수
function updateTextOverlays() {
    const titleOverlay = document.getElementById('video-title-overlay');
    const subtitleOverlay = document.getElementById('video-subtitle-overlay');

    // 제목
    const titleInput = document.getElementById('overlay-title-input');
    const titleSize = document.getElementById('overlay-title-size');
    const titleColor = document.getElementById('overlay-title-color');
    const titleStaticEffect = document.getElementById('overlay-title-static-effect');
    const titleDynamicEffect = document.getElementById('overlay-title-dynamic-effect');

    // 제목 숨김 체크박스 상태 확인
    const hideTitleCheckbox = document.getElementById('hide-title-overlay');
    const isTitleHidden = hideTitleCheckbox && hideTitleCheckbox.checked;

    if (titleInput && titleInput.value.trim()) {
        titleOverlay.textContent = titleInput.value;
        titleOverlay.style.display = isTitleHidden ? 'none' : 'block';
        titleOverlay.style.opacity = '1';
        titleOverlay.classList.remove('empty');
        titleOverlay.style.fontSize = titleSize.value + 'px';
        titleOverlay.style.color = titleColor.value;
        applyTextEffect(titleOverlay, titleStaticEffect.value, titleDynamicEffect.value);
    } else {
        titleOverlay.textContent = '영상 제목을 입력하세요';
        titleOverlay.style.display = isTitleHidden ? 'none' : 'block';
        titleOverlay.style.opacity = '0.5';
        titleOverlay.style.fontSize = '48px';
        titleOverlay.style.color = 'white';
    }

    // 부제목
    const subtitleInput = document.getElementById('overlay-subtitle-input');
    const subtitleSize = document.getElementById('overlay-subtitle-size');
    const subtitleColor = document.getElementById('overlay-subtitle-color');
    const subtitleStaticEffect = document.getElementById('overlay-subtitle-static-effect');
    const subtitleDynamicEffect = document.getElementById('overlay-subtitle-dynamic-effect');

    // 부제목 숨김 체크박스 상태 확인
    const hideSubtitleCheckbox = document.getElementById('hide-subtitle-overlay');
    const isSubtitleHidden = hideSubtitleCheckbox && hideSubtitleCheckbox.checked;

    if (subtitleInput && subtitleInput.value.trim()) {
        subtitleOverlay.textContent = subtitleInput.value;
        subtitleOverlay.style.display = isSubtitleHidden ? 'none' : 'block';
        subtitleOverlay.style.opacity = '1';
        subtitleOverlay.classList.remove('empty');
        subtitleOverlay.style.fontSize = subtitleSize.value + 'px';
        subtitleOverlay.style.color = subtitleColor.value;
        applyTextEffect(subtitleOverlay, subtitleStaticEffect.value, subtitleDynamicEffect.value);
    } else {
        subtitleOverlay.textContent = '부제목을 입력하세요';
        subtitleOverlay.style.display = isSubtitleHidden ? 'none' : 'block';
        subtitleOverlay.style.opacity = '0.5';
        subtitleOverlay.style.fontSize = '32px';
        subtitleOverlay.style.color = '#ffe14d';
    }

    // 주자막 (Korean) 업데이트
    const koreanInput = document.getElementById('overlay-korean-input');
    const koreanSize = document.getElementById('overlay-korean-size');
    const koreanColor = document.getElementById('overlay-korean-color');
    const koreanX = document.getElementById('overlay-korean-x');
    const koreanY = document.getElementById('overlay-korean-y');
    const koreanEffect = document.getElementById('overlay-korean-effect');

    if (koreanInput && koreanSize && koreanColor && koreanX && koreanY && koreanEffect) {
        // updateSubtitleOverlay 함수 호출하여 주자막 업데이트
        if (typeof updateSubtitleOverlay === 'function') {
            updateSubtitleOverlay(
                koreanInput.value,
                koreanSize.value,
                koreanColor.value,
                koreanX.value,
                koreanY.value,
                koreanEffect.value
            );
        }
    }

    // 보조자막 (English) 업데이트
    const englishInput = document.getElementById('overlay-english-input');
    const englishSize = document.getElementById('overlay-english-size');
    const englishColor = document.getElementById('overlay-english-color');
    const englishX = document.getElementById('overlay-english-x');
    const englishY = document.getElementById('overlay-english-y');
    const englishEffect = document.getElementById('overlay-english-effect');

    if (englishInput && englishSize && englishColor && englishX && englishY && englishEffect) {
        // updateSecondarySubtitleOverlay 함수 호출하여 보조자막 업데이트
        if (typeof updateSecondarySubtitleOverlay === 'function') {
            updateSecondarySubtitleOverlay(
                englishInput.value,
                englishSize.value,
                englishColor.value,
                englishX.value,
                englishY.value,
                englishEffect.value
            );
        }
    }

    // Canvas 텍스트 오버레이 동기화
    updateCanvasText();
}

// 텍스트 오버레이 설정 저장
function saveTextOverlaySettings() {
    const settings = {
        title: {
            text: document.getElementById('overlay-title-input').value,
            size: document.getElementById('overlay-title-size').value,
            color: document.getElementById('overlay-title-color').value,
            staticEffect: document.getElementById('overlay-title-static-effect').value,
            dynamicEffect: document.getElementById('overlay-title-dynamic-effect').value,
            position: document.getElementById('video-title-overlay').style.transform
        },
        subtitle: {
            text: document.getElementById('overlay-subtitle-input').value,
            size: document.getElementById('overlay-subtitle-size').value,
            color: document.getElementById('overlay-subtitle-color').value,
            staticEffect: document.getElementById('overlay-subtitle-static-effect').value,
            dynamicEffect: document.getElementById('overlay-subtitle-dynamic-effect').value,
            position: document.getElementById('video-subtitle-overlay').style.transform
        }
    };

    try {
        localStorage.setItem('videoAnalyzerTextOverlay', JSON.stringify(settings));
        alert('✅ 텍스트 오버레이 설정이 저장되었습니다!');
        console.log('💾 설정 저장됨:', settings);
    } catch (e) {
        console.error('❌ 설정 저장 실패:', e);
        alert('❌ 설정 저장에 실패했습니다.');
    }
}

// 텍스트 오버레이 설정 불러오기
function loadTextOverlaySettings() {
    try {
        const saved = localStorage.getItem('videoAnalyzerTextOverlay');
        if (!saved) {
            alert('⚠️ 저장된 설정이 없습니다.');
            return;
        }

        const settings = JSON.parse(saved);

        // 제목 설정 복원
        if (settings.title) {
            document.getElementById('overlay-title-input').value = settings.title.text || '';
            document.getElementById('overlay-title-size').value = settings.title.size || '48';
            document.getElementById('overlay-title-color').value = settings.title.color || '#ffffff';
            document.getElementById('overlay-title-static-effect').value = settings.title.staticEffect || 'none';
            document.getElementById('overlay-title-dynamic-effect').value = settings.title.dynamicEffect || 'none';

            // 크기 표시 업데이트
            document.getElementById('title-size-display').textContent = settings.title.size + 'px';

            // 위치 복원
            if (settings.title.position) {
                document.getElementById('video-title-overlay').style.transform = settings.title.position;
            }
        }

        // 부제목 설정 복원
        if (settings.subtitle) {
            document.getElementById('overlay-subtitle-input').value = settings.subtitle.text || '';
            document.getElementById('overlay-subtitle-size').value = settings.subtitle.size || '32';
            document.getElementById('overlay-subtitle-color').value = settings.subtitle.color || '#ffe14d';
            document.getElementById('overlay-subtitle-static-effect').value = settings.subtitle.staticEffect || 'none';
            document.getElementById('overlay-subtitle-dynamic-effect').value = settings.subtitle.dynamicEffect || 'none';

            // 크기 표시 업데이트
            document.getElementById('subtitle-size-display').textContent = settings.subtitle.size + 'px';

            // 위치 복원
            if (settings.subtitle.position) {
                document.getElementById('video-subtitle-overlay').style.transform = settings.subtitle.position;
            }
        }

        // 한글 자막 설정 복원
        if (settings.korean) {
            document.getElementById('overlay-korean-input').value = settings.korean.text || '';
            document.getElementById('overlay-korean-size').value = settings.korean.size || '32';
            document.getElementById('overlay-korean-color').value = settings.korean.color || '#000000';
            document.getElementById('overlay-korean-x').value = settings.korean.x || '50';
            document.getElementById('overlay-korean-y').value = settings.korean.y || '65';
            // 하위 호환성: 기존 effect 값이 있으면 staticEffect로 사용
            if (settings.korean.staticEffect !== undefined) {
                document.getElementById('overlay-korean-static-effect').value = settings.korean.staticEffect || 'outline';
            } else if (settings.korean.effect) {
                document.getElementById('overlay-korean-static-effect').value = settings.korean.effect || 'outline';
            }
            if (settings.korean.dynamicEffect !== undefined) {
                document.getElementById('overlay-korean-dynamic-effect').value = settings.korean.dynamicEffect || 'none';
            }

            // 크기 표시 업데이트
            document.getElementById('korean-size-display').textContent = settings.korean.size + 'px';
        }

        // 일본어 자막 설정 복원
        if (settings.japanese) {
            document.getElementById('overlay-japanese-input').value = settings.japanese.text || '';
            document.getElementById('overlay-japanese-size').value = settings.japanese.size || '30';
            document.getElementById('overlay-japanese-color').value = settings.japanese.color || '#000000';
            document.getElementById('overlay-japanese-x').value = settings.japanese.x || '50';
            document.getElementById('overlay-japanese-y').value = settings.japanese.y || '83';
            // 하위 호환성: 기존 effect 값이 있으면 staticEffect로 사용
            if (settings.japanese.staticEffect !== undefined) {
                document.getElementById('overlay-japanese-static-effect').value = settings.japanese.staticEffect || 'outline';
            } else if (settings.japanese.effect) {
                document.getElementById('overlay-japanese-static-effect').value = settings.japanese.effect || 'outline';
            }
            if (settings.japanese.dynamicEffect !== undefined) {
                document.getElementById('overlay-japanese-dynamic-effect').value = settings.japanese.dynamicEffect || 'none';
            }

            // 크기 표시 업데이트
            document.getElementById('japanese-size-display').textContent = settings.japanese.size + 'px';
        }

        // 영어 자막 설정 복원
        if (settings.english) {
            document.getElementById('overlay-english-input').value = settings.english.text || '';
            document.getElementById('overlay-english-size').value = settings.english.size || '28';
            document.getElementById('overlay-english-color').value = settings.english.color || '#000000';
            document.getElementById('overlay-english-x').value = settings.english.x || '50';
            document.getElementById('overlay-english-y').value = settings.english.y || '90';
            // 하위 호환성: 기존 effect 값이 있으면 staticEffect로 사용
            if (settings.english.staticEffect !== undefined) {
                document.getElementById('overlay-english-static-effect').value = settings.english.staticEffect || 'outline';
            } else if (settings.english.effect) {
                document.getElementById('overlay-english-static-effect').value = settings.english.effect || 'outline';
            }
            if (settings.english.dynamicEffect !== undefined) {
                document.getElementById('overlay-english-dynamic-effect').value = settings.english.dynamicEffect || 'none';
            }

            // 크기 표시 업데이트
            document.getElementById('english-size-display').textContent = settings.english.size + 'px';
        }

        // 검정 배경 설정 복원
        if (settings.blackBars) {
            // 상단 배경
            if (settings.blackBars.top) {
                document.getElementById('top-bar-enable').checked = settings.blackBars.top.enabled || false;
                document.getElementById('top-bar-height').value = settings.blackBars.top.height || '15';
                document.getElementById('top-bar-opacity').value = settings.blackBars.top.opacity || '80';

                if (settings.blackBars.top.enabled) {
                    toggleBlackBar('top');
                }
            }

            // 하단 배경
            if (settings.blackBars.bottom) {
                document.getElementById('bottom-bar-enable').checked = settings.blackBars.bottom.enabled || false;
                document.getElementById('bottom-bar-height').value = settings.blackBars.bottom.height || '15';
                document.getElementById('bottom-bar-opacity').value = settings.blackBars.bottom.opacity || '80';

                if (settings.blackBars.bottom.enabled) {
                    toggleBlackBar('bottom');
                }
            }
        }

        // 오버레이 업데이트
        updateTextOverlays();

        alert('✅ 텍스트 오버레이 및 검정 배경 설정이 불러와졌습니다!');
        console.log('📂 설정 불러옴:', settings);
    } catch (e) {
        console.error('❌ 설정 불러오기 실패:', e);
        alert('❌ 설정 불러오기에 실패했습니다.');
    }
}

// 텍스트 오버레이 지우기
function clearTextOverlay() {
    if (confirm('🗑️ 모든 텍스트 오버레이를 지우시겠습니까?')) {
        // 입력 필드 초기화
        document.getElementById('overlay-title-input').value = '';
        document.getElementById('overlay-subtitle-input').value = '';
        document.getElementById('overlay-korean-input').value = '';
        document.getElementById('overlay-japanese-input').value = '';
        document.getElementById('overlay-english-input').value = '';
        document.getElementById('overlay-source-input').value = '';

        // 오버레이를 예시 텍스트로 복원
        const titleOverlay = document.getElementById('video-title-overlay');
        titleOverlay.textContent = '영상 제목을 입력하세요';
        titleOverlay.style.display = 'block';
        titleOverlay.style.opacity = '0.5';

        const subtitleOverlay = document.getElementById('video-subtitle-overlay');
        subtitleOverlay.textContent = '부제목을 입력하세요';
        subtitleOverlay.style.display = 'block';
        subtitleOverlay.style.opacity = '0.5';

        const koreanOverlay = document.getElementById('korean-subtitle-overlay');
        koreanOverlay.textContent = '';
        koreanOverlay.style.display = 'none';

        const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
        japaneseOverlay.textContent = '';
        japaneseOverlay.style.display = 'none';

        const englishOverlay = document.getElementById('english-subtitle-overlay');
        englishOverlay.textContent = '';
        englishOverlay.style.display = 'none';

        const sourceOverlay = document.getElementById('source-overlay');
        sourceOverlay.textContent = '';
        sourceOverlay.style.display = 'none';

        console.log('🗑️ 텍스트 오버레이 지움');
    }
}

// ========================================
// 검정 배경 기능
// ========================================

// 검정 배경 토글
function toggleBlackBar(position) {
    const bar = document.getElementById(`${position}-black-bar`);
    const checkbox = document.getElementById(`${position}-bar-enable`);

    if (checkbox.checked) {
        bar.style.display = 'block';
        updateBlackBar(position);
        console.log(`✅ ${position === 'top' ? '상단' : '하단'} 검정 배경 활성화`);
    } else {
        bar.style.display = 'none';
        console.log(`❌ ${position === 'top' ? '상단' : '하단'} 검정 배경 비활성화`);
    }

    // Canvas 업데이트
    updateCanvasBlackBars();
}

// 검정 배경 업데이트
function updateBlackBar(position) {
    const bar = document.getElementById(`${position}-black-bar`);
    const height = document.getElementById(`${position}-bar-height`).value;
    const opacity = document.getElementById(`${position}-bar-opacity`).value;

    // 높이 업데이트
    bar.style.height = height + '%';
    document.getElementById(`${position}-bar-height-display`).textContent = height + '%';

    // 투명도 업데이트
    const opacityValue = opacity / 100;
    bar.style.background = `rgba(0, 0, 0, ${opacityValue})`;
    document.getElementById(`${position}-bar-opacity-display`).textContent = opacity + '%';

    // Canvas 업데이트
    updateCanvasBlackBars();
}

// ========================================
// 한글/영어 자막 기능
// ========================================

// 한글 자막 적용
function applyKoreanSubtitle() {
    const overlay = document.getElementById('korean-subtitle-overlay');
    const text = document.getElementById('overlay-korean-input').value.trim();
    const size = document.getElementById('overlay-korean-size').value;
    const color = document.getElementById('overlay-korean-color').value;
    const x = document.getElementById('overlay-korean-x').value;
    const y = document.getElementById('overlay-korean-y').value;
    const staticEffect = document.getElementById('overlay-korean-static-effect').value;
    const dynamicEffect = document.getElementById('overlay-korean-dynamic-effect').value;

    if (!text) {
        overlay.textContent = '';
        overlay.style.display = 'none';
        overlay.classList.add('empty');
        return;
    }

    overlay.textContent = text;
    overlay.style.display = 'block';
    overlay.style.opacity = '1';
    overlay.classList.remove('empty');
    overlay.style.fontSize = size + 'px';
    overlay.style.color = color;
    overlay.style.left = x + '%';
    overlay.style.top = y + '%';

    // 🌏 언어 자동 감지 및 최적 폰트 적용
    const detectedLang = detectLanguage(text);
    const optimalFont = getFontFamilyForLanguage(detectedLang);
    overlay.style.fontFamily = optimalFont;

    // 효과 제거 후 재적용
    overlay.className = 'custom-subtitle-overlay';
    overlay.setAttribute('data-lang', detectedLang);
    overlay.setAttribute('lang', detectedLang);

    // 정적 효과 적용
    if (staticEffect && staticEffect !== 'none') {
        overlay.classList.add(`effect-${staticEffect}`);
    }

    // 동적 효과 적용
    if (dynamicEffect && dynamicEffect !== 'none') {
        overlay.classList.add(`effect-${dynamicEffect}`);
    }

    // Canvas에도 동기화
    if (typeof updateCanvasText === 'function') {
        updateCanvasText();
    }

    console.log(`✅ 주 자막 적용: ${text} (언어: ${detectedLang})`);
}

// 일본어 자막 적용 (메인 자막)
function applyJapaneseSubtitle() {
    const overlay = document.getElementById('japanese-subtitle-overlay');
    const text = document.getElementById('overlay-japanese-input').value.trim();
    const size = document.getElementById('overlay-japanese-size').value;
    const color = document.getElementById('overlay-japanese-color').value;
    const x = document.getElementById('overlay-japanese-x').value;
    const y = document.getElementById('overlay-japanese-y').value;
    const staticEffect = document.getElementById('overlay-japanese-static-effect').value;
    const dynamicEffect = document.getElementById('overlay-japanese-dynamic-effect').value;

    if (!text) {
        overlay.textContent = '';
        overlay.style.display = 'none';
        overlay.classList.add('empty');
        return;
    }

    overlay.textContent = text;
    overlay.style.display = 'block';
    overlay.style.opacity = '1';
    overlay.classList.remove('empty');
    overlay.style.fontSize = size + 'px';
    overlay.style.color = color;
    overlay.style.left = x + '%';
    overlay.style.top = y + '%';

    // 일본어 폰트 최적화 (이모지 폰트 포함)
    const optimalFont = getFontFamilyForLanguage('ja');
    overlay.style.fontFamily = optimalFont;

    // 효과 제거 후 재적용
    overlay.className = 'custom-subtitle-overlay';
    overlay.setAttribute('data-lang', 'japanese');
    overlay.setAttribute('lang', 'ja');

    // 정적 효과 적용
    if (staticEffect && staticEffect !== 'none') {
        overlay.classList.add(`effect-${staticEffect}`);
    }

    // 동적 효과 적용
    if (dynamicEffect && dynamicEffect !== 'none') {
        overlay.classList.add(`effect-${dynamicEffect}`);
    }

    console.log(`✅ 메인 자막 (일본어) 적용: ${text}`);
}

// 영어 자막 적용
function applyEnglishSubtitle() {
    const overlay = document.getElementById('english-subtitle-overlay');
    const text = document.getElementById('overlay-english-input').value.trim();
    const size = document.getElementById('overlay-english-size').value;
    const color = document.getElementById('overlay-english-color').value;
    const x = document.getElementById('overlay-english-x').value;
    const y = document.getElementById('overlay-english-y').value;
    const staticEffect = document.getElementById('overlay-english-static-effect').value;
    const dynamicEffect = document.getElementById('overlay-english-dynamic-effect').value;

    if (!text) {
        overlay.textContent = '';
        overlay.style.display = 'none';
        overlay.classList.add('empty');
        return;
    }

    overlay.textContent = text;
    overlay.style.display = 'block';
    overlay.style.opacity = '1';
    overlay.classList.remove('empty');
    overlay.style.fontSize = size + 'px';
    overlay.style.color = color;
    overlay.style.left = x + '%';
    overlay.style.top = y + '%';

    // 🌏 언어 자동 감지 및 최적 폰트 적용
    const detectedLang = detectLanguage(text);
    const optimalFont = getFontFamilyForLanguage(detectedLang);
    overlay.style.fontFamily = optimalFont;

    // 효과 제거 후 재적용
    overlay.className = 'custom-subtitle-overlay';
    overlay.setAttribute('data-lang', detectedLang);
    overlay.setAttribute('lang', detectedLang);

    // 정적 효과 적용
    if (staticEffect && staticEffect !== 'none') {
        overlay.classList.add(`effect-${staticEffect}`);
    }

    // 동적 효과 적용
    if (dynamicEffect && dynamicEffect !== 'none') {
        overlay.classList.add(`effect-${dynamicEffect}`);
    }

    // Canvas에도 동기화
    if (typeof updateCanvasText === 'function') {
        updateCanvasText();
    }

    console.log(`✅ 보조 자막 적용: ${text} (언어: ${detectedLang})`);
}

// 제목 적용
// AI 제목 & 부제목 생성
async function generateAITitleSubtitle() {
    const statusDiv = document.getElementById('ai-generation-status');
    const statusText = document.getElementById('ai-status-text');
    const statusTimer = document.getElementById('ai-status-timer');
    const titleInput = document.getElementById('overlay-title-input');
    const subtitleInput = document.getElementById('overlay-subtitle-input');

    // 타이머 관련 변수
    let startTime = Date.now();
    let timerInterval = null;

    try {
        // 상태 표시
        if (statusDiv) {
            statusDiv.style.display = 'block';
        }
        if (statusText) {
            statusText.textContent = '⏳ AI가 제목과 부제목을 생성하고 있습니다...';
        }

        // 경과 시간 표시 타이머 시작
        timerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            if (statusTimer) {
                statusTimer.textContent = `경과 시간: ${elapsed}초`;
            }
        }, 100);

        // 현재 영상 정보 가져오기
        const savedVideoInfo = localStorage.getItem(VIDEO_INFO_STORAGE_KEY);
        if (!savedVideoInfo) {
            throw new Error('영상 정보를 찾을 수 없습니다. 먼저 영상을 선택해주세요.');
        }

        const videoInfo = JSON.parse(savedVideoInfo);
        const videoPath = videoInfo.path || videoInfo.file_path;

        if (!videoPath) {
            throw new Error('영상 경로를 찾을 수 없습니다.');
        }

        // 선택된 AI 모델 가져오기
        const selectedModel = document.getElementById('ai-model-select')?.value || 'claude';

        // 타임아웃 설정 (30초)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        // AI 제목/부제목 생성 API 호출
        const response = await fetch('/api/video-analyzer/generate-title-subtitle', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_path: videoPath,
                video_info: videoInfo,
                model: selectedModel
            }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'AI 생성에 실패했습니다.');
        }

        const data = await response.json();

        // 타이머 중지
        if (timerInterval) {
            clearInterval(timerInterval);
        }

        // 총 소요 시간 계산
        const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);

        // 생성된 제목과 부제목을 입력 필드에 설정
        if (titleInput && data.title) {
            titleInput.value = data.title;
            // 제목 자동 적용
            try {
                applyTitle();
                console.log('✅ 제목 자동 적용 완료');
            } catch (e) {
                console.warn('⚠️ 제목 자동 적용 실패:', e);
            }
        }

        if (subtitleInput && data.subtitle) {
            subtitleInput.value = data.subtitle;
            // 부제목 자동 적용
            try {
                applySubtitle();
                console.log('✅ 부제목 자동 적용 완료');
            } catch (e) {
                console.warn('⚠️ 부제목 자동 적용 실패:', e);
            }
        }

        // 성공 메시지
        if (statusText) {
            statusText.innerHTML = '✅ AI 제목과 부제목이 생성되어 입력 필드에 설정되었습니다!';
        }
        if (statusTimer) {
            statusTimer.innerHTML = `완료 시간: ${totalTime}초 | 모델: ${data.model || selectedModel}<br><small style="color: #94a3b8;">💡 아래 "✅ 제목 적용" / "✅ 부제목 적용" 버튼을 눌러 영상에 적용하세요.</small>`;
        }
        if (statusDiv) {
            statusDiv.style.color = '#4ade80';
            setTimeout(() => {
                statusDiv.style.display = 'none';
                statusDiv.style.color = '#94a3b8';
            }, 5000);
        }

        console.log(`✅ AI 제목/부제목 생성 완료 (${totalTime}초):`, { title: data.title, subtitle: data.subtitle, model: data.model });

    } catch (error) {
        console.error('❌ AI 제목/부제목 생성 실패:', error);

        // 타이머 중지
        if (timerInterval) {
            clearInterval(timerInterval);
        }

        // 에러 메시지 처리
        let errorMessage = error.message;
        if (error.name === 'AbortError') {
            errorMessage = '요청 시간이 초과되었습니다 (30초). 다시 시도해주세요.';
        }

        if (statusText) {
            statusText.innerHTML = `❌ ${errorMessage}`;
        }
        if (statusTimer) {
            statusTimer.textContent = '';
        }
        if (statusDiv) {
            statusDiv.style.color = '#f87171';
            setTimeout(() => {
                statusDiv.style.display = 'none';
                statusDiv.style.color = '#94a3b8';
            }, 8000);
        }

        alert(`AI 제목/부제목 생성 실패: ${errorMessage}`);
    }
}

/**
 * 텍스트 언어 자동 감지 (한국어/일본어/영어)
 */
function detectLanguage(text) {
    if (!text) return 'ko'; // 기본값: 한국어

    // 일본어 감지: 히라가나, 가타카나
    const hasHiragana = /[\u3040-\u309F]/.test(text);
    const hasKatakana = /[\u30A0-\u30FF]/.test(text);
    if (hasHiragana || hasKatakana) {
        return 'ja';
    }

    // 한국어 감지: 한글
    const hasHangul = /[\uAC00-\uD7AF\u1100-\u11FF]/.test(text);
    if (hasHangul) {
        return 'ko';
    }

    // 한자(CJK Unified Ideographs) - 한중일 공통
    const hasCJK = /[\u4E00-\u9FFF]/.test(text);
    if (hasCJK) {
        // 한자만 있는 경우, 전체 텍스트 분석으로 추가 판단
        // 일본어는 한자+히라가나 혼용이 일반적이므로 한국어로 간주
        return 'ko';
    }

    // 그 외는 영어
    return 'en';
}

/**
 * 언어에 맞는 최적의 font-family 반환
 */
function getFontFamilyForLanguage(lang) {
    const fontStacks = {
        // 일본어: 시스템 폰트 우선 + Google Fonts fallback + 이모지 폰트
        'ja': "'ヒラギノ角ゴ ProN', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Yu Gothic', 'メイリオ', Meiryo, 'MS PGothic', 'Noto Sans JP', 'Noto Sans CJK JP', 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', sans-serif",

        // 한국어: 시스템 폰트 우선 + Google Fonts fallback + 이모지 폰트
        'ko': "'맑은 고딕', 'Malgun Gothic', 'Apple SD Gothic Neo', 'Noto Sans KR', 'Noto Sans CJK KR', 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', sans-serif",

        // 영어: 시스템 폰트 + 이모지 폰트
        'en': "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', sans-serif"
    };

    return fontStacks[lang] || fontStacks['ko'];
}

function applyTitle() {
    const titleOverlay = document.getElementById('video-title-overlay') || document.querySelector('.video-title-overlay');
    const text = document.getElementById('overlay-title-input').value.trim();
    const size = document.getElementById('overlay-title-size').value;
    const color = document.getElementById('overlay-title-color').value;
    const staticEffect = document.getElementById('overlay-title-static-effect')?.value || 'none';
    const dynamicEffect = document.getElementById('overlay-title-dynamic-effect')?.value || 'none';

    if (!titleOverlay) {
        console.error('❌ 제목 오버레이를 찾을 수 없습니다.');
        alert('⚠️ 영상을 먼저 불러와주세요.');
        return;
    }

    if (!text) {
        titleOverlay.textContent = '영상 제목을 입력하세요';
        titleOverlay.style.opacity = '0.5';
    } else {
        titleOverlay.textContent = text;
        titleOverlay.style.fontSize = `${size}px`;
        titleOverlay.style.color = color;
        titleOverlay.style.opacity = '1';
        titleOverlay.style.display = 'block';

        // 🌏 언어 자동 감지 및 최적 폰트 적용
        const detectedLang = detectLanguage(text);
        const optimalFont = getFontFamilyForLanguage(detectedLang);
        titleOverlay.style.fontFamily = optimalFont;
        titleOverlay.setAttribute('lang', detectedLang);
        console.log(`🌏 제목 언어 감지: ${detectedLang}, 폰트: ${optimalFont}`);

        // 정적 효과 적용
        titleOverlay.className = 'video-title-overlay video-text-overlay';
        if (staticEffect && staticEffect !== 'none') {
            titleOverlay.classList.add(`effect-${staticEffect}`);
        }

        // 동적 효과 적용
        if (dynamicEffect && dynamicEffect !== 'none') {
            titleOverlay.classList.add(`effect-${dynamicEffect}`);
        }
    }
    console.log(`✅ 제목 적용: ${text}`);

    // Canvas 오버레이 동기화
    syncOverlaysToCanvas();
}

// 부제목 적용
function applySubtitle() {
    const subtitleOverlay = document.getElementById('video-subtitle-overlay') || document.querySelector('.video-subtitle-overlay');
    const text = document.getElementById('overlay-subtitle-input').value.trim();
    const size = document.getElementById('overlay-subtitle-size').value;
    const color = document.getElementById('overlay-subtitle-color').value;
    const staticEffect = document.getElementById('overlay-subtitle-static-effect')?.value || 'none';
    const dynamicEffect = document.getElementById('overlay-subtitle-dynamic-effect')?.value || 'none';

    if (!subtitleOverlay) {
        console.error('❌ 부제목 오버레이를 찾을 수 없습니다.');
        alert('⚠️ 영상을 먼저 불러와주세요.');
        return;
    }

    if (!text) {
        subtitleOverlay.textContent = '부제목을 입력하세요';
        subtitleOverlay.style.opacity = '0.5';
    } else {
        subtitleOverlay.textContent = text;
        subtitleOverlay.style.fontSize = `${size}px`;
        subtitleOverlay.style.color = color;
        subtitleOverlay.style.opacity = '1';
        subtitleOverlay.style.display = 'block';

        // 🌏 언어 자동 감지 및 최적 폰트 적용
        const detectedLang = detectLanguage(text);
        const optimalFont = getFontFamilyForLanguage(detectedLang);
        subtitleOverlay.style.fontFamily = optimalFont;
        subtitleOverlay.setAttribute('lang', detectedLang);
        console.log(`🌏 부제목 언어 감지: ${detectedLang}, 폰트: ${optimalFont}`);

        // 정적 효과 적용
        subtitleOverlay.className = 'video-subtitle-overlay video-text-overlay';
        if (staticEffect && staticEffect !== 'none') {
            subtitleOverlay.classList.add(`effect-${staticEffect}`);
        }

        // 동적 효과 적용
        if (dynamicEffect && dynamicEffect !== 'none') {
            subtitleOverlay.classList.add(`effect-${dynamicEffect}`);
        }
    }
    console.log(`✅ 부제목 적용: ${text}`);

    // Canvas 오버레이 동기화
    syncOverlaysToCanvas();
}

// 출처 적용
function applySource() {
    const overlay = document.getElementById('source-overlay');
    const text = document.getElementById('overlay-source-input').value.trim();
    const size = document.getElementById('overlay-source-size').value;
    const color = document.getElementById('overlay-source-color').value;
    const x = document.getElementById('overlay-source-x').value;
    const y = document.getElementById('overlay-source-y').value;
    const staticEffect = document.getElementById('overlay-source-static-effect').value;
    const dynamicEffect = document.getElementById('overlay-source-dynamic-effect').value;

    if (!text) {
        overlay.textContent = '출처를 입력하세요';
        overlay.style.display = 'block';
        overlay.style.opacity = '0.5';
        overlay.style.fontSize = '18px';
        overlay.style.color = '#cccccc';
        overlay.classList.add('empty');
        return;
    }

    // 텍스트 적용
    overlay.textContent = text;
    overlay.style.fontSize = `${size}px`;
    overlay.style.color = color;
    overlay.style.display = 'block';
    overlay.style.opacity = '1';
    overlay.classList.remove('empty');

    // 위치 적용
    overlay.style.top = `${y}%`;
    overlay.style.left = `${x}%`;

    // 🌏 언어 자동 감지 및 최적 폰트 적용 (이모지 폰트 포함)
    const detectedLang = detectLanguage(text);
    const optimalFont = getFontFamilyForLanguage(detectedLang);
    overlay.style.fontFamily = optimalFont;

    // 효과 제거 후 재적용
    overlay.className = 'custom-subtitle-overlay';
    overlay.setAttribute('data-lang', detectedLang);

    // 정적 효과 적용
    if (staticEffect && staticEffect !== 'none') {
        overlay.classList.add(`effect-${staticEffect}`);
    }

    // 동적 효과 적용
    if (dynamicEffect && dynamicEffect !== 'none') {
        overlay.classList.add(`effect-${dynamicEffect}`);
    }

    console.log(`✅ 출처 적용: ${text}`);
}

// 빠른 자막 불러오기 비우기 함수
function clearQuickSubtitle() {
    if (confirm('🗑️ 불러온 자막을 비우시겠습니까?')) {
        // 파일 입력 초기화
        const fileInput = document.getElementById('quick-subtitle-file-input');
        if (fileInput) {
            fileInput.value = '';
        }

        // 표시된 파일명 초기화
        const fileNameSpan = document.getElementById('loaded-subtitle-files');
        if (fileNameSpan) {
            fileNameSpan.textContent = '';
        }

        console.log('🗑️ 빠른 자막 불러오기 비움');
        alert('✅ 불러온 자막이 비워졌습니다.');
    }
}

// 타임라인 자막을 화면 오버레이에 표시하는 함수
function updateSubtitleOverlaysFromTimeline(currentTime) {
    // 체크박스 상태 확인
    const mainEnabled = document.getElementById('track-main-subtitle-enable')?.checked;
    const translationEnabled = document.getElementById('track-translation-subtitle-enable')?.checked;
    const descriptionEnabled = document.getElementById('track-description-subtitle-enable')?.checked;

    // 메인 자막 오버레이 업데이트 (main - 일본어)
    const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
    const japaneseInput = document.getElementById('overlay-japanese-input');

    if (japaneseOverlay) {
        let subtitleChanged = false;
        // 타임라인 트랙이 활성화되어 있고 자막 데이터가 있는 경우
        if (mainEnabled && loadedSubtitles.main && loadedSubtitles.main.length > 0) {
            const currentSubtitle = findSubtitleAtTime(loadedSubtitles.main, currentTime);
            if (currentSubtitle) {
                // 자막 내용이 바뀐 경우에만 업데이트
                if (japaneseOverlay.textContent !== currentSubtitle.text) {
                    japaneseOverlay.textContent = currentSubtitle.text;
                    subtitleChanged = true;
                }

                // 컨트롤에서 설정된 스타일 적용
                const size = document.getElementById('overlay-japanese-size')?.value || '30';
                const color = document.getElementById('overlay-japanese-color')?.value || '#000000';
                const x = document.getElementById('overlay-japanese-x')?.value || '50';
                const y = document.getElementById('overlay-japanese-y')?.value || '73';
                const staticEffect = document.getElementById('overlay-japanese-static-effect')?.value || 'outline';
                const dynamicEffect = document.getElementById('overlay-japanese-dynamic-effect')?.value || 'none';

                japaneseOverlay.style.display = 'block';
                japaneseOverlay.style.opacity = '1';
                japaneseOverlay.style.fontSize = size + 'px';
                japaneseOverlay.style.color = color;
                japaneseOverlay.style.left = x + '%';
                japaneseOverlay.style.top = y + '%';
                japaneseOverlay.classList.remove('empty');

                // 일본어 폰트 최적화
                const optimalFont = getFontFamilyForLanguage('ja');
                japaneseOverlay.style.fontFamily = optimalFont;

                // 효과 제거 후 재적용
                japaneseOverlay.className = 'custom-subtitle-overlay';
                japaneseOverlay.setAttribute('data-lang', 'japanese');
                japaneseOverlay.setAttribute('lang', 'ja');

                // 정적 효과 적용
                if (staticEffect && staticEffect !== 'none') {
                    japaneseOverlay.classList.add(`effect-${staticEffect}`);
                }

                // 동적 효과 적용
                if (dynamicEffect && dynamicEffect !== 'none') {
                    japaneseOverlay.classList.add(`effect-${dynamicEffect}`);
                }
            } else {
                // 현재 시간에 자막이 없으면 숨김
                if (japaneseOverlay.textContent !== '') {
                    subtitleChanged = true;
                }
                japaneseOverlay.textContent = '';
                japaneseOverlay.style.display = 'none';
                japaneseOverlay.classList.add('empty');
            }
        } else if (!mainEnabled) {
            // 타임라인 트랙이 비활성화된 경우 - 수동 입력된 텍스트가 있다면 유지, 없으면 숨김
            if (!japaneseInput || !japaneseInput.value.trim()) {
                if (japaneseOverlay.textContent !== '') {
                    subtitleChanged = true;
                }
                japaneseOverlay.textContent = '';
                japaneseOverlay.style.display = 'none';
                japaneseOverlay.classList.add('empty');
            }
            // 수동 입력 텍스트가 있으면 그대로 유지 (applyJapaneseSubtitle로 설정된 상태)
        }

        // Canvas 동기화 (자막이 변경된 경우에만)
        if (subtitleChanged && typeof updateCanvasText === 'function') {
            updateCanvasText();
        }
    }

    // 주자막 오버레이 업데이트 (translation)
    const koreanOverlay = document.getElementById('korean-subtitle-overlay');
    const koreanInput = document.getElementById('overlay-korean-input');

    if (koreanOverlay) {
        let subtitleChanged = false;
        // 타임라인 트랙이 활성화되어 있고 자막 데이터가 있는 경우
        if (translationEnabled && loadedSubtitles.translation && loadedSubtitles.translation.length > 0) {
            const currentSubtitle = findSubtitleAtTime(loadedSubtitles.translation, currentTime);
            if (currentSubtitle) {
                // 자막 내용이 바뀐 경우에만 업데이트
                if (koreanOverlay.textContent !== currentSubtitle.text) {
                    koreanOverlay.textContent = currentSubtitle.text;
                    subtitleChanged = true;
                }

                // 컨트롤에서 설정된 스타일 적용
                const size = document.getElementById('overlay-korean-size')?.value || '32';
                const color = document.getElementById('overlay-korean-color')?.value || '#ffffff';
                const x = document.getElementById('overlay-korean-x')?.value || '50';
                const y = document.getElementById('overlay-korean-y')?.value || '65';
                const staticEffect = document.getElementById('overlay-korean-static-effect')?.value || 'outline';
                const dynamicEffect = document.getElementById('overlay-korean-dynamic-effect')?.value || 'none';

                koreanOverlay.style.display = 'block';
                koreanOverlay.style.opacity = '1';
                koreanOverlay.style.fontSize = size + 'px';
                koreanOverlay.style.color = color;
                koreanOverlay.style.left = x + '%';
                koreanOverlay.style.top = y + '%';
                koreanOverlay.classList.remove('empty');

                // 언어 감지 및 폰트 적용
                const detectedLang = detectLanguage(currentSubtitle.text);
                const optimalFont = getFontFamilyForLanguage(detectedLang);
                koreanOverlay.style.fontFamily = optimalFont;

                // 효과 제거 후 재적용
                koreanOverlay.className = 'custom-subtitle-overlay';
                koreanOverlay.setAttribute('data-lang', detectedLang);
                koreanOverlay.setAttribute('lang', detectedLang);

                // 정적 효과 적용
                if (staticEffect && staticEffect !== 'none') {
                    koreanOverlay.classList.add(`effect-${staticEffect}`);
                }

                // 동적 효과 적용
                if (dynamicEffect && dynamicEffect !== 'none') {
                    koreanOverlay.classList.add(`effect-${dynamicEffect}`);
                }
            } else {
                // 현재 시간에 자막이 없으면 숨김
                if (koreanOverlay.textContent !== '') {
                    subtitleChanged = true;
                }
                koreanOverlay.textContent = '';
                koreanOverlay.style.display = 'none';
                koreanOverlay.classList.add('empty');
            }
        } else if (!translationEnabled) {
            // 타임라인 트랙이 비활성화된 경우 - 수동 입력된 텍스트가 있다면 유지, 없으면 숨김
            if (!koreanInput || !koreanInput.value.trim()) {
                if (koreanOverlay.textContent !== '') {
                    subtitleChanged = true;
                }
                koreanOverlay.textContent = '';
                koreanOverlay.style.display = 'none';
                koreanOverlay.classList.add('empty');
            }
            // 수동 입력 텍스트가 있으면 그대로 유지 (applyKoreanSubtitle로 설정된 상태)
        }

        // Canvas 동기화 (자막이 변경된 경우에만)
        if (subtitleChanged && typeof updateCanvasText === 'function') {
            updateCanvasText();
        }
    }

    // 보조자막 오버레이 업데이트 (description)
    const englishOverlay = document.getElementById('english-subtitle-overlay');
    const englishInput = document.getElementById('overlay-english-input');

    if (englishOverlay) {
        let subtitleChanged = false;
        // 타임라인 트랙이 활성화되어 있고 자막 데이터가 있는 경우
        if (descriptionEnabled && loadedSubtitles.description && loadedSubtitles.description.length > 0) {
            const currentSubtitle = findSubtitleAtTime(loadedSubtitles.description, currentTime);
            if (currentSubtitle) {
                // 자막 내용이 바뀐 경우에만 업데이트
                if (englishOverlay.textContent !== currentSubtitle.text) {
                    englishOverlay.textContent = currentSubtitle.text;
                    subtitleChanged = true;
                }

                // 컨트롤에서 설정된 스타일 적용
                const size = document.getElementById('overlay-english-size')?.value || '28';
                const color = document.getElementById('overlay-english-color')?.value || '#ffe14d';
                const x = document.getElementById('overlay-english-x')?.value || '50';
                const y = document.getElementById('overlay-english-y')?.value || '95';
                const staticEffect = document.getElementById('overlay-english-static-effect')?.value || 'outline';
                const dynamicEffect = document.getElementById('overlay-english-dynamic-effect')?.value || 'none';

                englishOverlay.style.display = 'block';
                englishOverlay.style.opacity = '1';
                englishOverlay.style.fontSize = size + 'px';
                englishOverlay.style.color = color;
                englishOverlay.style.left = x + '%';
                englishOverlay.style.top = y + '%';
                englishOverlay.classList.remove('empty');

                // 언어 감지 및 폰트 적용
                const detectedLang = detectLanguage(currentSubtitle.text);
                const optimalFont = getFontFamilyForLanguage(detectedLang);
                englishOverlay.style.fontFamily = optimalFont;

                // 효과 제거 후 재적용
                englishOverlay.className = 'custom-subtitle-overlay';
                englishOverlay.setAttribute('data-lang', detectedLang);
                englishOverlay.setAttribute('lang', detectedLang);

                // 정적 효과 적용
                if (staticEffect && staticEffect !== 'none') {
                    englishOverlay.classList.add(`effect-${staticEffect}`);
                }

                // 동적 효과 적용
                if (dynamicEffect && dynamicEffect !== 'none') {
                    englishOverlay.classList.add(`effect-${dynamicEffect}`);
                }
            } else {
                // 현재 시간에 자막이 없으면 숨김
                if (englishOverlay.textContent !== '') {
                    subtitleChanged = true;
                }
                englishOverlay.textContent = '';
                englishOverlay.style.display = 'none';
                englishOverlay.classList.add('empty');
            }
        } else if (!descriptionEnabled) {
            // 타임라인 트랙이 비활성화된 경우 - 수동 입력된 텍스트가 있다면 유지, 없으면 숨김
            if (!englishInput || !englishInput.value.trim()) {
                if (englishOverlay.textContent !== '') {
                    subtitleChanged = true;
                }
                englishOverlay.textContent = '';
                englishOverlay.style.display = 'none';
                englishOverlay.classList.add('empty');
            }
            // 수동 입력 텍스트가 있으면 그대로 유지 (applyEnglishSubtitle로 설정된 상태)
        }

        // Canvas 동기화 (자막이 변경된 경우에만)
        if (subtitleChanged && typeof updateCanvasText === 'function') {
            updateCanvasText();
        }
    }
}

// 특정 시간에 해당하는 자막 찾기
function findSubtitleAtTime(subtitles, currentTime) {
    if (!subtitles || subtitles.length === 0) return null;

    for (const subtitle of subtitles) {
        const startSeconds = srtTimeToSeconds(subtitle.start);
        const endSeconds = srtTimeToSeconds(subtitle.end);

        if (currentTime >= startSeconds && currentTime <= endSeconds) {
            return subtitle;
        }
    }

    return null;
}

// 자막 드래그 기능 초기화
function initSubtitleDragging() {
    const koreanOverlay = document.getElementById('korean-subtitle-overlay');
    const englishOverlay = document.getElementById('english-subtitle-overlay');
    const sourceOverlay = document.getElementById('source-overlay');

    if (koreanOverlay) {
        makeSubtitleDraggable(koreanOverlay, 'korean');
    }
    if (englishOverlay) {
        makeSubtitleDraggable(englishOverlay, 'english');
    }
    if (sourceOverlay) {
        makeSubtitleDraggable(sourceOverlay, 'source');
    }
}

// 자막 드래그 가능하게 만들기
function makeSubtitleDraggable(element, lang) {
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;

    // mousedown 이벤트 핸들러
    const handleMouseDown = (e) => {
        if (element.classList.contains('empty') || element.style.display === 'none') return;

        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;

        const rect = element.getBoundingClientRect();
        const wrapper = element.closest('.video-subtitle-wrapper');
        const wrapperRect = wrapper.getBoundingClientRect();

        startLeft = rect.left - wrapperRect.left;
        startTop = rect.top - wrapperRect.top;

        element.style.cursor = 'grabbing';
        e.preventDefault();
    };

    // mousemove 이벤트 핸들러
    const handleMouseMove = (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        const wrapper = element.closest('.video-subtitle-wrapper');
        const wrapperRect = wrapper.getBoundingClientRect();
        const newLeft = startLeft + deltaX;
        const newTop = startTop + deltaY;

        // 퍼센트로 변환
        const leftPercent = (newLeft / wrapperRect.width) * 100;
        const topPercent = (newTop / wrapperRect.height) * 100;

        // 범위 제한
        const clampedLeft = Math.max(0, Math.min(100, leftPercent));
        const clampedTop = Math.max(0, Math.min(100, topPercent));

        element.style.left = clampedLeft + '%';
        element.style.top = clampedTop + '%';

        // 입력 필드 업데이트
        const xInput = document.getElementById(`overlay-${lang}-x`);
        const yInput = document.getElementById(`overlay-${lang}-y`);
        if (xInput) xInput.value = Math.round(clampedLeft);
        if (yInput) yInput.value = Math.round(clampedTop);

        e.preventDefault();
    };

    // mouseup 이벤트 핸들러
    const handleMouseUp = () => {
        if (isDragging) {
            isDragging = false;
            element.style.cursor = 'move';
        }
    };

    // 이벤트 리스너 등록
    element.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
}

// 텍스트 오버레이 설정 저장 (기존 함수에 자막 추가)
function saveTextOverlaySettingsWithSubtitles() {
    const settings = {
        title: {
            text: document.getElementById('overlay-title-input').value,
            size: document.getElementById('overlay-title-size').value,
            color: document.getElementById('overlay-title-color').value,
            staticEffect: document.getElementById('overlay-title-static-effect').value,
            dynamicEffect: document.getElementById('overlay-title-dynamic-effect').value,
            position: document.getElementById('video-title-overlay').style.transform
        },
        subtitle: {
            text: document.getElementById('overlay-subtitle-input').value,
            size: document.getElementById('overlay-subtitle-size').value,
            color: document.getElementById('overlay-subtitle-color').value,
            staticEffect: document.getElementById('overlay-subtitle-static-effect').value,
            dynamicEffect: document.getElementById('overlay-subtitle-dynamic-effect').value,
            position: document.getElementById('video-subtitle-overlay').style.transform
        },
        korean: {
            text: document.getElementById('overlay-korean-input').value,
            size: document.getElementById('overlay-korean-size').value,
            color: document.getElementById('overlay-korean-color').value,
            x: document.getElementById('overlay-korean-x').value,
            y: document.getElementById('overlay-korean-y').value,
            staticEffect: document.getElementById('overlay-korean-static-effect').value,
            dynamicEffect: document.getElementById('overlay-korean-dynamic-effect').value
        },
        japanese: {
            text: document.getElementById('overlay-japanese-input').value,
            size: document.getElementById('overlay-japanese-size').value,
            color: document.getElementById('overlay-japanese-color').value,
            x: document.getElementById('overlay-japanese-x').value,
            y: document.getElementById('overlay-japanese-y').value,
            staticEffect: document.getElementById('overlay-japanese-static-effect').value,
            dynamicEffect: document.getElementById('overlay-japanese-dynamic-effect').value
        },
        english: {
            text: document.getElementById('overlay-english-input').value,
            size: document.getElementById('overlay-english-size').value,
            color: document.getElementById('overlay-english-color').value,
            x: document.getElementById('overlay-english-x').value,
            y: document.getElementById('overlay-english-y').value,
            staticEffect: document.getElementById('overlay-english-static-effect').value,
            dynamicEffect: document.getElementById('overlay-english-dynamic-effect').value
        },
        blackBars: {
            top: {
                enabled: document.getElementById('top-bar-enable').checked,
                height: document.getElementById('top-bar-height').value,
                opacity: document.getElementById('top-bar-opacity').value
            },
            bottom: {
                enabled: document.getElementById('bottom-bar-enable').checked,
                height: document.getElementById('bottom-bar-height').value,
                opacity: document.getElementById('bottom-bar-opacity').value
            }
        }
    };

    try {
        // 저장 시간 추가
        settings.savedAt = new Date().toISOString();
        settings.name = '기본 설정';

        localStorage.setItem('videoAnalyzerTextOverlay', JSON.stringify(settings));
        updateSettingsStatus('기본 설정', new Date());
        alert('✅ 텍스트 오버레이 및 검정 배경 설정이 저장되었습니다!');
        console.log('💾 설정 저장됨:', settings);
    } catch (e) {
        console.error('❌ 설정 저장 실패:', e);
        alert('❌ 설정 저장에 실패했습니다.');
    }
}

// 다른 이름으로 저장
function saveTextOverlaySettingsAs() {
    const name = prompt('설정 이름을 입력하세요:', `설정_${new Date().toLocaleDateString()}`);
    if (!name) return;

    // 현재 설정 수집 (기존 함수와 동일)
    const settings = {
        name: name,
        savedAt: new Date().toISOString(),
        title: {
            text: document.getElementById('overlay-title-input').value,
            size: document.getElementById('overlay-title-size').value,
            color: document.getElementById('overlay-title-color').value,
            staticEffect: document.getElementById('overlay-title-static-effect').value,
            dynamicEffect: document.getElementById('overlay-title-dynamic-effect').value,
            position: document.getElementById('video-title-overlay')?.style.transform || ''
        },
        subtitle: {
            text: document.getElementById('overlay-subtitle-input').value,
            size: document.getElementById('overlay-subtitle-size').value,
            color: document.getElementById('overlay-subtitle-color').value,
            staticEffect: document.getElementById('overlay-subtitle-static-effect').value,
            dynamicEffect: document.getElementById('overlay-subtitle-dynamic-effect').value,
            position: document.getElementById('video-subtitle-overlay')?.style.transform || ''
        },
        source: {
            text: document.getElementById('overlay-source-input').value,
            size: document.getElementById('overlay-source-size').value,
            color: document.getElementById('overlay-source-color').value,
            x: document.getElementById('overlay-source-x').value,
            y: document.getElementById('overlay-source-y').value,
            staticEffect: document.getElementById('overlay-source-static-effect').value,
            dynamicEffect: document.getElementById('overlay-source-dynamic-effect').value,
            hide: document.getElementById('source-overlay-hide').checked
        },
        korean: {
            text: document.getElementById('overlay-korean-input').value,
            size: document.getElementById('overlay-korean-size').value,
            color: document.getElementById('overlay-korean-color').value,
            x: document.getElementById('overlay-korean-x').value,
            y: document.getElementById('overlay-korean-y').value,
            staticEffect: document.getElementById('overlay-korean-static-effect').value,
            dynamicEffect: document.getElementById('overlay-korean-dynamic-effect').value
        },
        japanese: {
            text: document.getElementById('overlay-japanese-input').value,
            size: document.getElementById('overlay-japanese-size').value,
            color: document.getElementById('overlay-japanese-color').value,
            x: document.getElementById('overlay-japanese-x').value,
            y: document.getElementById('overlay-japanese-y').value,
            staticEffect: document.getElementById('overlay-japanese-static-effect').value,
            dynamicEffect: document.getElementById('overlay-japanese-dynamic-effect').value
        },
        english: {
            text: document.getElementById('overlay-english-input').value,
            size: document.getElementById('overlay-english-size').value,
            color: document.getElementById('overlay-english-color').value,
            x: document.getElementById('overlay-english-x').value,
            y: document.getElementById('overlay-english-y').value,
            staticEffect: document.getElementById('overlay-english-static-effect').value,
            dynamicEffect: document.getElementById('overlay-english-dynamic-effect').value
        },
        blackBars: {
            top: {
                enabled: document.getElementById('top-bar-enable').checked,
                height: document.getElementById('top-bar-height').value,
                opacity: document.getElementById('top-bar-opacity').value  // 0-100 범위로 저장
            },
            bottom: {
                enabled: document.getElementById('bottom-bar-enable').checked,
                height: document.getElementById('bottom-bar-height').value,
                opacity: document.getElementById('bottom-bar-opacity').value  // 0-100 범위로 저장
            }
        },
        // Canvas 자막 위치 정보 저장
        canvasSubtitlePositions: canvasPreview ? {
            main: canvasPreview.subtitleStyles.main.yPosition,
            translation: canvasPreview.subtitleStyles.translation.yPosition,
            description: canvasPreview.subtitleStyles.description.yPosition
        } : null,
        // Canvas 오버레이 위치 정보 저장 (title, subtitle)
        canvasOverlayPositions: canvasPreview && canvasPreview.overlays ?
            canvasPreview.overlays.map(overlay => ({
                type: overlay.type,
                text: overlay.text,
                x: overlay.x,
                y: overlay.y,
                fontSize: overlay.fontSize,
                color: overlay.color,
                borderWidth: overlay.borderWidth,
                borderColor: overlay.borderColor
            })) : null
    };

    try {
        // 모든 설정 목록 가져오기
        const allSettings = JSON.parse(localStorage.getItem('videoAnalyzerAllSettings') || '{}');
        allSettings[name] = settings;
        localStorage.setItem('videoAnalyzerAllSettings', JSON.stringify(allSettings));

        updateSettingsStatus(name, new Date());
        alert(`✅ "${name}" 설정이 저장되었습니다!`);
        console.log('💾 설정 저장됨:', settings);
    } catch (e) {
        console.error('❌ 설정 저장 실패:', e);
        alert('❌ 설정 저장에 실패했습니다.');
    }
}

// 설정 불러오기 (개선된 버전)
function loadTextOverlaySettings() {
    try {
        // 저장된 모든 설정 목록 가져오기
        const allSettings = JSON.parse(localStorage.getItem('videoAnalyzerAllSettings') || '{}');
        const settingsList = Object.keys(allSettings);

        if (settingsList.length === 0) {
            // 기본 설정만 있는 경우
            const saved = localStorage.getItem('videoAnalyzerTextOverlay');
            if (!saved) {
                alert('⚠️ 저장된 설정이 없습니다.');
                return;
            }
            const settings = JSON.parse(saved);
            applySettings(settings);
            updateSettingsStatus(settings.name || '기본 설정', settings.savedAt ? new Date(settings.savedAt) : null);
            return;
        }

        // 설정 선택 다이얼로그
        let message = '불러올 설정을 선택하세요:\n\n';
        settingsList.forEach((name, index) => {
            const setting = allSettings[name];
            const date = setting.savedAt ? new Date(setting.savedAt).toLocaleString() : '알 수 없음';
            message += `${index + 1}. ${name} (${date})\n`;
        });
        message += '\n번호를 입력하세요:';

        const choice = prompt(message);
        if (!choice) return;

        const index = parseInt(choice) - 1;
        if (index < 0 || index >= settingsList.length) {
            alert('❌ 잘못된 번호입니다.');
            return;
        }

        const selectedName = settingsList[index];
        const settings = allSettings[selectedName];
        applySettings(settings);
        updateSettingsStatus(selectedName, settings.savedAt ? new Date(settings.savedAt) : null);
        alert(`✅ "${selectedName}" 설정을 불러왔습니다!`);

    } catch (e) {
        console.error('❌ 설정 불러오기 실패:', e);
        console.error('에러 상세:', e.message, e.stack);
        alert(`❌ 설정 불러오기에 실패했습니다.\n에러: ${e.message}\n\n브라우저 콘솔(F12)을 확인하세요.`);
    }
}

// 파일에서 설정 불러오기
function browseSettingsFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const settings = JSON.parse(event.target.result);
                applySettings(settings);
                updateSettingsStatus(settings.name || file.name, settings.savedAt ? new Date(settings.savedAt) : null);
                alert(`✅ "${file.name}" 파일에서 설정을 불러왔습니다!`);
            } catch (e) {
                console.error('❌ 파일 읽기 실패:', e);
                alert('❌ 유효하지 않은 설정 파일입니다.');
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

// 설정 적용 헬퍼 함수
function applySettings(settings) {
    // 제목 설정 적용
    if (settings.title) {
        document.getElementById('overlay-title-input').value = settings.title.text || '';
        document.getElementById('overlay-title-size').value = settings.title.size || 48;
        document.getElementById('overlay-title-color').value = settings.title.color || '#ffffff';
        if (settings.title.staticEffect) document.getElementById('overlay-title-static-effect').value = settings.title.staticEffect;
        if (settings.title.dynamicEffect) document.getElementById('overlay-title-dynamic-effect').value = settings.title.dynamicEffect;

        // 크기 표시 업데이트
        const titleSizeDisplay = document.getElementById('title-size-display');
        if (titleSizeDisplay) titleSizeDisplay.textContent = (settings.title.size || 48) + 'px';

        // 실제 오버레이에 적용
        const titleOverlay = document.getElementById('video-title-overlay');
        if (titleOverlay) {
            if (settings.title.text) {
                try {
                    applyTitle();
                } catch (err) {
                    console.warn('제목 적용 실패 (영상이 로드되지 않았을 수 있음):', err);
                }
            }
            // 위치 복원
            if (settings.title.position) {
                titleOverlay.style.transform = settings.title.position;
            }
        }
    }

    // 부제목 설정 적용
    if (settings.subtitle) {
        document.getElementById('overlay-subtitle-input').value = settings.subtitle.text || '';
        document.getElementById('overlay-subtitle-size').value = settings.subtitle.size || 32;
        document.getElementById('overlay-subtitle-color').value = settings.subtitle.color || '#ffe14d';
        if (settings.subtitle.staticEffect) document.getElementById('overlay-subtitle-static-effect').value = settings.subtitle.staticEffect;
        if (settings.subtitle.dynamicEffect) document.getElementById('overlay-subtitle-dynamic-effect').value = settings.subtitle.dynamicEffect;

        // 크기 표시 업데이트
        const subtitleSizeDisplay = document.getElementById('subtitle-size-display');
        if (subtitleSizeDisplay) subtitleSizeDisplay.textContent = (settings.subtitle.size || 32) + 'px';

        // 실제 오버레이에 적용
        const subtitleOverlay = document.getElementById('video-subtitle-overlay');
        if (subtitleOverlay) {
            if (settings.subtitle.text) {
                try {
                    applySubtitle();
                } catch (err) {
                    console.warn('부제목 적용 실패 (영상이 로드되지 않았을 수 있음):', err);
                }
            }
            // 위치 복원
            if (settings.subtitle.position) {
                subtitleOverlay.style.transform = settings.subtitle.position;
            }
        }
    }

    // 출처 설정 적용
    if (settings.source) {
        if (document.getElementById('overlay-source-input')) document.getElementById('overlay-source-input').value = settings.source.text || '';
        if (document.getElementById('overlay-source-size')) document.getElementById('overlay-source-size').value = settings.source.size || 16;
        if (document.getElementById('overlay-source-color')) document.getElementById('overlay-source-color').value = settings.source.color || '#ffffff';
        if (document.getElementById('overlay-source-x')) document.getElementById('overlay-source-x').value = settings.source.x || 10;
        if (document.getElementById('overlay-source-y')) document.getElementById('overlay-source-y').value = settings.source.y || 10;
        // 하위 호환성
        if (settings.source.staticEffect !== undefined && document.getElementById('overlay-source-static-effect')) {
            document.getElementById('overlay-source-static-effect').value = settings.source.staticEffect || 'none';
        } else if (settings.source.effect && document.getElementById('overlay-source-static-effect')) {
            document.getElementById('overlay-source-static-effect').value = settings.source.effect || 'none';
        }
        if (settings.source.dynamicEffect !== undefined && document.getElementById('overlay-source-dynamic-effect')) {
            document.getElementById('overlay-source-dynamic-effect').value = settings.source.dynamicEffect || 'none';
        }
        if (document.getElementById('source-overlay-hide')) document.getElementById('source-overlay-hide').checked = settings.source.hide || false;
    }

    // 한글 자막 설정 적용
    if (settings.korean) {
        if (document.getElementById('overlay-korean-input')) document.getElementById('overlay-korean-input').value = settings.korean.text || '';
        if (document.getElementById('overlay-korean-size')) document.getElementById('overlay-korean-size').value = settings.korean.size || 24;
        if (document.getElementById('overlay-korean-color')) document.getElementById('overlay-korean-color').value = settings.korean.color || '#ffffff';
        if (document.getElementById('overlay-korean-x')) document.getElementById('overlay-korean-x').value = settings.korean.x || 50;
        if (document.getElementById('overlay-korean-y')) document.getElementById('overlay-korean-y').value = settings.korean.y || 80;
        // 하위 호환성
        if (settings.korean.staticEffect !== undefined && document.getElementById('overlay-korean-static-effect')) {
            document.getElementById('overlay-korean-static-effect').value = settings.korean.staticEffect || 'none';
        } else if (settings.korean.effect && document.getElementById('overlay-korean-static-effect')) {
            document.getElementById('overlay-korean-static-effect').value = settings.korean.effect || 'none';
        }
        if (settings.korean.dynamicEffect !== undefined && document.getElementById('overlay-korean-dynamic-effect')) {
            document.getElementById('overlay-korean-dynamic-effect').value = settings.korean.dynamicEffect || 'none';
        }
    }

    // 일본어 자막 설정 적용
    if (settings.japanese) {
        if (document.getElementById('overlay-japanese-input')) document.getElementById('overlay-japanese-input').value = settings.japanese.text || '';
        if (document.getElementById('overlay-japanese-size')) document.getElementById('overlay-japanese-size').value = settings.japanese.size || 30;
        if (document.getElementById('overlay-japanese-color')) document.getElementById('overlay-japanese-color').value = settings.japanese.color || '#000000';
        if (document.getElementById('overlay-japanese-x')) document.getElementById('overlay-japanese-x').value = settings.japanese.x || 50;
        if (document.getElementById('overlay-japanese-y')) document.getElementById('overlay-japanese-y').value = settings.japanese.y || 83;
        // 하위 호환성
        if (settings.japanese.staticEffect !== undefined && document.getElementById('overlay-japanese-static-effect')) {
            document.getElementById('overlay-japanese-static-effect').value = settings.japanese.staticEffect || 'outline';
        } else if (settings.japanese.effect && document.getElementById('overlay-japanese-static-effect')) {
            document.getElementById('overlay-japanese-static-effect').value = settings.japanese.effect || 'outline';
        }
        if (settings.japanese.dynamicEffect !== undefined && document.getElementById('overlay-japanese-dynamic-effect')) {
            document.getElementById('overlay-japanese-dynamic-effect').value = settings.japanese.dynamicEffect || 'none';
        }
    }

    // 영어 자막 설정 적용
    if (settings.english) {
        if (document.getElementById('overlay-english-input')) document.getElementById('overlay-english-input').value = settings.english.text || '';
        if (document.getElementById('overlay-english-size')) document.getElementById('overlay-english-size').value = settings.english.size || 20;
        if (document.getElementById('overlay-english-color')) document.getElementById('overlay-english-color').value = settings.english.color || '#ffe14d';
        if (document.getElementById('overlay-english-x')) document.getElementById('overlay-english-x').value = settings.english.x || 50;
        if (document.getElementById('overlay-english-y')) document.getElementById('overlay-english-y').value = settings.english.y || 90;
        // 하위 호환성
        if (settings.english.staticEffect !== undefined && document.getElementById('overlay-english-static-effect')) {
            document.getElementById('overlay-english-static-effect').value = settings.english.staticEffect || 'none';
        } else if (settings.english.effect && document.getElementById('overlay-english-static-effect')) {
            document.getElementById('overlay-english-static-effect').value = settings.english.effect || 'none';
        }
        if (settings.english.dynamicEffect !== undefined && document.getElementById('overlay-english-dynamic-effect')) {
            document.getElementById('overlay-english-dynamic-effect').value = settings.english.dynamicEffect || 'none';
        }
    }

    // Canvas 자막 위치 복원
    if (settings.canvasSubtitlePositions && canvasPreview) {
        console.log('📍 Canvas 자막 위치 복원:', settings.canvasSubtitlePositions);
        if (settings.canvasSubtitlePositions.main !== undefined) {
            canvasPreview.updateSubtitlePosition('main', settings.canvasSubtitlePositions.main);
        }
        if (settings.canvasSubtitlePositions.translation !== undefined) {
            canvasPreview.updateSubtitlePosition('translation', settings.canvasSubtitlePositions.translation);
        }
        if (settings.canvasSubtitlePositions.description !== undefined) {
            canvasPreview.updateSubtitlePosition('description', settings.canvasSubtitlePositions.description);
        }
    }

    // Canvas 오버레이 위치 복원 (title, subtitle)
    if (settings.canvasOverlayPositions && canvasPreview) {
        console.log('📍 Canvas 오버레이 위치 복원:', settings.canvasOverlayPositions);
        canvasPreview.clearOverlays();
        settings.canvasOverlayPositions.forEach(overlay => {
            canvasPreview.addOverlay({
                type: overlay.type,
                text: overlay.text,
                x: overlay.x,
                y: overlay.y,
                fontSize: overlay.fontSize,
                color: overlay.color,
                borderWidth: overlay.borderWidth,
                borderColor: overlay.borderColor
            });
        });
    }

    // 검정 배경 설정 적용
    if (settings.blackBars) {
        // 상단 검정 바
        if (settings.blackBars.top) {
            const topEnable = document.getElementById('top-bar-enable');
            const topHeight = document.getElementById('top-bar-height');
            const topOpacity = document.getElementById('top-bar-opacity');

            if (topEnable) topEnable.checked = settings.blackBars.top.enabled || false;
            if (topHeight) topHeight.value = settings.blackBars.top.height || 15;
            // opacity는 0-100 범위로 저장되므로 그대로 사용
            if (topOpacity) topOpacity.value = settings.blackBars.top.opacity || 80;

            // 표시 업데이트
            const topHeightDisplay = document.getElementById('top-bar-height-display');
            const topOpacityDisplay = document.getElementById('top-bar-opacity-display');
            if (topHeightDisplay) topHeightDisplay.textContent = (settings.blackBars.top.height || 15) + '%';
            if (topOpacityDisplay) topOpacityDisplay.textContent = (settings.blackBars.top.opacity || 80) + '%';
        }

        // 하단 검정 바
        if (settings.blackBars.bottom) {
            const bottomEnable = document.getElementById('bottom-bar-enable');
            const bottomHeight = document.getElementById('bottom-bar-height');
            const bottomOpacity = document.getElementById('bottom-bar-opacity');

            if (bottomEnable) bottomEnable.checked = settings.blackBars.bottom.enabled || false;
            if (bottomHeight) bottomHeight.value = settings.blackBars.bottom.height || 15;
            // opacity는 0-100 범위로 저장되므로 그대로 사용
            if (bottomOpacity) bottomOpacity.value = settings.blackBars.bottom.opacity || 80;

            // 표시 업데이트
            const bottomHeightDisplay = document.getElementById('bottom-bar-height-display');
            const bottomOpacityDisplay = document.getElementById('bottom-bar-opacity-display');
            if (bottomHeightDisplay) bottomHeightDisplay.textContent = (settings.blackBars.bottom.height || 15) + '%';
            if (bottomOpacityDisplay) bottomOpacityDisplay.textContent = (settings.blackBars.bottom.opacity || 80) + '%';
        }

        // 검정 배경 실제 적용
        if (settings.blackBars.top) {
            const topBar = document.getElementById('top-black-bar');
            const topCheckbox = document.getElementById('top-bar-enable');
            if (topBar && topCheckbox) {
                if (topCheckbox.checked) {
                    topBar.style.display = 'block';
                    updateBlackBar('top');
                } else {
                    topBar.style.display = 'none';
                }
            }
        }
        if (settings.blackBars.bottom) {
            const bottomBar = document.getElementById('bottom-black-bar');
            const bottomCheckbox = document.getElementById('bottom-bar-enable');
            if (bottomBar && bottomCheckbox) {
                if (bottomCheckbox.checked) {
                    bottomBar.style.display = 'block';
                    updateBlackBar('bottom');
                } else {
                    bottomBar.style.display = 'none';
                }
            }
        }
    }

    console.log('✅ 설정이 적용되었습니다:', settings);
}

// 현재 설정 상태 업데이트
function updateSettingsStatus(name, savedAt) {
    const nameEl = document.getElementById('saved-settings-name');
    const timeEl = document.getElementById('saved-settings-time');

    if (nameEl) nameEl.textContent = name || '기본 설정';
    if (timeEl && savedAt) {
        const date = new Date(savedAt);
        timeEl.textContent = `저장 시간: ${date.toLocaleString()}`;
    } else if (timeEl) {
        timeEl.textContent = '미저장';
    }
}

// 기존 저장 함수를 새 함수로 대체
saveTextOverlaySettings = saveTextOverlaySettingsWithSubtitles;

// 이벤트 리스너 등록 (DOMContentLoaded에 추가)
document.addEventListener('DOMContentLoaded', function() {
    // 기존 DOMContentLoaded 코드는 유지하고, 여기에 추가

    // 텍스트 오버레이 드래그 가능하게 설정
    const titleOverlay = document.getElementById('video-title-overlay');
    const subtitleOverlay = document.getElementById('video-subtitle-overlay');

    if (titleOverlay) makeOverlayDraggable(titleOverlay);
    if (subtitleOverlay) makeOverlayDraggable(subtitleOverlay);

    // 제목 입력 이벤트
    const titleInput = document.getElementById('overlay-title-input');
    if (titleInput) {
        titleInput.addEventListener('input', updateTextOverlays);
    }

    // 제목 크기 슬라이더
    const titleSize = document.getElementById('overlay-title-size');
    if (titleSize) {
        titleSize.addEventListener('input', function() {
            document.getElementById('title-size-display').textContent = this.value + 'px';
            updateTextOverlays();
        });
    }

    // 제목 색상
    const titleColor = document.getElementById('overlay-title-color');
    if (titleColor) {
        titleColor.addEventListener('input', updateTextOverlays);
    }

    // 제목 효과
    const titleStaticEffect = document.getElementById('overlay-title-static-effect');
    if (titleStaticEffect) {
        titleStaticEffect.addEventListener('change', updateTextOverlays);
    }

    const titleDynamicEffect = document.getElementById('overlay-title-dynamic-effect');
    if (titleDynamicEffect) {
        titleDynamicEffect.addEventListener('change', updateTextOverlays);
    }

    // 부제목 입력 이벤트
    const subtitleInput = document.getElementById('overlay-subtitle-input');
    if (subtitleInput) {
        subtitleInput.addEventListener('input', updateTextOverlays);
    }

    // 부제목 크기 슬라이더
    const subtitleSize = document.getElementById('overlay-subtitle-size');
    if (subtitleSize) {
        subtitleSize.addEventListener('input', function() {
            document.getElementById('subtitle-size-display').textContent = this.value + 'px';
            updateTextOverlays();
        });
    }

    // 부제목 색상
    const subtitleColor = document.getElementById('overlay-subtitle-color');
    if (subtitleColor) {
        subtitleColor.addEventListener('input', updateTextOverlays);
    }

    // 부제목 효과
    const subtitleStaticEffect = document.getElementById('overlay-subtitle-static-effect');
    if (subtitleStaticEffect) {
        subtitleStaticEffect.addEventListener('change', updateTextOverlays);
    }

    const subtitleDynamicEffect = document.getElementById('overlay-subtitle-dynamic-effect');
    if (subtitleDynamicEffect) {
        subtitleDynamicEffect.addEventListener('change', updateTextOverlays);
    }

    // 일본어 자막 크기 슬라이더
    const japaneseSize = document.getElementById('overlay-japanese-size');
    if (japaneseSize) {
        japaneseSize.addEventListener('input', function() {
            const sizeValue = this.value + 'px';
            document.getElementById('japanese-size-display').textContent = sizeValue;

            // 메인 자막 오버레이에 실시간 적용
            const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
            if (japaneseOverlay && !japaneseOverlay.classList.contains('empty')) {
                japaneseOverlay.style.fontSize = sizeValue;
            }

            // Canvas에도 동기화
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 일본어 자막 색상
    const japaneseColor = document.getElementById('overlay-japanese-color');
    if (japaneseColor) {
        japaneseColor.addEventListener('input', function() {
            const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
            if (japaneseOverlay && !japaneseOverlay.classList.contains('empty')) {
                japaneseOverlay.style.color = this.value;
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 일본어 자막 X 위치
    const japaneseX = document.getElementById('overlay-japanese-x');
    if (japaneseX) {
        japaneseX.addEventListener('input', function() {
            const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
            if (japaneseOverlay && !japaneseOverlay.classList.contains('empty')) {
                japaneseOverlay.style.left = this.value + '%';
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 일본어 자막 Y 위치
    const japaneseY = document.getElementById('overlay-japanese-y');
    if (japaneseY) {
        japaneseY.addEventListener('input', function() {
            const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
            if (japaneseOverlay && !japaneseOverlay.classList.contains('empty')) {
                japaneseOverlay.style.top = this.value + '%';
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 일본어 자막 정적 효과
    const japaneseStaticEffect = document.getElementById('overlay-japanese-static-effect');
    if (japaneseStaticEffect) {
        japaneseStaticEffect.addEventListener('change', function() {
            const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
            if (japaneseOverlay && !japaneseOverlay.classList.contains('empty')) {
                // 기존 효과 제거
                japaneseOverlay.className = 'custom-subtitle-overlay';
                japaneseOverlay.setAttribute('data-lang', 'japanese');
                japaneseOverlay.setAttribute('lang', 'ja');

                // 새 효과 적용
                if (this.value && this.value !== 'none') {
                    japaneseOverlay.classList.add(`effect-${this.value}`);
                }

                // 동적 효과도 다시 추가
                const dynamicEffect = document.getElementById('overlay-japanese-dynamic-effect')?.value;
                if (dynamicEffect && dynamicEffect !== 'none') {
                    japaneseOverlay.classList.add(`effect-${dynamicEffect}`);
                }
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 일본어 자막 동적 효과
    const japaneseDynamicEffect = document.getElementById('overlay-japanese-dynamic-effect');
    if (japaneseDynamicEffect) {
        japaneseDynamicEffect.addEventListener('change', function() {
            const japaneseOverlay = document.getElementById('japanese-subtitle-overlay');
            if (japaneseOverlay && !japaneseOverlay.classList.contains('empty')) {
                // 기존 효과 제거
                japaneseOverlay.className = 'custom-subtitle-overlay';
                japaneseOverlay.setAttribute('data-lang', 'japanese');
                japaneseOverlay.setAttribute('lang', 'ja');

                // 정적 효과 다시 추가
                const staticEffect = document.getElementById('overlay-japanese-static-effect')?.value;
                if (staticEffect && staticEffect !== 'none') {
                    japaneseOverlay.classList.add(`effect-${staticEffect}`);
                }

                // 새 동적 효과 적용
                if (this.value && this.value !== 'none') {
                    japaneseOverlay.classList.add(`effect-${this.value}`);
                }
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 한글 자막 크기 슬라이더
    const koreanSize = document.getElementById('overlay-korean-size');
    if (koreanSize) {
        koreanSize.addEventListener('input', function() {
            const sizeValue = this.value + 'px';
            document.getElementById('korean-size-display').textContent = sizeValue;

            // 주자막 오버레이에 실시간 적용
            const koreanOverlay = document.getElementById('korean-subtitle-overlay');
            if (koreanOverlay && !koreanOverlay.classList.contains('empty')) {
                koreanOverlay.style.fontSize = sizeValue;
            }

            // Canvas에도 동기화
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 한글 자막 색상
    const koreanColor = document.getElementById('overlay-korean-color');
    if (koreanColor) {
        koreanColor.addEventListener('input', function() {
            const koreanOverlay = document.getElementById('korean-subtitle-overlay');
            if (koreanOverlay && !koreanOverlay.classList.contains('empty')) {
                koreanOverlay.style.color = this.value;
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 한글 자막 X 위치
    const koreanX = document.getElementById('overlay-korean-x');
    if (koreanX) {
        koreanX.addEventListener('input', function() {
            const koreanOverlay = document.getElementById('korean-subtitle-overlay');
            if (koreanOverlay && !koreanOverlay.classList.contains('empty')) {
                koreanOverlay.style.left = this.value + '%';
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 한글 자막 Y 위치
    const koreanY = document.getElementById('overlay-korean-y');
    if (koreanY) {
        koreanY.addEventListener('input', function() {
            const koreanOverlay = document.getElementById('korean-subtitle-overlay');
            if (koreanOverlay && !koreanOverlay.classList.contains('empty')) {
                koreanOverlay.style.top = this.value + '%';
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 한글 자막 정적 효과
    const koreanStaticEffect = document.getElementById('overlay-korean-static-effect');
    if (koreanStaticEffect) {
        koreanStaticEffect.addEventListener('change', function() {
            const koreanOverlay = document.getElementById('korean-subtitle-overlay');
            if (koreanOverlay && !koreanOverlay.classList.contains('empty')) {
                // 기존 효과 제거
                koreanOverlay.className = 'custom-subtitle-overlay';
                const lang = koreanOverlay.getAttribute('data-lang') || 'korean';
                koreanOverlay.setAttribute('data-lang', lang);

                // 새 효과 적용
                if (this.value && this.value !== 'none') {
                    koreanOverlay.classList.add(`effect-${this.value}`);
                }

                // 동적 효과도 다시 추가
                const dynamicEffect = document.getElementById('overlay-korean-dynamic-effect')?.value;
                if (dynamicEffect && dynamicEffect !== 'none') {
                    koreanOverlay.classList.add(`effect-${dynamicEffect}`);
                }
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 한글 자막 동적 효과
    const koreanDynamicEffect = document.getElementById('overlay-korean-dynamic-effect');
    if (koreanDynamicEffect) {
        koreanDynamicEffect.addEventListener('change', function() {
            const koreanOverlay = document.getElementById('korean-subtitle-overlay');
            if (koreanOverlay && !koreanOverlay.classList.contains('empty')) {
                // 기존 효과 제거
                koreanOverlay.className = 'custom-subtitle-overlay';
                const lang = koreanOverlay.getAttribute('data-lang') || 'korean';
                koreanOverlay.setAttribute('data-lang', lang);

                // 정적 효과 다시 추가
                const staticEffect = document.getElementById('overlay-korean-static-effect')?.value;
                if (staticEffect && staticEffect !== 'none') {
                    koreanOverlay.classList.add(`effect-${staticEffect}`);
                }

                // 새 동적 효과 적용
                if (this.value && this.value !== 'none') {
                    koreanOverlay.classList.add(`effect-${this.value}`);
                }
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 영어 자막 크기 슬라이더
    const englishSize = document.getElementById('overlay-english-size');
    if (englishSize) {
        englishSize.addEventListener('input', function() {
            const sizeValue = this.value + 'px';
            document.getElementById('english-size-display').textContent = sizeValue;

            // 보조자막 오버레이에 실시간 적용
            const englishOverlay = document.getElementById('english-subtitle-overlay');
            if (englishOverlay && !englishOverlay.classList.contains('empty')) {
                englishOverlay.style.fontSize = sizeValue;
            }

            // Canvas에도 동기화
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 영어 자막 색상
    const englishColor = document.getElementById('overlay-english-color');
    if (englishColor) {
        englishColor.addEventListener('input', function() {
            const englishOverlay = document.getElementById('english-subtitle-overlay');
            if (englishOverlay && !englishOverlay.classList.contains('empty')) {
                englishOverlay.style.color = this.value;
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 영어 자막 X 위치
    const englishX = document.getElementById('overlay-english-x');
    if (englishX) {
        englishX.addEventListener('input', function() {
            const englishOverlay = document.getElementById('english-subtitle-overlay');
            if (englishOverlay && !englishOverlay.classList.contains('empty')) {
                englishOverlay.style.left = this.value + '%';
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 영어 자막 Y 위치
    const englishY = document.getElementById('overlay-english-y');
    if (englishY) {
        englishY.addEventListener('input', function() {
            const englishOverlay = document.getElementById('english-subtitle-overlay');
            if (englishOverlay && !englishOverlay.classList.contains('empty')) {
                englishOverlay.style.top = this.value + '%';
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 영어 자막 정적 효과
    const englishStaticEffect = document.getElementById('overlay-english-static-effect');
    if (englishStaticEffect) {
        englishStaticEffect.addEventListener('change', function() {
            const englishOverlay = document.getElementById('english-subtitle-overlay');
            if (englishOverlay && !englishOverlay.classList.contains('empty')) {
                // 기존 효과 제거
                englishOverlay.className = 'custom-subtitle-overlay';
                const lang = englishOverlay.getAttribute('data-lang') || 'english';
                englishOverlay.setAttribute('data-lang', lang);

                // 새 효과 적용
                if (this.value && this.value !== 'none') {
                    englishOverlay.classList.add(`effect-${this.value}`);
                }

                // 동적 효과도 다시 추가
                const dynamicEffect = document.getElementById('overlay-english-dynamic-effect')?.value;
                if (dynamicEffect && dynamicEffect !== 'none') {
                    englishOverlay.classList.add(`effect-${dynamicEffect}`);
                }
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 영어 자막 동적 효과
    const englishDynamicEffect = document.getElementById('overlay-english-dynamic-effect');
    if (englishDynamicEffect) {
        englishDynamicEffect.addEventListener('change', function() {
            const englishOverlay = document.getElementById('english-subtitle-overlay');
            if (englishOverlay && !englishOverlay.classList.contains('empty')) {
                // 기존 효과 제거
                englishOverlay.className = 'custom-subtitle-overlay';
                const lang = englishOverlay.getAttribute('data-lang') || 'english';
                englishOverlay.setAttribute('data-lang', lang);

                // 정적 효과 다시 추가
                const staticEffect = document.getElementById('overlay-english-static-effect')?.value;
                if (staticEffect && staticEffect !== 'none') {
                    englishOverlay.classList.add(`effect-${staticEffect}`);
                }

                // 새 동적 효과 적용
                if (this.value && this.value !== 'none') {
                    englishOverlay.classList.add(`effect-${this.value}`);
                }
            }
            if (typeof updateCanvasText === 'function') {
                updateCanvasText();
            }
        });
    }

    // 출처 크기 슬라이더
    const sourceSize = document.getElementById('overlay-source-size');
    if (sourceSize) {
        sourceSize.addEventListener('input', function() {
            document.getElementById('source-size-display').textContent = this.value + 'px';
        });
    }

    // 자막 드래그 초기화
    initSubtitleDragging();

    // 출처 오버레이 숨기기 체크박스 이벤트
    const sourceHideCheckbox = document.getElementById('source-overlay-hide');
    const sourceOverlay = document.getElementById('source-overlay');

    if (sourceHideCheckbox && sourceOverlay) {
        sourceHideCheckbox.addEventListener('change', function() {
            if (this.checked) {
                sourceOverlay.style.display = 'none';
            } else {
                sourceOverlay.style.display = 'block';
            }
        });
    }
});

// 자막 미리보기 함수
async function previewSubtitle(subtitlePath, videoName) {
    try {
        // 자막 파일 읽기
        const response = await fetch(`/api/video-analyzer/read-subtitle?path=${encodeURIComponent(subtitlePath)}`);

        if (!response.ok) {
            throw new Error('자막 파일을 읽을 수 없습니다.');
        }

        const data = await response.json();

        // 모달 표시
        showSubtitleModal(data.subtitles, videoName, data.count);

    } catch (error) {
        console.error('자막 미리보기 오류:', error);
        alert('자막 미리보기 실패: ' + error.message);
    }
}

// 자막 모달 표시
function showSubtitleModal(subtitles, videoName, count) {
    const modal = document.getElementById('subtitle-preview-modal');
    const titleEl = document.getElementById('subtitle-modal-title');
    const countEl = document.getElementById('subtitle-modal-count');
    const contentEl = document.getElementById('subtitle-modal-content');

    titleEl.textContent = videoName;
    countEl.textContent = `총 ${count}개의 자막`;

    // 자막 내용 HTML 생성
    let html = '';
    subtitles.forEach(sub => {
        html += `
            <div class="subtitle-preview-item">
                <div class="subtitle-preview-time">${sub.start} → ${sub.end}</div>
                <div class="subtitle-preview-text">${sub.text}</div>
            </div>
        `;
    });

    contentEl.innerHTML = html;
    modal.style.display = 'flex';
}

// 자막 모달 닫기
function closeSubtitleModal() {
    const modal = document.getElementById('subtitle-preview-modal');
    modal.style.display = 'none';
}

// 모달 외부 클릭 시 닫기
window.addEventListener('click', (event) => {
    const modal = document.getElementById('subtitle-preview-modal');
    if (event.target === modal) {
        closeSubtitleModal();
    }
});

</script>

<!-- 자막 미리보기 모달 -->
<div id="subtitle-preview-modal" class="subtitle-modal" style="display: none;">
    <div class="subtitle-modal-content">
        <div class="subtitle-modal-header">
            <h2 style="margin: 0; color: #fff;">📌 제목자막 미리보기</h2>
            <button onclick="closeSubtitleModal()" class="subtitle-modal-close">&times;</button>
        </div>
        <div class="subtitle-modal-info">
            <div style="font-size: 1.1rem; font-weight: bold; color: #10b981;" id="subtitle-modal-title"></div>
            <div style="color: #10b981; font-size: 0.9rem;" id="subtitle-modal-count"></div>
        </div>
        <div class="subtitle-modal-body" id="subtitle-modal-content">
            <!-- 자막 내용이 여기에 표시됩니다 -->
        </div>
    </div>
</div>

<style>
.subtitle-modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.subtitle-modal-content {
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border-radius: 12px;
    width: 90%;
    max-width: 800px;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.subtitle-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 25px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.subtitle-modal-info {
    padding: 15px 25px;
    background: rgba(0, 0, 0, 0.2);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.subtitle-modal-close {
    background: none;
    border: none;
    color: #fff;
    font-size: 2rem;
    cursor: pointer;
    padding: 0;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
}

.subtitle-modal-close:hover {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
}

.subtitle-modal-body {
    padding: 20px 25px;
    overflow-y: auto;
    max-height: calc(85vh - 200px);
}

.subtitle-preview-item {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 12px;
    border-left: 3px solid #10b981;
    transition: all 0.2s;
}

.subtitle-preview-item:hover {
    background: rgba(255, 255, 255, 0.08);
    transform: translateX(5px);
}

.subtitle-preview-time {
    color: #10b981;
    font-size: 0.85rem;
    font-weight: bold;
    margin-bottom: 8px;
    font-family: 'Courier New', monospace;
}

.subtitle-preview-text {
    color: #10b981;
    font-size: 1rem;
    line-height: 1.6;
    white-space: pre-wrap;
}

/* 스크롤바 스타일링 */
.subtitle-modal-body::-webkit-scrollbar {
    width: 8px;
}

.subtitle-modal-body::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
}

.subtitle-modal-body::-webkit-scrollbar-thumb {
    background: rgba(16, 185, 129, 0.5);
    border-radius: 4px;
}

.subtitle-modal-body::-webkit-scrollbar-thumb:hover {
    background: rgba(16, 185, 129, 0.7);
}

/* 진행률 모달 스타일 */
#progress-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    justify-content: center;
    align-items: center;
}

.progress-modal-content {
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    padding: 40px;
    border-radius: 16px;
    width: 500px;
    max-width: 90%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.progress-modal-header {
    text-align: center;
    margin-bottom: 30px;
}

.progress-modal-header h3 {
    color: #10b981;
    font-size: 24px;
    margin: 0 0 10px 0;
}

.progress-modal-header p {
    color: #94a3b8;
    font-size: 14px;
    margin: 0;
}

.progress-bar-container {
    width: 100%;
    height: 30px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    overflow: hidden;
    margin-bottom: 15px;
    position: relative;
    border: 1px solid rgba(16, 185, 129, 0.2);
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
    border-radius: 15px;
    transition: width 0.3s ease;
    position: relative;
    overflow: hidden;
}

.progress-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.3) 50%,
        transparent 100%
    );
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(100%);
    }
}

.progress-text {
    text-align: center;
    color: #e0e6ed;
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 10px;
}

.progress-message {
    text-align: center;
    color: #94a3b8;
    font-size: 14px;
    min-height: 20px;
}

.progress-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(16, 185, 129, 0.3);
    border-top-color: #10b981;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
    vertical-align: middle;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
</style>

<!-- 진행률 모달 -->
<div id="progress-modal">
    <div class="progress-modal-content">
        <div class="progress-modal-header">
            <h3>🎬 프리뷰 영상 생성 중</h3>
            <p>잠시만 기다려주세요...</p>
        </div>
        <div class="progress-text" id="progress-percentage">0%</div>
        <div class="progress-bar-container">
            <div class="progress-bar" id="progress-bar" style="width: 0%;"></div>
        </div>
        <div class="progress-message">
            <span class="progress-spinner"></span>
            <span id="progress-message">초기화 중...</span>
        </div>
    </div>
</div>

<script>
// 로드된 미디어 파일 정보 저장
const loadedMedia = {
    video: null,
    audio: null,
    commentary: null,
    bgm: null
};

const AUDIO_TRACK_TYPES = ['audio', 'commentary', 'bgm'];
let audioSyncInitialized = false;
let currentAudioSelection = null;

// 로드된 자막 데이터
const loadedSubtitles = {
    main: [],
    translation: [],
    description: []
};

// 로드된 자막 파일명 저장
const loadedSubtitleFiles = {
    main: null,
    translation: null,
    description: null
};

// A-B 반복 재생 상태
const abRepeat = {
    pointA: null,
    pointB: null,
    enabled: false
};

// 자막 파일명 표시 업데이트
function updateSubtitleFileDisplay() {
    const displayElement = document.getElementById('loaded-subtitle-files');
    if (!displayElement) return;

    const trackNames = {
        main: '메인',
        translation: '번역',
        description: '설명'
    };

    const loadedFiles = [];
    for (const [trackType, fileName] of Object.entries(loadedSubtitleFiles)) {
        if (fileName) {
            loadedFiles.push(`${trackNames[trackType]}: ${fileName}`);
        }
    }

    if (loadedFiles.length > 0) {
        displayElement.textContent = `(${loadedFiles.join(', ')})`;
    } else {
        displayElement.textContent = '';
    }
}

// IndexedDB 초기화
let db;
const DB_NAME = 'VideoAnalyzerDB';
const DB_VERSION = 1;
const STORE_NAME = 'mediaFiles';

function initIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => {
            console.error('IndexedDB 열기 실패:', request.error);
            reject(request.error);
        };

        request.onsuccess = () => {
            db = request.result;
            console.log('IndexedDB 초기화 완료');
            resolve(db);
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;

            // Object Store 생성
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                objectStore.createIndex('type', 'type', { unique: false });
                console.log('Object Store 생성 완료');
            }
        };
    });
}

// 파일을 IndexedDB에 저장
function saveFileToIndexedDB(id, type, file, metadata = {}) {
    return new Promise((resolve, reject) => {
        if (!db) {
            reject('IndexedDB가 초기화되지 않았습니다.');
            return;
        }

        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const objectStore = transaction.objectStore(STORE_NAME);

        const data = {
            id: id,
            type: type,
            file: file,
            metadata: metadata,
            timestamp: Date.now()
        };

        const request = objectStore.put(data);

        request.onsuccess = () => {
            console.log(`파일 저장 완료: ${id} (${type})`);
            resolve();
        };

        request.onerror = () => {
            console.error('파일 저장 실패:', request.error);
            reject(request.error);
        };
    });
}

// IndexedDB에서 파일 불러오기
function loadFileFromIndexedDB(id) {
    return new Promise((resolve, reject) => {
        if (!db) {
            reject('IndexedDB가 초기화되지 않았습니다.');
            return;
        }

        const transaction = db.transaction([STORE_NAME], 'readonly');
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.get(id);

        request.onsuccess = () => {
            if (request.result) {
                console.log(`파일 불러오기 완료: ${id}`);
                resolve(request.result);
            } else {
                resolve(null);
            }
        };

        request.onerror = () => {
            console.error('파일 불러오기 실패:', request.error);
            reject(request.error);
        };
    });
}

// IndexedDB에서 특정 타입의 모든 파일 불러오기
function loadAllFilesByType(type) {
    return new Promise((resolve, reject) => {
        if (!db) {
            reject('IndexedDB가 초기화되지 않았습니다.');
            return;
        }

        const transaction = db.transaction([STORE_NAME], 'readonly');
        const objectStore = transaction.objectStore(STORE_NAME);
        const index = objectStore.index('type');
        const request = index.getAll(type);

        request.onsuccess = () => {
            console.log(`${type} 타입 파일 ${request.result.length}개 불러오기 완료`);
            resolve(request.result);
        };

        request.onerror = () => {
            console.error('파일 목록 불러오기 실패:', request.error);
            reject(request.error);
        };
    });
}

// 저장된 파일들을 복원하는 함수
async function restoreSavedFiles() {
    try {
        console.log('🔄 저장된 파일 복원 시작...');

        let restoredCount = 0;
        const errors = [];

        // 비디오 파일 복원
        try {
            const videoData = await loadFileFromIndexedDB('video');
            if (videoData && videoData.file) {
                console.log('📹 비디오 파일 복원:', videoData.metadata.fileName);
                const file = new File([videoData.file], videoData.metadata.fileName, { type: videoData.file.type });
                await handleVideoFileLoad(file, true); // silent 모드
                restoredCount++;
                console.log('✅ 비디오 파일 복원 성공');

                // 비디오 미리보기 섹션 표시
                const previewSection = document.getElementById('video-preview-section');
                if (previewSection) {
                    previewSection.style.display = 'block';
                    console.log('📺 비디오 미리보기 섹션 표시됨');
                }
            } else {
                console.log('ℹ️ 저장된 비디오 파일 없음');
            }
        } catch (error) {
            console.error('❌ 비디오 파일 복원 실패:', error);
            errors.push(`비디오: ${error.message || error}`);
        }

        // 메인 자막 파일 복원
        try {
            const mainData = await loadFileFromIndexedDB('main-subtitle');
            if (mainData && mainData.file) {
                console.log('📝 메인 자막 파일 복원:', mainData.metadata.fileName);
                const file = new File([mainData.file], mainData.metadata.fileName, { type: 'text/plain' });
                // 타임라인 트랙으로 복원
                handleSubtitleFileLoad(file, 'main');
                restoredCount++;
                console.log('✅ 메인 자막 파일 복원 성공');
            } else {
                console.log('ℹ️ 저장된 메인 자막 파일 없음');
            }
        } catch (error) {
            console.error('❌ 메인 자막 파일 복원 실패:', error);
            errors.push(`메인 자막: ${error.message || error}`);
        }

        // 주자막 파일 복원
        try {
            const translationData = await loadFileFromIndexedDB('translation-subtitle');
            if (translationData && translationData.file) {
                console.log('📝 주자막 파일 복원:', translationData.metadata.fileName);
                const file = new File([translationData.file], translationData.metadata.fileName, { type: 'text/plain' });
                // 타임라인 트랙으로 복원
                handleSubtitleFileLoad(file, 'translation');
                restoredCount++;
                console.log('✅ 주자막 파일 복원 성공');
            } else {
                console.log('ℹ️ 저장된 주자막 파일 없음');
            }
        } catch (error) {
            console.error('❌ 주자막 파일 복원 실패:', error);
            errors.push(`주자막: ${error.message || error}`);
        }

        // 보조자막 파일 복원
        try {
            const descriptionData = await loadFileFromIndexedDB('description-subtitle');
            if (descriptionData && descriptionData.file) {
                console.log('📝 보조자막 파일 복원:', descriptionData.metadata.fileName);
                const file = new File([descriptionData.file], descriptionData.metadata.fileName, { type: 'text/plain' });
                // 타임라인 트랙으로 복원
                handleSubtitleFileLoad(file, 'description');
                restoredCount++;
                console.log('✅ 보조자막 파일 복원 성공');
            } else {
                console.log('ℹ️ 저장된 보조자막 파일 없음');
            }
        } catch (error) {
            console.error('❌ 보조자막 파일 복원 실패:', error);
            errors.push(`보조자막: ${error.message || error}`);
        }

        // 오디오 트랙 복원 (audio, commentary, bgm)
        for (const trackType of ['audio', 'commentary', 'bgm']) {
            try {
                const audioData = await loadFileFromIndexedDB(trackType);
                if (audioData && audioData.file) {
                    console.log(`🎵 ${trackType} 파일 복원:`, audioData.metadata.fileName);
                    const file = new File([audioData.file], audioData.metadata.fileName, { type: audioData.file.type });
                    await handleAudioFileLoad(file, trackType);
                    restoredCount++;
                    console.log(`✅ ${trackType} 파일 복원 성공`);
                } else {
                    console.log(`ℹ️ 저장된 ${trackType} 파일 없음`);
                }
            } catch (error) {
                console.error(`❌ ${trackType} 파일 복원 실패:`, error);
                errors.push(`${trackType}: ${error.message || error}`);
            }
        }

        // 결과 메시지 표시
        if (restoredCount > 0 || errors.length > 0) {
            const statusMsg = document.createElement('div');
            statusMsg.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${errors.length > 0 ? '#ef4444' : '#10b981'};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: bold;
                max-width: 300px;
            `;

            if (restoredCount > 0) {
                statusMsg.textContent = `✅ ${restoredCount}개 파일 복원됨`;
                console.log(`✅ 파일 복원 완료 (${restoredCount}개)`);
            }

            if (errors.length > 0) {
                statusMsg.innerHTML = `❌ 복원 오류<br><small>${errors.join('<br>')}</small>`;
                console.error('❌ 복원 오류:', errors);
            }

            document.body.appendChild(statusMsg);
            setTimeout(() => statusMsg.remove(), 5000);
        } else {
            console.log('ℹ️ 복원할 파일 없음');
        }
    } catch (error) {
        console.error('❌ 파일 복원 중 치명적 오류:', error);
        alert(`파일 복원 중 오류가 발생했습니다: ${error.message || error}`);
    }
}

// 파일 로드 기능 초기화
document.addEventListener('DOMContentLoaded', async function() {
    // IndexedDB 초기화
    try {
        await initIndexedDB();
        console.log('✅ IndexedDB 초기화 성공');

        // 저장된 파일 복원
        await restoreSavedFiles();
    } catch (error) {
        console.error('❌ IndexedDB 초기화 실패:', error);
    }

    // 텍스트 오버레이 설정 자동 복원
    try {
        const saved = localStorage.getItem('videoAnalyzerTextOverlay');
        if (saved) {
            const settings = JSON.parse(saved);
            console.log('🔄 텍스트 오버레이 설정 복원 중...');

            // 설정을 복원하지만 실제 오버레이는 영상 로드 후에만 적용
            // 입력 필드 값만 복원
            if (settings.title) {
                const titleInput = document.getElementById('overlay-title-input');
                const titleSize = document.getElementById('overlay-title-size');
                const titleColor = document.getElementById('overlay-title-color');
                if (titleInput) titleInput.value = settings.title.text || '';
                if (titleSize) {
                    titleSize.value = settings.title.size || 48;
                    const titleSizeDisplay = document.getElementById('title-size-display');
                    if (titleSizeDisplay) titleSizeDisplay.textContent = (settings.title.size || 48) + 'px';
                }
                if (titleColor) titleColor.value = settings.title.color || '#ffffff';
            }

            if (settings.subtitle) {
                const subtitleInput = document.getElementById('overlay-subtitle-input');
                const subtitleSize = document.getElementById('overlay-subtitle-size');
                const subtitleColor = document.getElementById('overlay-subtitle-color');
                if (subtitleInput) subtitleInput.value = settings.subtitle.text || '';
                if (subtitleSize) {
                    subtitleSize.value = settings.subtitle.size || 32;
                    const subtitleSizeDisplay = document.getElementById('subtitle-size-display');
                    if (subtitleSizeDisplay) subtitleSizeDisplay.textContent = (settings.subtitle.size || 32) + 'px';
                }
                if (subtitleColor) subtitleColor.value = settings.subtitle.color || '#ffe14d';
            }

            // 검정 배경 설정 복원
            if (settings.blackBars) {
                if (settings.blackBars.top) {
                    const topEnable = document.getElementById('top-bar-enable');
                    const topHeight = document.getElementById('top-bar-height');
                    const topOpacity = document.getElementById('top-bar-opacity');
                    if (topEnable) topEnable.checked = settings.blackBars.top.enabled || false;
                    if (topHeight) topHeight.value = settings.blackBars.top.height || 15;
                    if (topOpacity) topOpacity.value = settings.blackBars.top.opacity || 70;
                }
                if (settings.blackBars.bottom) {
                    const bottomEnable = document.getElementById('bottom-bar-enable');
                    const bottomHeight = document.getElementById('bottom-bar-height');
                    const bottomOpacity = document.getElementById('bottom-bar-opacity');
                    if (bottomEnable) bottomEnable.checked = settings.blackBars.bottom.enabled || false;
                    if (bottomHeight) bottomHeight.value = settings.blackBars.bottom.height || 15;
                    if (bottomOpacity) bottomOpacity.value = settings.blackBars.bottom.opacity || 70;
                }
            }

            updateSettingsStatus(settings.name || '기본 설정', settings.savedAt ? new Date(settings.savedAt) : null);
            console.log('✅ 텍스트 오버레이 설정 복원 완료');
        }
    } catch (error) {
        console.error('❌ 텍스트 오버레이 설정 복원 실패:', error);
    }

    // 타임라인 줌 변경 이벤트
    const timelineZoom = document.getElementById('timeline-zoom');
    if (timelineZoom) {
        timelineZoom.addEventListener('input', function() {
            updateAllClipSizes();
        });
    }

    // 영상 파일 로드
    const videoFileInput = document.getElementById('video-file-input');
    if (videoFileInput) {
        videoFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleVideoFileLoad(file).catch((error) => {
                    console.error('영상 파일 로드 실패:', error);
                });
            }
        });
    }

    // 제목/부제목 숨기기 체크박스 이벤트
    const hideTitleCheckbox = document.getElementById('hide-title-overlay');
    const hideSubtitleCheckbox = document.getElementById('hide-subtitle-overlay');

    if (hideTitleCheckbox) {
        hideTitleCheckbox.addEventListener('change', function() {
            const titleOverlay = document.getElementById('video-title-overlay');
            if (titleOverlay) {
                titleOverlay.style.display = this.checked ? 'none' : 'block';
            }
        });
    }

    if (hideSubtitleCheckbox) {
        hideSubtitleCheckbox.addEventListener('change', function() {
            const subtitleOverlay = document.getElementById('video-subtitle-overlay');
            if (subtitleOverlay) {
                subtitleOverlay.style.display = this.checked ? 'none' : 'block';
            }
        });
    }

    // 음성 파일 로드
    const audioFileInput = document.getElementById('audio-file-input');
    if (audioFileInput) {
        audioFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleAudioFileLoad(file, 'audio').catch((error) => {
                    console.error('음성 파일 로드 실패:', error);
                });
            }
        });
    }

    // 해설 음성 파일 로드
    const commentaryFileInput = document.getElementById('commentary-file-input');
    if (commentaryFileInput) {
        commentaryFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleAudioFileLoad(file, 'commentary').catch((error) => {
                    console.error('해설 음성 파일 로드 실패:', error);
                });
            }
        });
    }

    // 배경 음악 파일 로드
    const bgmFileInput = document.getElementById('bgm-file-input');
    if (bgmFileInput) {
        bgmFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleAudioFileLoad(file, 'bgm').catch((error) => {
                    console.error('배경 음악 파일 로드 실패:', error);
                });
            }
        });
    }

    // 메인 자막 파일 로드
    const mainSubtitleInput = document.getElementById('main-subtitle-file-input');
    if (mainSubtitleInput) {
        mainSubtitleInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleSubtitleFileLoad(file, 'main');
            }
        });
    }

    // 오디오 편집 버튼 동작
    document.querySelectorAll('[data-audio-action]').forEach((button) => {
        button.addEventListener('click', async function() {
            const action = this.dataset.audioAction;
            const trackType = this.dataset.track;
            if (!trackType || !action) {
                return;
            }

            if (action === 'clear-selection') {
                clearAudioSelection(trackType);
                return;
            }

            const originalText = this.textContent;
            this.disabled = true;
            this.textContent = '⏳ 처리 중...';

            try {
                if (action === 'trim-to-video') {
                    await trimAudioToVideoLength(trackType);
                } else if (action === 'delete-from-selection') {
                    await deleteAudioFromSelection(trackType);
                }
            } catch (error) {
                console.error('오디오 편집 작업 실패:', error);
            } finally {
                this.disabled = false;
                this.textContent = originalText;
            }
        });
    });

    updateAudioSelectionUI();

    // 주자막 파일 로드
    const translationSubtitleInput = document.getElementById('translation-subtitle-file-input');
    if (translationSubtitleInput) {
        translationSubtitleInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleSubtitleFileLoad(file, 'translation');
            }
        });
    }

    // 보조자막 파일 로드
    const descriptionSubtitleInput = document.getElementById('description-subtitle-file-input');
    if (descriptionSubtitleInput) {
        descriptionSubtitleInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleSubtitleFileLoad(file, 'description');
            }
        });
    }

    attachAudioTrackToggleListeners();

    // 빠른 자막 파일 로드 (제목자막 포함 옆 버튼)
    const quickSubtitleInput = document.getElementById('quick-subtitle-file-input');
    if (quickSubtitleInput) {
        quickSubtitleInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleSubtitleFileLoad(file, 'main');
                // 자막을 로드하면 자동으로 체크박스 체크
                const checkbox = document.getElementById('include-title-subtitle');
                if (checkbox) {
                    checkbox.checked = true;
                }
            }
        });
    }

    // 재생 컨트롤 버튼 이벤트 핸들러
    const playPauseBtn = document.getElementById('play-pause-btn');
    const stopBtn = document.getElementById('stop-btn');
    const rewindBtn = document.getElementById('rewind-btn');
    const forwardBtn = document.getElementById('forward-btn');
    const skipToStartBtn = document.getElementById('skip-to-start-btn');
    const skipToEndBtn = document.getElementById('skip-to-end-btn');

    // 재생/일시정지
    if (playPauseBtn) {
        playPauseBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                if (videoPlayer.paused) {
                    videoPlayer.play();
                    playPauseBtn.textContent = '⏸️';
                } else {
                    videoPlayer.pause();
                    playPauseBtn.textContent = '▶️';
                }
            } else {
                alert('영상을 먼저 로드해주세요.');
            }
        });
    }

    // 정지
    if (stopBtn) {
        stopBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                videoPlayer.pause();
                videoPlayer.currentTime = 0;
                if (playPauseBtn) playPauseBtn.textContent = '▶️';
            }
        });
    }

    // 되감기 (5초 뒤로)
    if (rewindBtn) {
        rewindBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 5);
            }
        });
    }

    // 빨리감기 (5초 앞으로)
    if (forwardBtn) {
        forwardBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 5);
            }
        });
    }

    // 처음으로
    if (skipToStartBtn) {
        skipToStartBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                videoPlayer.currentTime = 0;
            }
        });
    }

    // 끝으로
    if (skipToEndBtn) {
        skipToEndBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                videoPlayer.currentTime = videoPlayer.duration;
            }
        });
    }

    // 재생 속도 조절
    const playbackSpeedBtn = document.getElementById('playback-speed-btn');
    const playbackSpeeds = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0];
    let currentSpeedIndex = 3; // 1.0x

    if (playbackSpeedBtn) {
        playbackSpeedBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                // 다음 속도로 변경
                currentSpeedIndex = (currentSpeedIndex + 1) % playbackSpeeds.length;
                const newSpeed = playbackSpeeds[currentSpeedIndex];
                videoPlayer.playbackRate = newSpeed;
                playbackSpeedBtn.textContent = `${newSpeed}x`;
                console.log('재생 속도 변경:', newSpeed);
            } else {
                alert('영상을 먼저 로드해주세요.');
            }
        });
    }

    // A-B 구간 반복 재생
    const setPointABtn = document.getElementById('set-point-a-btn');
    const setPointBBtn = document.getElementById('set-point-b-btn');
    const toggleAbRepeatBtn = document.getElementById('toggle-ab-repeat-btn');

    // A 지점 설정
    if (setPointABtn) {
        setPointABtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                abRepeat.pointA = videoPlayer.currentTime;
                const mins = Math.floor(abRepeat.pointA / 60);
                const secs = Math.floor(abRepeat.pointA % 60);
                setPointABtn.textContent = `🅰️ ${mins}:${secs.toString().padStart(2, '0')}`;
                setPointABtn.style.background = '#10b981';
                console.log('A 지점 설정:', abRepeat.pointA);
            } else {
                alert('영상을 먼저 로드해주세요.');
            }
        });
    }

    // B 지점 설정
    if (setPointBBtn) {
        setPointBBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                abRepeat.pointB = videoPlayer.currentTime;
                const mins = Math.floor(abRepeat.pointB / 60);
                const secs = Math.floor(abRepeat.pointB % 60);
                setPointBBtn.textContent = `🅱️ ${mins}:${secs.toString().padStart(2, '0')}`;
                setPointBBtn.style.background = '#f59e0b';
                console.log('B 지점 설정:', abRepeat.pointB);

                // B 지점 설정 시 A 지점이 있으면 자동으로 반복 활성화
                if (abRepeat.pointA !== null && abRepeat.pointB > abRepeat.pointA) {
                    abRepeat.enabled = true;
                    toggleAbRepeatBtn.textContent = '🔁 ON';
                    toggleAbRepeatBtn.style.background = '#ef4444';
                }
            } else {
                alert('영상을 먼저 로드해주세요.');
            }
        });
    }

    // A-B 반복 토글
    if (toggleAbRepeatBtn) {
        toggleAbRepeatBtn.addEventListener('click', function() {
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && videoPlayer.src) {
                if (abRepeat.pointA === null || abRepeat.pointB === null) {
                    alert('A 지점과 B 지점을 먼저 설정해주세요.');
                    return;
                }
                if (abRepeat.pointB <= abRepeat.pointA) {
                    alert('B 지점은 A 지점보다 뒤에 있어야 합니다.');
                    return;
                }

                abRepeat.enabled = !abRepeat.enabled;
                if (abRepeat.enabled) {
                    toggleAbRepeatBtn.textContent = '🔁 ON';
                    toggleAbRepeatBtn.style.background = '#ef4444';
                    console.log('A-B 반복 활성화');
                } else {
                    toggleAbRepeatBtn.textContent = '🔁 OFF';
                    toggleAbRepeatBtn.style.background = '#4a5568';
                    console.log('A-B 반복 비활성화');
                }
            } else {
                alert('영상을 먼저 로드해주세요.');
            }
        });
    }

    // 키보드 단축키
    document.addEventListener('keydown', function(e) {
        // input, textarea 등에서는 단축키 비활성화
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        const videoPlayer = document.getElementById('video-preview-player');
        if (!videoPlayer || !videoPlayer.src) return;

        switch(e.code) {
            case 'Space': // 재생/일시정지
                e.preventDefault();
                if (videoPlayer.paused) {
                    videoPlayer.play();
                    if (playPauseBtn) playPauseBtn.textContent = '⏸️';
                } else {
                    videoPlayer.pause();
                    if (playPauseBtn) playPauseBtn.textContent = '▶️';
                }
                break;

            case 'ArrowLeft': // 5초 뒤로
                e.preventDefault();
                videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 5);
                break;

            case 'ArrowRight': // 5초 앞으로
                e.preventDefault();
                videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 5);
                break;

            case 'Home': // 처음으로
                e.preventDefault();
                videoPlayer.currentTime = 0;
                break;

            case 'End': // 끝으로
                e.preventDefault();
                videoPlayer.currentTime = videoPlayer.duration;
                break;
        }
    });
});

// 영상 파일 로드 처리
function handleVideoFileLoad(file, silent = false) {
    return new Promise((resolve, reject) => {
        console.log('영상 파일 로드:', file.name);

        const url = URL.createObjectURL(file);
        const videoPlayer = document.getElementById('video-preview-player');

        if (!videoPlayer) {
            reject('비디오 플레이어를 찾을 수 없습니다.');
            return;
        }

        videoPlayer.src = url;
        videoPlayer.load();

        // 비디오 메타데이터가 로드되면 타임라인 업데이트
        videoPlayer.addEventListener('loadedmetadata', async function() {
            try {
                const duration = videoPlayer.duration;
                console.log('영상 길이:', duration, '초');

                // 로드된 미디어 정보 저장
                loadedMedia.video = {
                    fileName: file.name,
                    duration: duration
                };

                // 타임라인에 영상 클립 표시
                displayVideoClipOnTimeline(file.name, duration);

                // 재생 헤드 표시
                const playhead = document.getElementById('playhead');
                if (playhead) {
                    playhead.style.display = 'block';
                }

                // 시간 표시 동기화
                initPlayheadSync();
                initAudioSync();
                syncAudioTrackVolume(videoPlayer);
                syncAudioTrackRate(videoPlayer);

                // IndexedDB에 파일 저장 (복원 모드가 아닐 때만)
                if (!silent) {
                    try {
                        await saveFileToIndexedDB('video', 'video', file, {
                            fileName: file.name,
                            duration: duration
                        });
                        console.log('✅ 비디오 파일이 IndexedDB에 저장되었습니다.');
                    } catch (error) {
                        console.error('❌ 비디오 파일 저장 실패:', error);
                    }

                    alert(`영상 파일 "${file.name}"이 로드되었습니다.\n길이: ${duration.toFixed(2)}초`);
                }

                resolve();
            } catch (error) {
                reject(error);
            }
        }, { once: true });

        // 에러 처리
        videoPlayer.addEventListener('error', function(e) {
            reject(`비디오 로드 실패: ${e.message}`);
        }, { once: true });
    });
}

// 재생 헤드 동기화 초기화
function initPlayheadSync() {
    const videoPlayer = document.getElementById('video-preview-player');
    const playhead = document.getElementById('playhead');
    const playheadTime = document.getElementById('playhead-time');
    const currentTimeDisplay = document.getElementById('current-time');
    const totalTimeDisplay = document.getElementById('total-time');

    if (!videoPlayer || !playhead) return;

    // 시간 업데이트 이벤트
    videoPlayer.addEventListener('timeupdate', function() {
        const currentTime = videoPlayer.currentTime;
        const duration = videoPlayer.duration;

        // A-B 구간 반복 체크
        if (abRepeat.enabled && abRepeat.pointA !== null && abRepeat.pointB !== null) {
            if (currentTime >= abRepeat.pointB) {
                videoPlayer.currentTime = abRepeat.pointA;
                console.log('A-B 반복: B 지점 도달, A 지점으로 이동');
            }
        }

        // 줌 레벨 가져오기
        const zoomLevel = parseFloat(document.getElementById('timeline-zoom')?.value || 1);
        const pixelsPerSecond = 50 * zoomLevel;

        // 재생 헤드 위치 계산 (트랙 헤더 너비 180px 추가)
        const leftPosition = 180 + (currentTime * pixelsPerSecond);
        playhead.style.left = leftPosition + 'px';

        // 시간 표시 포맷팅
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        // 재생 헤드 시간 표시 업데이트
        if (playheadTime) {
            playheadTime.textContent = formatTime(currentTime);
        }

        // 상단 시간 표시 업데이트
        if (currentTimeDisplay) {
            currentTimeDisplay.textContent = formatTime(currentTime);
        }
        if (totalTimeDisplay && duration) {
            totalTimeDisplay.textContent = formatTime(duration);
        }

        // 타임라인 자막을 화면에 표시
        updateSubtitleOverlaysFromTimeline(currentTime);
    });
}

// 타임라인에 영상 클립 표시
function displayVideoClipOnTimeline(fileName, duration) {
    const videoTrack = document.getElementById('video-track');
    if (!videoTrack) return;

    // 기존 클립 제거
    videoTrack.innerHTML = '';

    // 줌 레벨 가져오기
    const zoomLevel = parseFloat(document.getElementById('timeline-zoom')?.value || 1);
    const pixelsPerSecond = 50 * zoomLevel; // 기본 50px/초 * 줌 레벨 (10초 = 500px)

    // 클립 너비 계산
    const clipWidth = duration * pixelsPerSecond;

    // 클립 요소 생성
    const clip = document.createElement('div');
    clip.className = 'video-clip';
    clip.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0;
        width: ${clipWidth}px;
        height: 100%;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.3) 100%);
        border: 2px solid rgba(59, 130, 246, 0.6);
        border-radius: 4px;
        cursor: move;
        display: flex;
        align-items: center;
        padding: 0 10px;
        font-size: 12px;
        color: #fff;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    `;

    clip.innerHTML = `
        <span style="font-weight: bold;">📹 ${fileName}</span>
        <span style="margin-left: 10px; opacity: 0.7;">${duration.toFixed(2)}초</span>
    `;

    clip.title = `${fileName} (${duration.toFixed(2)}초)`;

    videoTrack.appendChild(clip);

    console.log(`영상 클립이 타임라인에 표시되었습니다. 너비: ${clipWidth}px`);
}

// 음성 파일 로드 처리
function handleAudioFileLoad(file, trackType, options = {}) {
    console.log(`${trackType} 음성 파일 로드:`, file.name);

    const {
        silent = false,
        alertMessage,
        skipAlert = false
    } = options || {};

    const showAlert = !silent && !skipAlert;

    const previous = loadedMedia[trackType];
    if (previous) {
        if (previous.audioElement) {
            try {
                previous.audioElement.pause();
            } catch (error) {
                console.warn('이전 오디오 트랙 일시정지 실패:', error);
            }
        }
        if (previous.objectUrl) {
            URL.revokeObjectURL(previous.objectUrl);
        }
    }

    const url = URL.createObjectURL(file);
    const audio = new Audio(url);
    audio.preload = 'auto';
    audio.loop = false;

    return new Promise((resolve, reject) => {
        const cleanup = () => {
            audio.removeEventListener('loadedmetadata', onLoadedMetadata);
            audio.removeEventListener('error', onAudioError);
        };

        const onAudioError = (event) => {
            cleanup();
            console.error('오디오 메타데이터 로드 실패:', event);
            if (!silent) {
                alert('❌ 오디오 파일을 불러오는 중 문제가 발생했습니다.');
            }
            URL.revokeObjectURL(url);
            reject(event instanceof Error ? event : new Error('오디오 로드 실패'));
        };

        const onLoadedMetadata = () => {
            cleanup();

            const duration = audio.duration;
            console.log(`${trackType} 음성 길이:`, duration, '초');

            // 로드된 미디어 정보 저장
            loadedMedia[trackType] = {
                fileName: file.name,
                duration: duration,
                file: file,
                audioElement: audio,
                objectUrl: url
            };

            clearAudioSelection(trackType);

            // 파형 그리기
            drawWaveform(file, trackType, duration);

            // 타임라인에 음성 클립 표시
            displayAudioClipOnTimeline(file.name, duration, trackType);

            // 타임라인 전체 너비 업데이트
            updateAllClipSizes();

            attachAudioTrackToggleListeners();
            initAudioSync();

            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer) {
                syncAudioTrackRate(videoPlayer);
                syncAudioTrackVolume(videoPlayer);
                if (!videoPlayer.paused && !videoPlayer.ended) {
                    startAudioTracks(videoPlayer);
                }
            }

            if (showAlert) {
                const message = alertMessage || `음성 파일 "${file.name}"이 ${trackType} 트랙에 로드되었습니다.\n길이: ${duration.toFixed(2)}초`;
                alert(message);
            } else {
                console.log(`음성 파일이 ${trackType} 트랙에 로드되었습니다. (길이: ${duration.toFixed(2)}초)`);
            }

            // 자동 자르기: 음성이 영상보다 길면 자동으로 자를지 물어보기
            const videoInfo = loadedMedia.video;
            if (videoInfo && videoInfo.duration && duration > videoInfo.duration + 0.5) {
                const shouldTrim = confirm(
                    `음성 길이(${duration.toFixed(2)}초)가 영상 길이(${videoInfo.duration.toFixed(2)}초)보다 깁니다.\n\n영상 길이에 맞춰 자동으로 자르시겠습니까?`
                );

                if (shouldTrim) {
                    // 비동기로 자르기 실행 (resolve 후에 실행)
                    setTimeout(() => {
                        trimAudioToVideoLength(trackType).catch(err => {
                            console.error('자동 자르기 실패:', err);
                            alert('음성 자르기에 실패했습니다.\n수동으로 "✂️ 영상 길이 맞추기" 버튼을 사용해주세요.');
                        });
                    }, 100);
                }
            }

            resolve({ duration });
        };

        audio.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
        audio.addEventListener('error', onAudioError, { once: true });

        if (audio.readyState >= 1 && Number.isFinite(audio.duration) && audio.duration > 0) {
            onLoadedMetadata();
        }
    });
}

// 타임라인에 음성 클립 표시
function displayAudioClipOnTimeline(fileName, duration, trackType) {
    // 트랙 ID 결정
    const trackId = trackType === 'audio' ? 'audio-track' :
                    trackType === 'commentary' ? 'commentary-audio-track' :
                    'bgm-audio-track';

    const audioTrack = document.getElementById(trackId);
    if (!audioTrack) return;

    // 캔버스가 있다면 그 위에 오버레이로 표시
    const canvas = audioTrack.querySelector('canvas');

    // 줌 레벨 가져오기
    const zoomLevel = parseFloat(document.getElementById('timeline-zoom')?.value || 1);
    const pixelsPerSecond = 50 * zoomLevel;

    // 클립 너비 계산
    const clipWidth = duration * pixelsPerSecond;

    console.log(`[displayAudioClipOnTimeline] ${trackType} - duration: ${duration}s, zoom: ${zoomLevel}, clipWidth: ${clipWidth}px`);

    // 클립 정보 오버레이 생성 (캔버스 위에 표시)
    let overlay = audioTrack.querySelector('.audio-clip-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.className = 'audio-clip-overlay';
        overlay.style.cssText = `
            position: absolute;
            left: 0;
            top: 0;
            height: 20px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.4) 0%, rgba(5, 150, 105, 0.4) 100%);
            border: 1px solid rgba(16, 185, 129, 0.6);
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 10px;
            color: #fff;
            font-weight: bold;
            z-index: 10;
            cursor: crosshair;
            pointer-events: auto;
        `;
        audioTrack.style.position = 'relative';
        audioTrack.appendChild(overlay);
    }

    overlay.style.width = `${clipWidth}px`;
    overlay.textContent = `🎵 ${fileName} (${duration.toFixed(2)}초)`;
    overlay.title = `${fileName} (${duration.toFixed(2)}초)`;
    overlay.dataset.trackType = trackType;
    overlay.dataset.duration = String(duration);

    if (!overlay.dataset.selectionListenerAttached) {
        overlay.addEventListener('click', handleAudioOverlayClick);
        overlay.dataset.selectionListenerAttached = 'true';
    }

    updateAudioSelectionUI();

    console.log(`${trackType} 음성 클립이 타임라인에 표시되었습니다. 너비: ${clipWidth}px`);
}

// 파형 그리기
async function drawWaveform(file, trackType, duration) {
    const canvasId = trackType === 'audio' ? 'timeline-waveform' :
                     trackType === 'commentary' ? 'commentary-waveform' :
                     'bgm-waveform';

    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    // 줌 레벨에 따른 캔버스 너비 설정
    const zoomLevel = parseFloat(document.getElementById('timeline-zoom')?.value || 1);
    const pixelsPerSecond = 50 * zoomLevel;
    const calculatedWidth = duration * pixelsPerSecond;

    // 캔버스 실제 너비 설정 (canvas.width는 픽셀 단위)
    canvas.width = calculatedWidth;
    const height = canvas.height = 50;  // 고정 높이

    // CSS 스타일로도 너비 명시
    canvas.style.width = calculatedWidth + 'px';

    console.log(`[drawWaveform] ${trackType} - duration: ${duration}s, zoom: ${zoomLevel}, pixelsPerSecond: ${pixelsPerSecond}, width: ${calculatedWidth}px`);

    // 간단한 파형 표시 (실제 구현에서는 Web Audio API 사용)
    ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
    ctx.clearRect(0, 0, calculatedWidth, height);

    // 임시 파형 그리기
    for (let i = 0; i < calculatedWidth; i += 2) {
        const barHeight = Math.random() * height * 0.8;
        const y = (height - barHeight) / 2;
        ctx.fillRect(i, y, 1, barHeight);
    }

    console.log(`${trackType} 파형이 그려졌습니다. 너비: ${calculatedWidth}px`);
}

// 자막 파일 로드 처리
async function handleSubtitleFileLoad(file, trackType) {
    console.log(`${trackType} 자막 파일 로드:`, file.name);

    const reader = new FileReader();

    reader.onload = async function(e) {
        const content = e.target.result;
        parseSubtitle(content, trackType);

        // 파일명 저장 및 표시 업데이트
        loadedSubtitleFiles[trackType] = file.name;
        updateSubtitleFileDisplay();

        // 자막을 IndexedDB에 저장
        if (trackType === 'translation' || trackType === 'main' || trackType === 'description') {
            try {
                await saveFileToIndexedDB(`${trackType}-subtitle`, 'subtitle', file, {
                    fileName: file.name
                });
                const trackNames = {
                    main: '메인 자막',
                    translation: '주자막',
                    description: '보조자막'
                };
                console.log(`✅ ${trackNames[trackType]} 파일이 IndexedDB에 저장되었습니다.`);
            } catch (error) {
                console.error(`❌ ${trackNames[trackType]} 파일 저장 실패:`, error);
            }
        }

        console.log(`자막 파일 "${file.name}"이 ${trackType} 트랙에 로드되었습니다.`);
    };

    reader.readAsText(file);
}

// 자막 파싱
function parseSubtitle(content, trackType) {
    console.log(`${trackType} 자막 파싱 중...`);

    // SRT 형식 파싱 (간단한 구현)
    const subtitles = [];
    const blocks = content.trim().split('\n\n');

    blocks.forEach(block => {
        const lines = block.split('\n');
        if (lines.length >= 3) {
            const timeRegex = /(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/;
            const timeMatch = lines[1].match(timeRegex);
            if (timeMatch) {
                const text = lines.slice(2).join(' ');
                subtitles.push({
                    start: timeMatch[1],
                    end: timeMatch[2],
                    text: text
                });
            }
        }
    });

    console.log(`${trackType} 자막 파싱 완료:`, subtitles.length, '개');

    // 자막 데이터 저장
    loadedSubtitles[trackType] = subtitles;

    // TODO: 타임라인에 자막 블록 표시
    displaySubtitlesOnTimeline(subtitles, trackType);

    // 🎯 타임라인 자막 로드 시 제목/부제목 자동 숨김 (중복 방지)
    autoHideTitleSubtitleOnTimelineLoad(trackType);
}

// 타임라인 자막 로드 시 제목/부제목 자동 숨김 함수
function autoHideTitleSubtitleOnTimelineLoad(trackType) {
    // main, translation, description 트랙 중 하나라도 로드되면 제목/부제목 숨김
    if (trackType === 'main' || trackType === 'translation' || trackType === 'description') {
        console.log(`🙈 타임라인 자막(${trackType}) 로드됨 - 제목/부제목 자동 숨김 처리`);

        let needsCanvasUpdate = false;

        // 제목 숨기기 체크박스 자동 체크
        const hideTitleCheckbox = document.getElementById('hide-title-overlay');
        if (hideTitleCheckbox && !hideTitleCheckbox.checked) {
            hideTitleCheckbox.checked = true;
            // 체크박스 이벤트 수동 트리거
            const titleOverlay = document.getElementById('video-title-overlay');
            if (titleOverlay) {
                titleOverlay.style.display = 'none';
                console.log('  ✅ 제목 오버레이 숨김');
                needsCanvasUpdate = true;
            }
        }

        // 부제목 숨기기 체크박스 자동 체크
        const hideSubtitleCheckbox = document.getElementById('hide-subtitle-overlay');
        if (hideSubtitleCheckbox && !hideSubtitleCheckbox.checked) {
            hideSubtitleCheckbox.checked = true;
            // 체크박스 이벤트 수동 트리거
            const subtitleOverlay = document.getElementById('video-subtitle-overlay');
            if (subtitleOverlay) {
                subtitleOverlay.style.display = 'none';
                console.log('  ✅ 부제목 오버레이 숨김');
                needsCanvasUpdate = true;
            }
        }

        // Canvas 동기화
        if (needsCanvasUpdate && typeof updateCanvasText === 'function') {
            updateCanvasText();
            console.log('  🎨 Canvas 동기화 완료');
        }
    }
}

// SRT 시간 형식을 초 단위로 변환 (00:00:15,461 -> 15.461)
function srtTimeToSeconds(srtTime) {
    const parts = srtTime.split(':');
    const hours = parseInt(parts[0]);
    const minutes = parseInt(parts[1]);
    const secondsParts = parts[2].split(',');
    const seconds = parseInt(secondsParts[0]);
    const milliseconds = parseInt(secondsParts[1]);

    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
}

// 타임라인에 자막 표시
function displaySubtitlesOnTimeline(subtitles, trackType) {
    const contentId = `${trackType}-subtitle-content`;
    const content = document.getElementById(contentId);

    if (!content) return;

    // 기존 내용 제거
    content.innerHTML = '';

    // 줌 레벨 가져오기
    const zoomLevel = parseFloat(document.getElementById('timeline-zoom')?.value || 1);
    const pixelsPerSecond = 50 * zoomLevel; // 기본 50px/초 * 줌 레벨 (10초 = 500px)

    // 각 자막을 블록으로 표시
    subtitles.forEach((subtitle, index) => {
        // SRT 시간을 초 단위로 변환
        const startSeconds = srtTimeToSeconds(subtitle.start);
        const endSeconds = srtTimeToSeconds(subtitle.end);
        const durationSeconds = endSeconds - startSeconds;

        // 픽셀 단위로 위치와 너비 계산
        const leftPosition = startSeconds * pixelsPerSecond;
        const blockWidth = Math.max(durationSeconds * pixelsPerSecond, 40); // 최소 너비 40px

        const block = document.createElement('div');
        block.className = 'subtitle-block';
        block.style.cssText = `
            position: absolute;
            left: ${leftPosition}px;
            width: ${blockWidth}px;
            height: 40px;
            background: rgba(16, 185, 129, 0.3);
            border: 1px solid rgba(16, 185, 129, 0.5);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 4px;
        `;
        block.textContent = subtitle.text;
        block.title = `${subtitle.start} -> ${subtitle.end}\n${subtitle.text}`;

        content.appendChild(block);
    });

    console.log(`${trackType} 트랙에 ${subtitles.length}개의 자막 블록이 표시되었습니다 (실제 시간 기반)`);

    // Canvas 미리보기로 자막 데이터 전달
    updateCanvasSubtitles(trackType, subtitles);
}

// 모든 클립 크기 업데이트 (줌 레벨 변경 시)
function updateAllClipSizes() {
    console.log('타임라인 줌 변경 - 모든 클립 크기 업데이트 중...');

    // 가장 긴 미디어 길이 찾기
    let maxDuration = 0;
    if (loadedMedia.video) maxDuration = Math.max(maxDuration, loadedMedia.video.duration);
    if (loadedMedia.audio) maxDuration = Math.max(maxDuration, loadedMedia.audio.duration);
    if (loadedMedia.commentary) maxDuration = Math.max(maxDuration, loadedMedia.commentary.duration);
    if (loadedMedia.bgm) maxDuration = Math.max(maxDuration, loadedMedia.bgm.duration);

    // 줌 레벨에 따른 타임라인 전체 너비 계산
    const zoomLevel = parseFloat(document.getElementById('timeline-zoom')?.value || 1);
    const pixelsPerSecond = 50 * zoomLevel;
    const timelineWidth = Math.max(maxDuration * pixelsPerSecond, window.innerWidth - 200);

    // 타임라인 콘텐츠 너비 설정
    const timelineContent = document.getElementById('timeline-content');
    if (timelineContent) {
        timelineContent.style.minWidth = timelineWidth + 'px';
        console.log(`타임라인 너비 설정: ${timelineWidth}px (maxDuration: ${maxDuration}s, zoom: ${zoomLevel})`);
    }

    // 영상 클립 업데이트
    if (loadedMedia.video) {
        displayVideoClipOnTimeline(loadedMedia.video.fileName, loadedMedia.video.duration);
    }

    // 음성 클립 업데이트
    if (loadedMedia.audio) {
        displayAudioClipOnTimeline(loadedMedia.audio.fileName, loadedMedia.audio.duration, 'audio');
        drawWaveform(loadedMedia.audio.file, 'audio', loadedMedia.audio.duration);
    }

    // 해설 음성 클립 업데이트
    if (loadedMedia.commentary) {
        displayAudioClipOnTimeline(loadedMedia.commentary.fileName, loadedMedia.commentary.duration, 'commentary');
        drawWaveform(loadedMedia.commentary.file, 'commentary', loadedMedia.commentary.duration);
    }

    // 배경 음악 클립 업데이트
    if (loadedMedia.bgm) {
        displayAudioClipOnTimeline(loadedMedia.bgm.fileName, loadedMedia.bgm.duration, 'bgm');
        drawWaveform(loadedMedia.bgm.file, 'bgm', loadedMedia.bgm.duration);
    }

    console.log('모든 클립 크기 업데이트 완료');
    updateAudioSelectionUI();
}

function getAudioTrackCheckboxId(trackType) {
    switch (trackType) {
        case 'audio':
            return 'track-audio-enable';
        case 'commentary':
            return 'track-commentary-enable';
        case 'bgm':
            return 'track-bgm-enable';
        default:
            return null;
    }
}

function isAudioTrackEnabled(trackType) {
    const checkboxId = getAudioTrackCheckboxId(trackType);
    if (!checkboxId) {
        return true;
    }
    const checkbox = document.getElementById(checkboxId);
    return !checkbox || checkbox.checked;
}

function getAudioTracks(includeDisabled = false) {
    const tracks = [];
    AUDIO_TRACK_TYPES.forEach((trackType) => {
        const mediaInfo = loadedMedia[trackType];
        if (mediaInfo && mediaInfo.audioElement) {
            if (includeDisabled || isAudioTrackEnabled(trackType)) {
                tracks.push({ trackType, mediaInfo });
            }
        }
    });
    return tracks;
}

function pauseAllAudioTracks() {
    getAudioTracks(true).forEach(({ mediaInfo }) => {
        try {
            mediaInfo.audioElement.pause();
        } catch (error) {
            console.warn('오디오 일시정지 실패:', error);
        }
    });
}

function syncAudioTrackTimes(videoPlayer) {
    if (!videoPlayer) {
        return;
    }
    const currentTime = Number.isFinite(videoPlayer.currentTime) ? videoPlayer.currentTime : 0;
    getAudioTracks().forEach(({ mediaInfo }) => {
        const audioElement = mediaInfo.audioElement;
        if (!audioElement || Number.isNaN(currentTime)) {
            return;
        }
        if (Math.abs((audioElement.currentTime || 0) - currentTime) > 0.2) {
            try {
                audioElement.currentTime = currentTime;
            } catch (error) {
                console.warn('오디오 타임라인 동기화 실패:', error);
            }
        }
    });
}

function syncAudioTrackRate(videoPlayer) {
    if (!videoPlayer) {
        return;
    }
    const playbackRate = Number.isFinite(videoPlayer.playbackRate) ? videoPlayer.playbackRate : 1;
    getAudioTracks(true).forEach(({ mediaInfo }) => {
        const audioElement = mediaInfo.audioElement;
        if (audioElement) {
            audioElement.playbackRate = playbackRate;
        }
    });
}

function syncAudioTrackVolume(videoPlayer) {
    if (!videoPlayer) {
        return;
    }
    const baseVolume = videoPlayer.muted ? 0 : (Number.isFinite(videoPlayer.volume) ? videoPlayer.volume : 1);
    getAudioTracks(true).forEach(({ mediaInfo }) => {
        const audioElement = mediaInfo.audioElement;
        if (audioElement) {
            audioElement.volume = baseVolume;
        }
    });
}

function startAudioTracks(videoPlayer) {
    if (!videoPlayer) {
        return;
    }
    const currentTime = Number.isFinite(videoPlayer.currentTime) ? videoPlayer.currentTime : 0;
    const playbackRate = Number.isFinite(videoPlayer.playbackRate) ? videoPlayer.playbackRate : 1;
    const baseVolume = videoPlayer.muted ? 0 : (Number.isFinite(videoPlayer.volume) ? videoPlayer.volume : 1);

    getAudioTracks().forEach(({ mediaInfo }) => {
        const audioElement = mediaInfo.audioElement;
        if (!audioElement) {
            return;
        }
        if (Number.isFinite(currentTime) && Math.abs((audioElement.currentTime || 0) - currentTime) > 0.05) {
            try {
                audioElement.currentTime = currentTime;
            } catch (error) {
                console.warn('오디오 재생 위치 설정 실패:', error);
            }
        }
        audioElement.playbackRate = playbackRate;
        audioElement.volume = baseVolume;

        const playPromise = audioElement.play();
        if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch((error) => {
                console.warn('오디오 트랙 재생 실패:', error);
            });
        }
    });
}

function attachAudioTrackToggleListeners() {
    AUDIO_TRACK_TYPES.forEach((trackType) => {
        const checkboxId = getAudioTrackCheckboxId(trackType);
        if (!checkboxId) {
            return;
        }
        const checkbox = document.getElementById(checkboxId);
        if (!checkbox || checkbox.dataset.audioToggleAttached === 'true') {
            return;
        }
        checkbox.dataset.audioToggleAttached = 'true';
        checkbox.addEventListener('change', () => {
            const trackInfo = loadedMedia[trackType];
            if (!trackInfo || !trackInfo.audioElement) {
                return;
            }
            if (checkbox.checked) {
                const videoPlayer = document.getElementById('video-preview-player');
                if (videoPlayer && !videoPlayer.paused && !videoPlayer.ended) {
                    startAudioTracks(videoPlayer);
                }
            } else {
                try {
                    trackInfo.audioElement.pause();
                } catch (error) {
                    console.warn('오디오 트랙 일시정지 실패:', error);
                }
            }
        });
    });
}

function handleAudioOverlayClick(event) {
    const overlay = event.currentTarget;
    const trackType = overlay.dataset.trackType;
    const duration = parseFloat(overlay.dataset.duration || '0');
    if (!trackType || !duration) {
        return;
    }

    const rect = overlay.getBoundingClientRect();
    const offsetX = event.clientX - rect.left;
    const fraction = overlay.clientWidth > 0 ? Math.min(Math.max(offsetX / overlay.clientWidth, 0), 1) : 0;
    const time = fraction * duration;

    setAudioSelection(trackType, time);
}

function setAudioSelection(trackType, time) {
    if (!trackType || !Number.isFinite(time)) {
        return;
    }
    currentAudioSelection = {
        trackType,
        time: Math.max(0, time)
    };
    updateAudioSelectionUI();
}

function clearAudioSelection(trackType) {
    if (!currentAudioSelection) {
        updateAudioSelectionUI();
        return;
    }

    if (!trackType || currentAudioSelection.trackType === trackType) {
        currentAudioSelection = null;
        updateAudioSelectionUI();
    }
}

function getAudioTrackContentId(trackType) {
    switch (trackType) {
        case 'audio':
            return 'audio-track';
        case 'commentary':
            return 'commentary-audio-track';
        case 'bgm':
            return 'bgm-audio-track';
        default:
            return null;
    }
}

function formatSecondsWithMs(seconds) {
    const totalSeconds = Math.max(0, Number(seconds) || 0);
    const mins = Math.floor(totalSeconds / 60);
    const secs = Math.floor(totalSeconds % 60);
    const millis = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);
    return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
}

function updateAudioSelectionUI() {
    AUDIO_TRACK_TYPES.forEach((trackType) => {
        const trackContentId = getAudioTrackContentId(trackType);
        const trackElement = trackContentId ? document.getElementById(trackContentId) : null;
        const overlay = trackElement ? trackElement.querySelector('.audio-clip-overlay') : null;
        const infoEl = document.getElementById(`audio-selection-info-${trackType}`);
        let marker = trackElement ? trackElement.querySelector('.audio-selection-marker') : null;
        const deleteBtn = document.querySelector(`[data-audio-action="delete-from-selection"][data-track="${trackType}"]`);

        if (!currentAudioSelection || currentAudioSelection.trackType !== trackType || !overlay || !overlay.clientWidth) {
            if (marker) {
                marker.remove();
            }
            if (infoEl) {
                infoEl.textContent = '선택 위치: 없음';
            }
            if (deleteBtn) {
                deleteBtn.disabled = true;
            }
            return;
        }

        const duration = parseFloat(overlay.dataset.duration || `${loadedMedia[trackType]?.duration || 0}`);
        if (!duration) {
            if (marker) {
                marker.remove();
            }
            if (infoEl) {
                infoEl.textContent = '선택 위치: 없음';
            }
            if (deleteBtn) {
                deleteBtn.disabled = true;
            }
            return;
        }

        const fraction = Math.min(Math.max(currentAudioSelection.time / duration, 0), 1);
        const left = fraction * overlay.clientWidth;

        if (!marker) {
            marker = document.createElement('div');
            marker.className = 'audio-selection-marker';
            trackElement.appendChild(marker);
        }

        marker.style.left = `${left}px`;

        if (infoEl) {
            infoEl.textContent = `선택 위치: ${formatSecondsWithMs(currentAudioSelection.time)} / ${formatSecondsWithMs(duration)}`;
        }

        if (deleteBtn) {
            deleteBtn.disabled = false;
        }
    });
}

function initAudioSync() {
    if (audioSyncInitialized) {
        attachAudioTrackToggleListeners();
        return;
    }
    const videoPlayer = document.getElementById('video-preview-player');
    if (!videoPlayer) {
        return;
    }

    videoPlayer.addEventListener('play', () => {
        startAudioTracks(videoPlayer);
    });

    videoPlayer.addEventListener('pause', () => {
        pauseAllAudioTracks();
    });

    videoPlayer.addEventListener('ended', () => {
        pauseAllAudioTracks();
    });

    videoPlayer.addEventListener('seeking', () => {
        pauseAllAudioTracks();
    });

    videoPlayer.addEventListener('seeked', () => {
        syncAudioTrackTimes(videoPlayer);
        if (!videoPlayer.paused && !videoPlayer.ended) {
            startAudioTracks(videoPlayer);
        }
    });

    videoPlayer.addEventListener('timeupdate', () => {
        if (!videoPlayer.paused && !videoPlayer.ended) {
            syncAudioTrackTimes(videoPlayer);
        }
    });

    videoPlayer.addEventListener('ratechange', () => {
        syncAudioTrackRate(videoPlayer);
    });

    videoPlayer.addEventListener('volumechange', () => {
        syncAudioTrackVolume(videoPlayer);
    });

    attachAudioTrackToggleListeners();
    audioSyncInitialized = true;
}

function getAudioTrackDisplayName(trackType) {
    const names = {
        audio: '음성',
        commentary: '해설 음성',
        bgm: '배경 음악'
    };
    return names[trackType] || trackType;
}

async function decodeAudioFileToBuffer(file) {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) {
        throw new Error('이 브라우저에서는 오디오 편집을 지원하지 않습니다.');
    }

    const arrayBuffer = await file.arrayBuffer();
    const audioCtx = new AudioCtx();
    try {
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        return audioBuffer;
    } finally {
        if (typeof audioCtx.close === 'function') {
            try {
                await audioCtx.close();
            } catch (closeError) {
                console.warn('AudioContext 종료 실패:', closeError);
            }
        }
    }
}

function audioBufferToWav(buffer) {
    const numOfChan = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;
    const channelData = [];

    for (let channel = 0; channel < numOfChan; channel++) {
        channelData.push(buffer.getChannelData(channel));
    }

    const interleaved = interleaveChannelData(channelData);

    const bufferLength = interleaved.length * (bitDepth / 8);
    const wavBuffer = new ArrayBuffer(44 + bufferLength);
    const view = new DataView(wavBuffer);

    // RIFF chunk descriptor
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + bufferLength, true);
    writeString(view, 8, 'WAVE');

    // FMT sub-chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // SubChunk1Size
    view.setUint16(20, format, true); // PCM
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numOfChan * (bitDepth / 8), true); // ByteRate
    view.setUint16(32, numOfChan * (bitDepth / 8), true); // BlockAlign
    view.setUint16(34, bitDepth, true);

    // data sub-chunk
    writeString(view, 36, 'data');
    view.setUint32(40, bufferLength, true);

    // Write PCM samples
    let offset = 44;
    for (let i = 0; i < interleaved.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, interleaved[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }

    return wavBuffer;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

function interleaveChannelData(channels) {
    const length = channels[0].length;
    const numChannels = channels.length;
    const interleaved = new Float32Array(length * numChannels);

    let writeIndex = 0;
    for (let i = 0; i < length; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
            interleaved[writeIndex++] = channels[channel][i];
        }
    }
    return interleaved;
}

async function trimAudioSegment(trackType, startSec, endSec, options = {}) {
    const mediaInfo = loadedMedia[trackType];
    if (!mediaInfo || !mediaInfo.file) {
        alert(`먼저 ${getAudioTrackDisplayName(trackType)} 트랙에 오디오를 로드해주세요.`);
        return;
    }

    try {
        const audioBuffer = await decodeAudioFileToBuffer(mediaInfo.file);
        const sampleRate = audioBuffer.sampleRate;
        const duration = audioBuffer.duration;

        const clampedStart = Math.max(0, Math.min(startSec, duration));
        const clampedEnd = Math.max(clampedStart, Math.min(endSec, duration));

        if (clampedEnd - clampedStart < 0.05) {
            alert('편집하려는 구간이 너무 짧습니다. 조금 더 긴 구간을 선택해주세요.');
            return;
        }

        const startSample = Math.floor(clampedStart * sampleRate);
        const endSample = Math.floor(clampedEnd * sampleRate);
        const frameCount = endSample - startSample;

        let editedBuffer;
        if (typeof AudioBuffer === 'function') {
            editedBuffer = new AudioBuffer({
                length: frameCount,
                numberOfChannels: audioBuffer.numberOfChannels,
                sampleRate
            });
        } else {
            const TempCtx = window.AudioContext || window.webkitAudioContext;
            if (!TempCtx) {
                throw new Error('오디오 편집을 위한 AudioBuffer를 생성할 수 없습니다.');
            }
            const tempCtx = new TempCtx();
            try {
                editedBuffer = tempCtx.createBuffer(audioBuffer.numberOfChannels, frameCount, sampleRate);
            } finally {
                if (typeof tempCtx.close === 'function') {
                    tempCtx.close();
                }
            }
        }

        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
            const sourceData = audioBuffer.getChannelData(channel).subarray(startSample, endSample);
            editedBuffer.copyToChannel(sourceData, channel, 0);
        }

        const wavArrayBuffer = audioBufferToWav(editedBuffer);
        const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });

        const baseName = (mediaInfo.fileName || mediaInfo.file.name || `${trackType}_audio`).replace(/\.[^.]+$/, '');
        const suffix = options.nameSuffix || 'edited';
        const newFileName = `${baseName}_${suffix}.wav`;
        const editedFile = new File([blob], newFileName, { type: 'audio/wav' });

        await handleAudioFileLoad(editedFile, trackType, { silent: true, skipAlert: true });
        clearAudioSelection(trackType);
        updateAudioSelectionUI();

        if (!options.skipAlert) {
            const message = options.successMessage || '오디오가 편집되었습니다.';
            alert(message);
        }

        return {
            file: editedFile,
            duration: editedBuffer.length / sampleRate
        };
    } catch (error) {
        console.error('오디오 편집 실패:', error);
        if (!options.skipAlert) {
            alert(`❌ 오디오 편집 중 오류가 발생했습니다.\n\n${error.message || error}`);
        }
        throw error;
    }
}

async function trimAudioToVideoLength(trackType) {
    const videoInfo = loadedMedia.video;
    if (!videoInfo || !videoInfo.duration) {
        alert('먼저 영상을 로드해주세요.');
        return;
    }

    const mediaInfo = loadedMedia[trackType];
    if (!mediaInfo || !mediaInfo.duration) {
        alert(`먼저 ${getAudioTrackDisplayName(trackType)} 트랙에 오디오를 로드해주세요.`);
        return;
    }

    if (mediaInfo.duration <= videoInfo.duration + 0.05) {
        alert('이미 영상 길이와 같거나 더 짧은 오디오입니다.');
        return;
    }

    const displayName = getAudioTrackDisplayName(trackType);
    await trimAudioSegment(trackType, 0, videoInfo.duration, {
        nameSuffix: 'trimmed',
        successMessage: `${displayName} 트랙을 영상 길이(${formatSecondsWithMs(videoInfo.duration)})에 맞춰 잘랐습니다.`
    });
}

async function deleteAudioFromSelection(trackType) {
    if (!currentAudioSelection || currentAudioSelection.trackType !== trackType) {
        alert('먼저 타임라인에서 삭제할 위치를 클릭하여 선택해주세요.');
        return;
    }

    const mediaInfo = loadedMedia[trackType];
    if (!mediaInfo || !mediaInfo.duration) {
        alert(`먼저 ${getAudioTrackDisplayName(trackType)} 트랙에 오디오를 로드해주세요.`);
        return;
    }

    const targetTime = Math.max(0, Math.min(currentAudioSelection.time, mediaInfo.duration));

    if (targetTime <= 0.1) {
        if (confirm('선택 위치가 0초에 가깝습니다. 전체 오디오를 삭제하시겠습니까?')) {
            clearMediaTrack(trackType);
        }
        return;
    }

    const displayName = getAudioTrackDisplayName(trackType);
    await trimAudioSegment(trackType, 0, targetTime, {
        nameSuffix: 'cut',
        successMessage: `${displayName} 트랙의 ${formatSecondsWithMs(targetTime)} 이후 구간을 삭제했습니다.`
    });
}

// 주자막 언어 선택 다이얼로그 표시
function showTranslationDialog() {
    // 메인 자막이 로드되어 있는지 확인
    if (!loadedSubtitles.main || loadedSubtitles.main.length === 0) {
        alert('⚠️ 메인 자막을 먼저 타임라인에 로드해주세요.\n\n타임라인의 "📝 메인 자막" 트랙에서 📂 버튼을 클릭하여 자막 파일을 로드하세요.');
        return;
    }

    // 다이얼로그 생성
    const dialog = document.createElement('div');
    dialog.id = 'translation-lang-dialog';
    dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.2s ease-out;
    `;

    dialog.innerHTML = `
        <div style="background: #1e293b; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);">
            <h3 style="margin: 0 0 20px 0; color: #10b981; font-size: 24px;">🌐 주자막 추출</h3>
            <p style="margin: 0 0 20px 0; color: #94a3b8; line-height: 1.6;">
                메인 자막 <strong style="color: #10b981;">${loadedSubtitles.main.length}개</strong>를 AI로 번역하여<br>
                주자막 트랙에 자동으로 추가합니다.
            </p>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; color: #e2e8f0; font-weight: 600;">번역할 언어 선택</label>
                <select id="dialog-translation-lang" style="width: 100%; padding: 12px 16px; border: 2px solid #4a5568; border-radius: 8px; background: #0f172a; color: #e2e8f0; font-size: 16px; cursor: pointer;">
                    <option value="en">🇺🇸 영어 (English)</option>
                    <option value="ja">🇯🇵 일본어 (日本語)</option>
                    <option value="zh">🇨🇳 중국어 (中文)</option>
                    <option value="es">🇪🇸 스페인어 (Español)</option>
                    <option value="fr">🇫🇷 프랑스어 (Français)</option>
                    <option value="de">🇩🇪 독일어 (Deutsch)</option>
                    <option value="vi">🇻🇳 베트남어 (Tiếng Việt)</option>
                    <option value="th">🇹🇭 태국어 (ภาษาไทย)</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="startTranslation()" class="btn-primary" style="flex: 1; padding: 12px; background: #10b981; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer;">
                    🚀 번역 시작
                </button>
                <button onclick="closeTranslationDialog()" class="btn-secondary" style="flex: 1; padding: 12px; background: #64748b; font-size: 16px; font-weight: 600; border-radius: 8px; cursor: pointer;">
                    취소
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(dialog);
}

// 다이얼로그 닫기
function closeTranslationDialog() {
    const dialog = document.getElementById('translation-lang-dialog');
    if (dialog) {
        dialog.remove();
    }
}

// 번역 시작
function startTranslation() {
    const targetLang = document.getElementById('dialog-translation-lang')?.value;
    closeTranslationDialog();
    extractTranslationSubtitles(targetLang);
}

// 주자막 추출 함수
async function extractTranslationSubtitles(targetLang = 'en') {
    console.log('🌐 주자막 추출 시작...');

    // 1. 메인 자막이 로드되어 있는지 확인
    if (!loadedSubtitles.main || loadedSubtitles.main.length === 0) {
        alert('⚠️ 메인 자막을 먼저 로드해주세요.');
        return;
    }

    // 2. 언어 이름 매핑
    const langNames = {
        'en': '영어',
        'ja': '일본어',
        'zh': '중국어',
        'es': '스페인어',
        'fr': '프랑스어',
        'de': '독일어',
        'vi': '베트남어',
        'th': '태국어'
    };

    console.log(`📝 메인 자막 ${loadedSubtitles.main.length}개를 ${langNames[targetLang]}로 번역 중...`);

    // 로딩 메시지 표시
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'translation-loading';
    loadingDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px 50px;
        border-radius: 12px;
        z-index: 10000;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    `;
    loadingDiv.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px;">🌐</div>
        <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">번역 중...</div>
        <div style="font-size: 14px; color: #94a3b8;">자막 ${loadedSubtitles.main.length}개를 ${langNames[targetLang]}로 번역하고 있습니다</div>
        <div style="margin-top: 15px;">
            <div class="spinner" style="border: 3px solid rgba(255, 255, 255, 0.3); border-top: 3px solid #10b981; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
        </div>
    `;
    document.body.appendChild(loadingDiv);

    try {
        // 3. 백엔드 API 호출
        const response = await fetch('/api/video-analyzer/translate-subtitles', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                subtitles: loadedSubtitles.main,
                target_lang: targetLang
            })
        });

        if (!response.ok) {
            throw new Error(`번역 API 오류: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ 번역 완료:', result);

        // 4. 번역된 자막을 주자막 트랙에 표시
        if (result.translated_subtitles && result.translated_subtitles.length > 0) {
            // 자막 데이터 저장
            loadedSubtitles.translation = result.translated_subtitles;

            // 타임라인에 표시
            displaySubtitlesOnTimeline(result.translated_subtitles, 'translation');

            // SRT 형식으로 변환
            const srtContent = convertToSRT(result.translated_subtitles);

            // 5. IndexedDB에 저장 (Blob으로 변환)
            const blob = new Blob([srtContent], { type: 'text/plain' });
            const file = new File([blob], `translated_${targetLang}.srt`, { type: 'text/plain' });

            try {
                await saveFileToIndexedDB('translation-subtitle', 'subtitle', file, {
                    fileName: file.name,
                    targetLang: targetLang
                });
                console.log('✅ 주자막이 IndexedDB에 저장되었습니다.');
            } catch (error) {
                console.error('❌ IndexedDB 저장 실패:', error);
            }

            // 비디오 플레이어에 주자막 트랙 로드
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer) {
                const translationTrack = document.getElementById('video-translation-track');
                if (translationTrack) {
                    const blobUrl = URL.createObjectURL(blob);
                    translationTrack.src = blobUrl;

                    // 기존 트랙 비활성화
                    for (let i = 0; i < videoPlayer.textTracks.length; i++) {
                        videoPlayer.textTracks[i].mode = 'hidden';
                    }

                    // 번역 트랙 활성화
                    const track = translationTrack.track;
                    if (track) {
                        track.mode = 'showing';
                        console.log('✅ 주자막 트랙이 활성화되었습니다.');
                    }
                }
            }

            // 성공 메시지
            loadingDiv.remove();

            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 20px 30px;
                border-radius: 8px;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
                animation: slideInRight 0.3s ease-out;
            `;
            successDiv.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 8px;">✅</div>
                <div style="font-weight: bold; margin-bottom: 5px;">번역 완료!</div>
                <div style="font-size: 12px; opacity: 0.9;">${result.translated_subtitles.length}개의 자막이 ${langNames[targetLang]}로 번역되었습니다</div>
            `;
            document.body.appendChild(successDiv);
            setTimeout(() => successDiv.remove(), 5000);

        } else {
            throw new Error('번역 결과가 비어있습니다.');
        }

    } catch (error) {
        console.error('❌ 번역 실패:', error);
        loadingDiv.remove();
        alert(`❌ 번역 중 오류가 발생했습니다.\n\n${error.message}`);
    }
}

// 자막 배열을 SRT 형식으로 변환
function convertToSRT(subtitles) {
    let srtContent = '';

    subtitles.forEach((subtitle, index) => {
        srtContent += `${index + 1}\n`;
        srtContent += `${subtitle.start} --> ${subtitle.end}\n`;
        srtContent += `${subtitle.text}\n\n`;
    });

    return srtContent;
}

// 트랙 비우기 기능
function clearTrack(trackType) {
    console.log(`🗑️ 트랙 비우기: ${trackType}`);

    const trackNames = {
        main: '메인 자막',
        translation: '주자막',
        description: '보조자막'
    };

    // 확인 대화상자 표시
    if (!confirm(`${trackNames[trackType]} 트랙의 모든 자막을 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
        return;
    }

    // 트랙 컨텐츠 영역 가져오기
    const trackContent = document.getElementById(`${trackType}-subtitle-content`);
    if (trackContent) {
        // 모든 자막 블록 제거
        trackContent.innerHTML = '';
        console.log(`✅ ${trackNames[trackType]} 트랙이 비워졌습니다.`);

        // 로드된 자막 데이터에서도 제거
        if (loadedSubtitles[trackType]) {
            loadedSubtitles[trackType] = [];
        }

        // 파일명도 초기화 및 표시 업데이트
        loadedSubtitleFiles[trackType] = null;
        updateSubtitleFileDisplay();
    }
}

// 미디어 트랙 비우기 기능
function clearMediaTrack(trackType) {
    console.log(`🗑️ 미디어 트랙 비우기: ${trackType}`);

    const trackNames = {
        video: '영상',
        audio: '음성',
        commentary: '해설 음성',
        bgm: '배경 음악'
    };

    // 확인 대화상자 표시
    if (!confirm(`${trackNames[trackType]} 트랙을 비우시겠습니까?\n\n로드된 파일이 제거됩니다.`)) {
        return;
    }

    clearAudioSelection(trackType);

    // 로드된 미디어 데이터 초기화
    if (loadedMedia[trackType]) {
        const mediaInfo = loadedMedia[trackType];
        if (mediaInfo && mediaInfo.audioElement) {
            try {
                mediaInfo.audioElement.pause();
            } catch (error) {
                console.warn('오디오 트랙 일시정지 실패:', error);
            }
        }
        if (mediaInfo && mediaInfo.objectUrl) {
            URL.revokeObjectURL(mediaInfo.objectUrl);
        }
        loadedMedia[trackType] = null;
    }

    // 트랙별 UI 초기화
    if (trackType === 'video') {
        // 영상 트랙 초기화
        const videoTrack = document.getElementById('video-track');
        if (videoTrack) {
            videoTrack.innerHTML = '';
        }
        // 비디오 플레이어 초기화
        const videoPlayer = document.getElementById('video-preview-player');
        if (videoPlayer) {
            videoPlayer.src = '';
            videoPlayer.load();
            pauseAllAudioTracks();
        }
    } else {
        // 오디오 트랙 초기화 (audio, commentary, bgm)
        const canvasId = trackType === 'audio' ? 'timeline-waveform' :
                        trackType === 'commentary' ? 'commentary-waveform' :
                        'bgm-waveform';
        const canvas = document.getElementById(canvasId);
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        const trackId = trackType === 'audio' ? 'audio-track' :
                        trackType === 'commentary' ? 'commentary-audio-track' :
                        'bgm-audio-track';
        const audioTrack = document.getElementById(trackId);
        if (audioTrack) {
            const overlay = audioTrack.querySelector('.audio-clip-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        pauseAllAudioTracks();
    }

    console.log(`✅ ${trackNames[trackType]} 트랙이 비워졌습니다.`);
}

// 트랙 비우기 버튼 이벤트 리스너 설정
document.addEventListener('DOMContentLoaded', () => {
    ['main', 'translation', 'description'].forEach(trackType => {
        const clearBtn = document.querySelector(`.track-clear[data-track="${trackType}"]`);
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                clearTrack(trackType);
            });
        }
    });
});

// ==================== 자막 템플릿 컨트롤 ====================
function toggleBannerControls() {
    const template = document.querySelector('input[name="subtitle-template-video"]:checked')?.value;
    const bannerControls = document.getElementById('banner-controls-video');

    if (template === 'banner') {
        bannerControls.style.display = 'block';
    } else {
        bannerControls.style.display = 'none';
    }

    // 선택된 라디오 버튼의 label 스타일 업데이트
    document.querySelectorAll('input[name="subtitle-template-video"]').forEach(radio => {
        const label = radio.closest('label');
        if (radio.checked) {
            label.style.borderColor = 'rgba(74, 158, 255, 1)';
            label.style.background = 'rgba(74, 158, 255, 0.1)';
        } else {
            label.style.borderColor = 'transparent';
            label.style.background = 'rgba(42, 46, 62, 0.8)';
        }
    });
}

// 페이지 로드 시 초기화
document.addEventListener('DOMContentLoaded', () => {
    toggleBannerControls();
});

// ==================== 패널 토글 기능 ====================
function toggleBrowserPanel() {
    const content = document.getElementById('browser-panel-content');
    const toggle = document.getElementById('browser-panel-toggle');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        toggle.textContent = '▼';
        toggle.style.transform = 'rotate(0deg)';
    } else {
        content.style.display = 'none';
        toggle.textContent = '▶';
        toggle.style.transform = 'rotate(-90deg)';
    }
}

function togglePerformancePanel() {
    const content = document.getElementById('performance-panel-content');
    const toggle = document.getElementById('performance-panel-toggle');

    if (content.style.display === 'none') {
        content.style.display = 'block';
        toggle.textContent = '▼';
        toggle.style.transform = 'rotate(0deg)';
    } else {
        content.style.display = 'none';
        toggle.textContent = '▶';
        toggle.style.transform = 'rotate(-90deg)';
    }
}

// ==================== 성능 대시보드 ====================
function showPerformanceReport() {
    const resultsDiv = document.getElementById('performance-dashboard-results');

    try {
        if (!window.performanceMonitor) {
            throw new Error('Performance Monitor가 로드되지 않았습니다.');
        }

        const reportHTML = window.performanceMonitor.generateHTMLReport();
        resultsDiv.innerHTML = reportHTML;
        resultsDiv.style.display = 'block';

        // 콘솔에도 출력
        window.performanceMonitor.printReport();

        console.log('📊 성능 대시보드 업데이트 완료');
    } catch (error) {
        console.error('성능 리포트 생성 중 오류:', error);
        resultsDiv.innerHTML = `
            <div style="padding: 15px; background: rgba(255, 68, 68, 0.1); border: 1px solid #ff4444; border-radius: 6px; color: #ff4444;">
                <strong>⚠️ 리포트 생성 실패</strong>
                <p style="margin: 5px 0 0 0; font-size: 0.9rem;">${error.message}</p>
            </div>
        `;
        resultsDiv.style.display = 'block';
    }
}

function clearPerformanceData() {
    if (confirm('모든 성능 측정 데이터를 초기화하시겠습니까?')) {
        window.performanceMonitor.clear();
        const resultsDiv = document.getElementById('performance-dashboard-results');
        resultsDiv.style.display = 'none';
        console.log('✨ 성능 데이터 초기화 완료');
    }
}

// ==================== 브라우저 진단 ====================
let browserCapChecker = null;

async function runBrowserDiagnostics() {
    const resultsDiv = document.getElementById('browser-diagnostic-results');
    const button = event.target;

    // 버튼 비활성화 및 로딩 표시
    button.disabled = true;
    button.textContent = '진단 중...';

    try {
        // BrowserCapabilities 인스턴스 생성
        if (!browserCapChecker) {
            browserCapChecker = new BrowserCapabilities();
        }

        // 진단 실행
        const capabilities = await browserCapChecker.checkAll();

        // 결과 표시
        resultsDiv.innerHTML = browserCapChecker.formatAsHTML();
        resultsDiv.style.display = 'block';

        // 콘솔에도 출력
        browserCapChecker.printToConsole();

        console.log('🔍 브라우저 기능 진단 완료:', capabilities);
    } catch (error) {
        console.error('브라우저 진단 중 오류:', error);
        resultsDiv.innerHTML = `
            <div style="padding: 15px; background: rgba(255, 68, 68, 0.1); border: 1px solid #ff4444; border-radius: 6px; color: #ff4444;">
                <strong>⚠️ 진단 실패</strong>
                <p style="margin: 5px 0 0 0; font-size: 0.9rem;">${error.message}</p>
            </div>
        `;
        resultsDiv.style.display = 'block';
    } finally {
        // 버튼 복구
        button.disabled = false;
        button.textContent = '진단 재실행';
    }
}

</script>

<!-- 브라우저 기능 탐지 스크립트 로드 -->
<script src="/static/browser-capabilities.js"></script>

<!-- 성능 모니터링 스크립트 로드 -->
<script src="/static/performance-monitor.js"></script>

<!-- MP4Box.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>

<!-- MP4 분석기 스크립트 로드 -->
<script src="/static/mp4-analyzer.js"></script>

<!-- Canvas 미리보기 스크립트 로드 -->
<script src="/static/canvas-preview.js"></script>

<!-- 해상도 선택 기능 -->
<script>
// 현재 해상도 설정
let currentResolution = {
    width: 1920,
    height: 1080,
    aspectRatio: '16:9',
    name: 'youtube'
};

// 해상도 프리셋
const resolutionPresets = {
    youtube: { width: 1920, height: 1080, aspectRatio: '16:9', name: '유튜브' },
    shorts: { width: 1080, height: 1920, aspectRatio: '9:16', name: '쇼츠' },
    '4k': { width: 3840, height: 2160, aspectRatio: '16:9', name: '4K' }
};

// 해상도 설정 함수
function setPreviewResolution(preset) {
    // 버튼 활성화 상태 업데이트
    document.querySelectorAll('[id^="btn-"][id$="-res"]').forEach(btn => {
        btn.style.opacity = '0.6';
        btn.style.transform = 'scale(1)';
    });

    if (preset === 'custom') {
        // 커스텀 해상도 입력 표시
        document.getElementById('custom-resolution-input').style.display = 'block';
        document.getElementById('btn-custom-res').style.opacity = '1';
        document.getElementById('btn-custom-res').style.transform = 'scale(1.05)';
        return;
    } else {
        // 커스텀 입력 숨김
        document.getElementById('custom-resolution-input').style.display = 'none';
    }

    // 선택된 버튼 강조
    const selectedBtn = document.getElementById(`btn-${preset}-res`);
    if (selectedBtn) {
        selectedBtn.style.opacity = '1';
        selectedBtn.style.transform = 'scale(1.05)';
    }

    // 해상도 적용
    const resolution = resolutionPresets[preset];
    if (resolution) {
        currentResolution = { ...resolution, name: preset };
        applyResolutionToPreview(resolution.width, resolution.height);
        updateResolutionDisplay(`${resolution.width}×${resolution.height} (${resolution.aspectRatio})`);
        console.log(`📐 해상도 변경: ${resolution.name} ${resolution.width}×${resolution.height}`);
    }
}

// 커스텀 해상도 적용
function applyCustomResolution() {
    const width = parseInt(document.getElementById('custom-width').value);
    const height = parseInt(document.getElementById('custom-height').value);

    if (!width || !height || width < 320 || height < 240) {
        alert('⚠️ 올바른 해상도를 입력하세요. (최소 320×240)');
        return;
    }

    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    const divisor = gcd(width, height);
    const aspectRatio = `${width / divisor}:${height / divisor}`;

    currentResolution = { width, height, aspectRatio, name: 'custom' };
    applyResolutionToPreview(width, height);
    updateResolutionDisplay(`${width}×${height} (${aspectRatio})`);
    console.log(`📐 커스텀 해상도 적용: ${width}×${height} (${aspectRatio})`);
}

// 미리보기에 해상도 적용
function applyResolutionToPreview(width, height) {
    const canvas = document.getElementById('video-canvas-preview');
    const video = document.getElementById('video-preview-player');
    const wrapper = document.querySelector('.video-subtitle-wrapper');

    if (canvas && video) {
        // Canvas 크기 설정
        canvas.width = width;
        canvas.height = height;

        // 비디오 컨테이너 최대 크기 설정 (화면 크기에 맞게 스케일링)
        const maxWidth = 800;
        const scale = Math.min(1, maxWidth / width);
        const displayWidth = width * scale;
        const displayHeight = height * scale;

        if (wrapper) {
            wrapper.style.width = displayWidth + 'px';
            wrapper.style.height = displayHeight + 'px';
        }

        // Canvas 렌더링
        if (canvasPreview) {
            canvasPreview.render();
            syncOverlaysToCanvas();
        }
    }
}

// 해상도 표시 업데이트
function updateResolutionDisplay(text) {
    const display = document.getElementById('current-res-text');
    if (display) {
        display.textContent = text;
    }
}
</script>

<!-- Canvas 미리보기 초기화 -->
<script>
// 전역 Canvas 미리보기 인스턴스
let canvasPreview = null;

// Canvas 미리보기 활성화/비활성화
function toggleCanvasPreview(enabled) {
    const canvas = document.getElementById('video-canvas-preview');
    const videoPlayer = document.getElementById('video-preview-player');
    const cssOverlays = document.querySelectorAll('.video-text-overlay, #top-black-bar, #bottom-black-bar');

    if (enabled) {
        // Canvas 표시, CSS 오버레이 숨김
        canvas.style.display = 'block';
        cssOverlays.forEach(el => el.style.opacity = '0.3'); // 참고용으로 반투명하게 유지

        // Canvas 미리보기 초기화
        if (!canvasPreview) {
            canvasPreview = new CanvasVideoPreview('video-canvas-preview', 'video-preview-player');
            console.log('✅ Canvas 미리보기 활성화됨');
        }
    } else {
        // Canvas 숨김, CSS 오버레이 표시
        canvas.style.display = 'none';
        cssOverlays.forEach(el => el.style.opacity = '1');
        console.log('📺 CSS 오버레이 모드');
    }
}

// 비디오 로드 시 Canvas 자동 초기화
document.addEventListener('DOMContentLoaded', () => {
    const videoPlayer = document.getElementById('video-preview-player');

    // 기본 해상도 버튼 활성화 (유튜브)
    const youtubeBtn = document.getElementById('btn-youtube-res');
    if (youtubeBtn) {
        youtubeBtn.style.opacity = '1';
        youtubeBtn.style.transform = 'scale(1.05)';
    }

    videoPlayer.addEventListener('loadedmetadata', () => {
        // 기본적으로 Canvas 미리보기 활성화
        toggleCanvasPreview(true);

        // 현재 설정된 해상도로 Canvas 크기 설정
        applyResolutionToPreview(currentResolution.width, currentResolution.height);

        // 검정 배경 초기값 설정 (예시)
        if (canvasPreview) {
            canvasPreview.setBlackBars(
                { enabled: false, height: 15, opacity: 0.8 }, // 상단
                { enabled: false, height: 15, opacity: 0.8 }  // 하단
            );
        }
    });

    // 타임라인 자막 체크박스 이벤트 리스너
    const mainSubtitleCheckbox = document.getElementById('track-main-subtitle-enable');
    const translationSubtitleCheckbox = document.getElementById('track-translation-subtitle-enable');
    const descriptionSubtitleCheckbox = document.getElementById('track-description-subtitle-enable');

    if (mainSubtitleCheckbox) {
        mainSubtitleCheckbox.addEventListener('change', (e) => {
            if (canvasPreview) {
                canvasPreview.setSubtitleEnabled('main', e.target.checked);
            }
            // 즉시 오버레이 업데이트
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && typeof updateSubtitleOverlaysFromTimeline === 'function') {
                updateSubtitleOverlaysFromTimeline(videoPlayer.currentTime);
            }
        });
    }

    if (translationSubtitleCheckbox) {
        translationSubtitleCheckbox.addEventListener('change', (e) => {
            if (canvasPreview) {
                canvasPreview.setSubtitleEnabled('translation', e.target.checked);
            }
            // 즉시 오버레이 업데이트
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && typeof updateSubtitleOverlaysFromTimeline === 'function') {
                updateSubtitleOverlaysFromTimeline(videoPlayer.currentTime);
            }
        });
    }

    if (descriptionSubtitleCheckbox) {
        descriptionSubtitleCheckbox.addEventListener('change', (e) => {
            if (canvasPreview) {
                canvasPreview.setSubtitleEnabled('description', e.target.checked);
            }
            // 즉시 오버레이 업데이트
            const videoPlayer = document.getElementById('video-preview-player');
            if (videoPlayer && typeof updateSubtitleOverlaysFromTimeline === 'function') {
                updateSubtitleOverlaysFromTimeline(videoPlayer.currentTime);
            }
        });
    }
});

// 텍스트 오버레이를 Canvas에 동기화하는 함수
function syncOverlaysToCanvas() {
    if (!canvasPreview) return;

    const titleOverlay = document.getElementById('video-title-overlay');
    const subtitleOverlay = document.getElementById('video-subtitle-overlay');
    const koreanOverlay = document.getElementById('korean-subtitle-overlay');
    const englishOverlay = document.getElementById('english-subtitle-overlay');

    canvasPreview.clearOverlays();

    // 제목 오버레이
    if (titleOverlay && titleOverlay.style.display !== 'none' && titleOverlay.textContent.trim() !== '영상 제목을 입력하세요') {
        const titleStyle = window.getComputedStyle(titleOverlay);
        const fontSize = parseInt(titleStyle.fontSize) || 48;

        canvasPreview.addOverlay({
            text: titleOverlay.textContent.trim(),
            x: canvasPreview.canvas.width / 2,
            y: canvasPreview.canvas.height * 0.5, // 50% 위치 (중앙)
            fontSize: fontSize,
            color: titleStyle.color || '#ffffff',
            borderWidth: 4,
            borderColor: '#000000',
            type: 'title'  // ⭐ type 추가
        });
    }

    // 부제목 오버레이
    if (subtitleOverlay && subtitleOverlay.style.display !== 'none' && subtitleOverlay.textContent.trim() !== '부제목을 입력하세요') {
        const subtitleStyle = window.getComputedStyle(subtitleOverlay);
        const fontSize = parseInt(subtitleStyle.fontSize) || 32;

        canvasPreview.addOverlay({
            text: subtitleOverlay.textContent.trim(),
            x: canvasPreview.canvas.width / 2,
            y: canvasPreview.canvas.height * 0.9, // 90% 위치
            fontSize: fontSize,
            color: subtitleStyle.color || '#ffe14d',
            borderWidth: 3,
            borderColor: '#000000',
            type: 'subtitle'  // ⭐ type 추가
        });
    }

    // 주자막 (Korean) 오버레이
    if (koreanOverlay && koreanOverlay.style.display !== 'none' && !koreanOverlay.classList.contains('empty')) {
        const koreanStyle = window.getComputedStyle(koreanOverlay);
        const fontSize = parseInt(koreanStyle.fontSize) || 32;
        const left = parseFloat(koreanOverlay.style.left) || 50;
        const top = parseFloat(koreanOverlay.style.top) || 65;

        canvasPreview.addOverlay({
            text: koreanOverlay.textContent.trim(),
            x: canvasPreview.canvas.width * (left / 100),
            y: canvasPreview.canvas.height * (top / 100),
            fontSize: fontSize,
            color: koreanStyle.color || '#000000',
            borderWidth: 3,
            borderColor: '#ffffff',
            type: 'korean'
        });
    }

    // 보조자막 (English) 오버레이
    if (englishOverlay && englishOverlay.style.display !== 'none' && !englishOverlay.classList.contains('empty')) {
        const englishStyle = window.getComputedStyle(englishOverlay);
        const fontSize = parseInt(englishStyle.fontSize) || 28;
        const left = parseFloat(englishOverlay.style.left) || 50;
        const top = parseFloat(englishOverlay.style.top) || 95;

        canvasPreview.addOverlay({
            text: englishOverlay.textContent.trim(),
            x: canvasPreview.canvas.width * (left / 100),
            y: canvasPreview.canvas.height * (top / 100),
            fontSize: fontSize,
            color: englishStyle.color || '#000000',
            borderWidth: 3,
            borderColor: '#ffe14d',
            type: 'english'
        });
    }

    console.log('🎨 Canvas 오버레이 동기화 완료:', canvasPreview.overlays);
}

// Canvas에 타임라인 자막 업데이트
function updateCanvasSubtitles(trackType, subtitles) {
    if (!canvasPreview) {
        console.log('ℹ️ Canvas 미리보기가 아직 초기화되지 않았습니다.');
        return;
    }

    // SRT 형식의 자막을 Canvas 형식으로 변환
    const canvasSubtitles = subtitles.map(sub => ({
        startTime: srtTimeToSeconds(sub.start),
        endTime: srtTimeToSeconds(sub.end),
        text: sub.text
    }));

    // Canvas에 자막 데이터 설정
    canvasPreview.setTimelineSubtitles(trackType, canvasSubtitles);
}

// 모든 타임라인 자막을 Canvas에 업데이트
function updateAllCanvasSubtitles() {
    if (!canvasPreview) return;
    canvasPreview.updateAllTimelineSubtitles(loadedSubtitles);
}

// 텍스트 변경 시 Canvas 업데이트
function updateCanvasText() {
    if (canvasPreview) {
        syncOverlaysToCanvas();
    }
}

// 검정 배경 토글을 Canvas에 반영
function updateCanvasBlackBars() {
    if (!canvasPreview) return;

    // 슬라이더에서 직접 값 가져오기
    const topHeight = parseFloat(document.getElementById('top-bar-height')?.value) || 15;
    const topOpacity = parseFloat(document.getElementById('top-bar-opacity')?.value) || 80;
    const bottomHeight = parseFloat(document.getElementById('bottom-bar-height')?.value) || 15;
    const bottomOpacity = parseFloat(document.getElementById('bottom-bar-opacity')?.value) || 80;

    const topBar = document.getElementById('top-black-bar');
    const bottomBar = document.getElementById('bottom-black-bar');

    canvasPreview.setBlackBars(
        {
            enabled: topBar && topBar.style.display !== 'none',
            height: topHeight,
            opacity: topOpacity / 100  // 0~100을 0~1로 변환
        },
        {
            enabled: bottomBar && bottomBar.style.display !== 'none',
            height: bottomHeight,
            opacity: bottomOpacity / 100  // 0~100을 0~1로 변환
        }
    );
}

console.log('🎨 Canvas 미리보기 시스템 준비 완료');
</script>

</body>
</html>
