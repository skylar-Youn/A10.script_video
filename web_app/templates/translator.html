<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쇼츠 번역 및 재해석기</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="brand">
                <h1><a href="/">유튜브 제작기</a> / 쇼츠 번역기</h1>
            </div>
        </header>

        <div id="project-view" class="hidden">
            <section class="panel">
                <div class="panel-header">
                    <h2 id="project-title"></h2>
                    <p id="project-status" class="panel-subtitle"></p>
                </div>
                <div id="project-actions"></div>
            </section>
            <section class="panel">
                <h3>번역 결과</h3>
                <div id="segments-table" class="segments-table"></div>
            </section>
        </div>

        <div id="creation-view">
            <section class="panel">
                <div class="panel-header">
                    <h2>1. 소스 선택</h2>
                    <p class="panel-subtitle">번역할 영상과 자막 파일을 선택하세요. 파일은 <code>youtube/download</code> 폴더에서 가져옵니다.</p>
                </div>
                <div id="downloads-list" class="downloads-list">
                    <p class="empty-state">다운로드된 파일을 불러오는 중...</p>
                    <p class="empty-state" style="color: #666; font-size: 0.9em;">
                        만약 이 메시지가 계속 표시된다면
                        <button onclick="location.reload(true)" style="margin: 0 5px; padding: 2px 8px;">강제 새로고침</button>
                        또는 개발자 도구(F12)에서 콘솔 오류를 확인해주세요.
                    </p>
                </div>
            </section>

            <section class="panel" id="ai-commentary-section">
                <div class="panel-header">
                    <h2>2. AI 해설 생성</h2>
                    <p class="panel-subtitle">선택된 영상의 자막을 분석하여 AI가 자동으로 해설을 생성합니다.</p>
                </div>
                <div id="selected-source-info" class="source-info">
                    <div class="source-details">
                        <h4 id="selected-source-title">선택된 소스</h4>
                        <p><strong>영상:</strong> <span id="selected-video-name">선택되지 않음</span></p>
                        <p><strong>자막:</strong> <span id="selected-subtitle-name">선택되지 않음</span></p>
                    </div>
                    <div class="source-actions">
                        <button type="button" id="open-source-selector-btn" class="btn-secondary btn-sm">파일 불러오기</button>
                    </div>
                </div>
                <div class="ai-commentary-controls">
                    <button type="button" id="generate-commentary-btn" class="btn-primary">
                        AI 해설 생성하기
                    </button>
                    <button type="button" id="skip-commentary-btn" class="btn-secondary">
                        건너뛰기
                    </button>
                </div>
                <div id="commentary-generation-status" class="status-message" style="display: none;">
                    <p>AI가 해설을 생성하고 있습니다...</p>
                </div>
            </section>

            <section class="panel" id="translation-settings-section">
                <div class="panel-header">
                    <h2>3. 번역 설정</h2>
                    <div>
                        <button type="button" id="load-settings-btn" class="btn-secondary btn-sm">지난 설정 불러오기</button>
                        <button type="button" id="save-settings-btn" class="btn-secondary btn-sm">설정 저장</button>
                    </div>
                </div>
                <form id="creation-form" class="form-grid" autocomplete="off">
                    <div class="form-group">
                        <label for="target-lang">목표 언어</label>
                        <select id="target-lang" name="target_lang" class="form-control" autocomplete="off">
                            <option value="ko">한국어</option>
                            <option value="en">English</option>
                            <option value="ja" selected>日本語</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="translation-mode">번역 모드</label>
                        <select id="translation-mode" name="translation_mode" class="form-control">
                            <option value="adaptive">적응형</option>
                            <option value="literal">직역</option>
                            <option value="reinterpret" selected>재해석 (기본)</option>
                        </select>
                    </div>
                    <div class="form-group form-group-full">
                        <label for="tone-hint">톤/스타일 힌트 (선택 사항)</label>
                        <input type="text" id="tone-hint" name="tone_hint" class="form-control" placeholder="드라마하고 유쾌하면서 유머러스하게" value="드라마하고 유쾌하면서 유머러스하게">
                    </div>
                    <div class="form-group form-group-full">
                        <button type="submit" class="btn-primary">번역 프로젝트 생성</button>
                    </div>
                </form>
            </section>
        </div>
    </div>


    <div id="source-selector-modal" class="modal hidden" role="dialog" aria-modal="true">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>영상/자막 파일 선택</h3>
                <button type="button" class="modal-close" id="source-selector-close" aria-label="닫기">×</button>
            </div>
            <div class="modal-body">
                <p class="modal-description">`youtube/download` 폴더에서 사용할 영상과 자막을 선택하세요.</p>
                <div class="source-selector-tabs" id="source-selector-tabs">
                    <button type="button" class="tab active" data-mode="downloads">다운로드된 파일</button>
                    <button type="button" class="tab" data-mode="projects">저장된 프로젝트</button>
                    <button type="button" class="tab" data-mode="saved">재해석 저장본</button>
                </div>
                <div id="source-selector-list" class="source-selector-list">
                    <p class="empty-state">목록을 불러오는 중...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="source-selector-cancel">취소</button>
                <button type="button" class="btn-primary" id="source-selector-apply" disabled>적용</button>
            </div>
        </div>
    </div>



    <script>
    (function () {
        const creationView = document.getElementById('creation-view');
        const projectView = document.getElementById('project-view');
        const downloadsList = document.getElementById('downloads-list');
        const creationForm = document.getElementById('creation-form');

        const projectTitle = document.getElementById('project-title');
        const projectStatus = document.getElementById('project-status');
        const projectActions = document.getElementById('project-actions');
        const segmentsTable = document.getElementById('segments-table');
        const openSourceSelectorBtn = document.getElementById('open-source-selector-btn');
        const sourceSelectorModal = document.getElementById('source-selector-modal');
        const sourceSelectorList = document.getElementById('source-selector-list');
        const sourceSelectorApplyBtn = document.getElementById('source-selector-apply');
        const sourceSelectorCloseBtn = document.getElementById('source-selector-close');
        const sourceSelectorCancelBtn = document.getElementById('source-selector-cancel');
        const sourceSelectorTabs = document.getElementById('source-selector-tabs');

        let selectedSource = null;
        let currentProject = null;
        let isTimelineView = false;
        let availableSourceOptions = [];
        let selectedSourceIndex = null;
        let sourceSelectorMode = 'downloads';
        let savedResultOptions = [];
        const savedResultDetailCache = {};
        let selectedSavedResultId = null;
        let translatorProjects = [];
        let selectedProjectId = null;
        const selectedSegmentIds = new Set();
        let selectionCountElem = null;
        let bulkTargetLangSelect = null;
        let bulkTranslateBtn = null;
        let bulkReverseBtn = null;
        let voiceSelectElem = null;
        let audioFormatSelectElem = null;

        if (openSourceSelectorBtn) {
            openSourceSelectorBtn.style.display = 'none';
        }

        const TEXT_FIELDS_MAP = {
            source: 'source_text',
            translated: 'translated_text',
            reverse_translated: 'reverse_translated_text',
            commentary: 'commentary',
            commentary_korean: 'commentary_korean',
            commentary_japanese: 'commentary_japanese',
            commentary_reverse_korean: 'commentary_reverse_korean',
        };

        const TEXT_TYPE_LABELS = {
            source: '현재 자막 (한국어)',
            commentary_korean: '재해석 자막 (한국어)',
            translated: '번역 일본어 자막',
            reverse_translated: '역번역 자막 (한국어)',
            commentary: '해설',
            commentary_japanese: '해설 일본어',
            commentary_reverse_korean: '해설 역번역 한국어',
        };

        function escapeHtml(text) {
            if (text === undefined || text === null) {
                return '';
            }
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function getSelectedVoice() {
            return voiceSelectElem && voiceSelectElem.value ? voiceSelectElem.value : 'nova';
        }

        function getSelectedAudioFormat() {
            return audioFormatSelectElem && audioFormatSelectElem.value ? audioFormatSelectElem.value : 'wav';
        }

        function updateSegmentCache(segmentId, textType, value) {
            if (!currentProject) {
                return;
            }
            const field = TEXT_FIELDS_MAP[textType];
            if (!field) {
                return;
            }
            const target = currentProject.segments.find(seg => seg.id === segmentId);
            if (target) {
                target[field] = value;
            }
        }

        function buildTextRow({ segmentId, label, type, value, rowClass, extraButtons = '', showLabel = true, speaker = null }) {
            const safeValue = escapeHtml(value || '');
            const labelAttr = showLabel ? '' : ' class="hidden-label"';
            const extraRowClass = showLabel ? '' : ' no-label';
            const speakerBadge = speaker ? `<span class="speaker-badge">${escapeHtml(speaker)}</span>` : '';
            return `
                <div class="text-row ${rowClass}${extraRowClass}">
                    <label${labelAttr}>${speakerBadge ? speakerBadge + ' ' : ''}${label}</label>
                    <div class="text-content" data-type="${type}" data-segment-id="${segmentId}">
                        <span class="text-display">${safeValue}</span>
                        <textarea class="text-edit" style="display: none;" rows="2">${safeValue}</textarea>
                        <div class="text-buttons">
                            <button class="btn-edit-text" data-type="${type}" data-segment-id="${segmentId}" title="${label} 수정">수정</button>
                            <button class="btn-copy-text" data-type="${type}" data-segment-id="${segmentId}" title="${label} 복사">복사</button>
                            ${extraButtons}
                            <button class="btn-delete-text" data-type="${type}" data-segment-id="${segmentId}" title="${label} 삭제">삭제</button>
                        </div>
                        <div class="last-modified" style="font-size: 0.8em; color: #888; margin-top: 4px;"></div>
                    </div>
                </div>
            `;
        }

        function buildAudioRow({ segmentId, audioPath, showLabel = true }) {
            const labelAttr = showLabel ? '' : ' class="hidden-label"';
            const extraRowClass = showLabel ? '' : ' no-label';
            const hasAudio = audioPath && audioPath.trim() !== '';
            const audioFileName = hasAudio ? extractFileName(audioPath) : '음성 파일 없음';

            return `
                <div class="text-row audio-row${extraRowClass}">
                    <label${labelAttr}>일본어 음성 파일</label>
                    <div class="audio-content" data-segment-id="${segmentId}">
                        <span class="audio-display">${escapeHtml(audioFileName)}</span>
                        <div class="audio-buttons">
                            ${hasAudio ? `
                                <button class="btn-play-audio" data-segment-id="${segmentId}" data-audio-path="${escapeHtml(audioPath)}" title="음성 듣기">▶️ 듣기</button>
                            ` : ''}
                            <button class="btn-generate-audio" data-segment-id="${segmentId}" title="음성 생성">🔊 생성</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function extractFileName(path) {
            if (!path) {
                return '';
            }
            const normalized = String(path).replace(/\\/g, '/');
            const parts = normalized.split('/').filter(Boolean);
            return parts.length ? parts[parts.length - 1] : normalized;
        }


        function formatTimestamp(seconds) {
            if (typeof seconds !== 'number' || Number.isNaN(seconds)) {
                return '00:00.00';
            }
            const totalSeconds = Math.max(seconds, 0);
            const minutes = Math.floor(totalSeconds / 60);
            const remainder = totalSeconds - minutes * 60;
            const secondsStr = remainder.toFixed(2).padStart(5, '0');
            const minutesStr = String(minutes).padStart(2, '0');
            return `${minutesStr}:${secondsStr}`;
        }


        function buildSegmentTime(seg) {
            const startTime = formatTimestamp(seg.start || 0);
            const endTime = formatTimestamp(seg.end || 0);
            const duration = Math.max((seg.end || 0) - (seg.start || 0), 0).toFixed(1);
            return `
                <div class="time-display" data-segment-id="${seg.id}" title="클릭하여 시간 수정">
                    <span class="start-time">${startTime}</span>
                    <span class="time-separator">→</span>
                    <span class="end-time">${endTime}</span>
                    <span class="time-duration">(${duration}초)</span>
                </div>
                <div class="time-edit" data-segment-id="${seg.id}" style="display: none;">
                    <input type="number" class="start-input" step="0.01" value="${(seg.start || 0).toFixed(2)}" min="0">
                    <span class="time-separator">→</span>
                    <input type="number" class="end-input" step="0.01" value="${(seg.end || 0).toFixed(2)}" min="0">
                    <div class="time-edit-buttons">
                        <button type="button" class="btn-save-time" data-segment-id="${seg.id}">저장</button>
                        <button type="button" class="btn-cancel-time" data-segment-id="${seg.id}">취소</button>
                    </div>
                </div>
            `;
        }


        function buildSegmentCheckbox(seg) {
            return `<input type="checkbox" class="segment-select" data-segment-id="${seg.id}" aria-label="세그먼트 선택">`;
        }


        function buildCardSegments(project) {
            if (!project.segments || !project.segments.length) {
                return '<p class="empty-state">세그먼트가 없습니다. 번역을 실행한 뒤 다시 시도해주세요.</p>';
            }

            return project.segments
                .map((seg, index) => {
                    const sourceRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.source,
                        type: 'source',
                        value: seg.source_text || '',
                        rowClass: 'korean original',
                        speaker: seg.speaker_name || null,
                        showLabel: true
                    });
                    const reinterpretRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.commentary_korean,
                        type: 'commentary_korean',
                        value: seg.commentary_korean || seg.source_text || '',
                        rowClass: 'korean reinterpretation',
                        speaker: seg.speaker_name || null,
                        showLabel: true
                    });
                    const japaneseRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.translated,
                        type: 'translated',
                        value: seg.translated_text || '',
                        rowClass: 'japanese',
                        extraButtons: `<button class="btn-translate-reverse" data-segment-id="${seg.id}" title="일본어→한국어 역번역">역번역</button>`,
                        showLabel: true
                    });
                    const audioRow = buildAudioRow({
                        segmentId: seg.id,
                        audioPath: seg.audio_path || '',
                        showLabel: true
                    });
                    const reverseRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.reverse_translated,
                        type: 'reverse_translated',
                        value: seg.reverse_translated_text || '',
                        rowClass: 'korean reverse',
                        showLabel: true
                    });

                    return `
                <div class="segment-item" data-segment-id="${seg.id}">
                    <div class="segment-header">
                        <div class="segment-select-cell">
                            ${buildSegmentCheckbox(seg)}
                            <span class="segment-index">${index + 1}</span>
                        </div>
                        <div class="segment-time" data-segment-id="${seg.id}">
                            ${buildSegmentTime(seg)}
                        </div>
                        <div class="segment-actions">
                            <button class="btn-move-up" data-segment-id="${seg.id}" title="위로 이동">⬆️</button>
                            <button class="btn-move-down" data-segment-id="${seg.id}" title="아래로 이동">⬇️</button>
                            <button class="btn-edit-segment" data-segment-id="${seg.id}" title="세그먼트 수정">✏️</button>
                            <button class="btn-delete-segment" data-segment-id="${seg.id}" title="세그먼트 삭제">🗑️</button>
                        </div>
                    </div>
                    <div class="segment-content">
                        <div class="text-pair translation-stack">
                            ${sourceRow}
                            ${reinterpretRow}
                            ${japaneseRow}
                            ${audioRow}
                            ${reverseRow}
                        </div>
                    </div>
                </div>
            `;
                })
                .join('');
        }


        function buildTimelineRow(seg, index) {
            const sourceCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.source,
                type: 'source',
                value: seg.source_text || '',
                rowClass: 'korean original',
                speaker: seg.speaker_name || null,
                showLabel: false
            });
            const reinterpretCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.commentary_korean,
                type: 'commentary_korean',
                value: seg.commentary_korean || seg.source_text || '',
                rowClass: 'korean reinterpretation',
                speaker: seg.speaker_name || null,
                showLabel: false
            });
            const japaneseCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.translated,
                type: 'translated',
                value: seg.translated_text || '',
                rowClass: 'japanese',
                extraButtons: `<button class="btn-translate-reverse" data-segment-id="${seg.id}" title="일본어→한국어 역번역">역번역</button>`,
                showLabel: false
            });
            const reverseCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.reverse_translated,
                type: 'reverse_translated',
                value: seg.reverse_translated_text || '',
                rowClass: 'korean reverse',
                showLabel: false
            });

            return `
                <div class="timeline-row segment-item" data-segment-id="${seg.id}">
                    <div class="timeline-col timeline-index">
                        ${buildSegmentCheckbox(seg)}
                        <span class="segment-index">${index + 1}</span>
                    </div>
                    <div class="timeline-col timeline-time">
                        <div class="segment-time" data-segment-id="${seg.id}">
                            ${buildSegmentTime(seg)}
                            <div class="segment-actions timeline-actions">
                                <button class="btn-move-up" data-segment-id="${seg.id}" title="위로 이동">⬆️</button>
                                <button class="btn-move-down" data-segment-id="${seg.id}" title="아래로 이동">⬇️</button>
                                <button class="btn-edit-segment" data-segment-id="${seg.id}" title="세그먼트 수정">✏️</button>
                                <button class="btn-delete-segment" data-segment-id="${seg.id}" title="세그먼트 삭제">🗑️</button>
                            </div>
                        </div>
                    </div>
                    <div class="timeline-col timeline-text">${sourceCell}</div>
                    <div class="timeline-col timeline-text">${reinterpretCell}</div>
                    <div class="timeline-col timeline-text">${japaneseCell}</div>
                    <div class="timeline-col timeline-text">${reverseCell}</div>
                </div>
            `;
        }


        function buildTimelineSegments(project) {
            if (!project.segments || !project.segments.length) {
                return '<p class="empty-state">세그먼트가 없습니다. 번역을 실행한 뒤 다시 시도해주세요.</p>';
            }

            const header = `
                <div class="timeline-row timeline-header">
                    <div class="timeline-col timeline-index">#</div>
                    <div class="timeline-col timeline-time">타임스탬프</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.source}</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.commentary_korean}</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.translated}</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.reverse_translated}</div>
                </div>
            `;

            const rows = project.segments
                .map((seg, index) => buildTimelineRow(seg, index))
                .join('');

            return `<div class="timeline-scroll">${header}${rows}</div>`;
        }


        function renderSegments(project) {
            if (!project || !project.segments) {
                segmentsTable.innerHTML = '<p class="empty-state">세그먼트를 불러오지 못했습니다.</p>';
                return;
            }

            if (isTimelineView) {
                segmentsTable.classList.add('timeline-active');
                segmentsTable.innerHTML = buildTimelineSegments(project);
            } else {
                segmentsTable.classList.remove('timeline-active');
                segmentsTable.innerHTML = buildCardSegments(project);
            }

            attachSegmentEventListeners();
            attachTimeEditListeners();
            attachSelectionCheckboxListeners();
            updateSelectionUI();
        }

        function openSourceSelectorModal() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            selectedSourceIndex = null;
            selectedSavedResultId = null;
            sourceSelectorApplyBtn.disabled = true;
            sourceSelectorModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
            switchSourceSelectorMode('downloads');
        }

        function closeSourceSelectorModal() {
            sourceSelectorModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
            selectedSourceIndex = null;
            selectedSavedResultId = null;
            sourceSelectorApplyBtn.disabled = true;
        }

        function updateSourceApplyState() {
            if (sourceSelectorMode === 'downloads') {
                sourceSelectorApplyBtn.disabled = selectedSourceIndex === null;
            } else if (sourceSelectorMode === 'projects') {
                sourceSelectorApplyBtn.disabled = !selectedProjectId;
            } else {
                sourceSelectorApplyBtn.disabled = !selectedSavedResultId || !savedResultDetailCache[selectedSavedResultId];
            }
        }

        function loadDownloadSources() {
            const cacheBuster = Date.now();
            sourceSelectorList.innerHTML = '<p class="empty-state">목록을 불러오는 중...</p>';

            fetch(`/api/translator/downloads?_cb=${cacheBuster}`)
                .then(res => res.ok ? res.json() : Promise.reject(new Error(`HTTP ${res.status}`)))
                .then(items => {
                    availableSourceOptions = Array.isArray(items) ? items : [];
                    renderDownloadOptions();
                })
                .catch(err => {
                    console.error('Failed to load source options:', err);
                    sourceSelectorList.innerHTML = '<p class="empty-state error">목록을 불러오지 못했습니다.</p>';
                });
        }

        function renderDownloadOptions() {
            if (!availableSourceOptions.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">사용 가능한 영상이 없습니다. 먼저 다운로드 도구에서 파일을 받아주세요.</p>';
                return;
            }

            const html = availableSourceOptions.map((item, index) => {
                const baseName = item.base_name || extractFileName(item.video_path) || `영상 ${index + 1}`;
                const subtitleName = item.subtitle_path ? extractFileName(item.subtitle_path) : '자막 없음';
                const videoName = extractFileName(item.video_path);
                return `
                    <label class="source-option">
                        <input type="radio" name="source-selection" value="${index}">
                        <div class="source-option-body">
                            <div class="option-title">${escapeHtml(baseName)}</div>
                            <div class="option-meta">
                                <span class="option-video">🎬 ${escapeHtml(videoName || '알 수 없음')}</span>
                                <span class="option-subtitle">📝 ${escapeHtml(subtitleName)}</span>
                            </div>
                        </div>
                    </label>
                `;
            }).join('');

            sourceSelectorList.innerHTML = html;
            sourceSelectorList.querySelectorAll('input[name="source-selection"]').forEach(input => {
                input.addEventListener('change', (event) => {
                    selectedSourceIndex = parseInt(event.target.value, 10);
                    selectedSavedResultId = null;
                    updateSourceApplyState();
                });
            });
            updateSourceApplyState();
        }

        function loadTranslatorProjects() {
            sourceSelectorList.innerHTML = '<p class="empty-state">프로젝트 목록을 불러오는 중...</p>';
            fetch('/api/translator/projects')
                .then(res => res.ok ? res.json() : Promise.reject(new Error(`HTTP ${res.status}`)))
                .then(projects => {
                    translatorProjects = Array.isArray(projects) ? projects : [];
                    renderTranslatorProjects();
                })
                .catch(err => {
                    console.error('Failed to load translator projects:', err);
                    sourceSelectorList.innerHTML = '<p class="empty-state error">프로젝트 목록을 불러오지 못했습니다.</p>';
                });
        }

        function renderTranslatorProjects() {
            if (!translatorProjects.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">저장된 프로젝트가 없습니다.</p>';
                return;
            }

            // 현재 프로젝트는 제외
            const otherProjects = translatorProjects.filter(p => p.id !== (currentProject?.id));

            if (!otherProjects.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">다른 프로젝트가 없습니다.</p>';
                return;
            }

            console.log('📋 Rendering translator projects:', otherProjects.length);

            const html = otherProjects.map((project, index) => {
                console.log(`Project ${index}:`, {
                    id: project.id,
                    base_name: project.base_name,
                    created_at: project.created_at,
                    segments: project.segments?.length
                });

                // 프로젝트 이름 표시 (base_name 또는 id에서 추출)
                let displayName = project.base_name || project.id || '이름 없음';

                // backup_ 접두사 제거
                if (displayName.startsWith('backup_')) {
                    displayName = displayName.substring(7); // 'backup_' 제거
                }

                // 타임스탬프 패턴 제거 (_20250930_194830 형태)
                displayName = displayName.replace(/_\d{8}_\d{6}$/, '');

                // 이름이 너무 길면 자르기 (50자 이상)
                if (displayName.length > 50) {
                    displayName = displayName.substring(0, 47) + '...';
                }

                const createdDate = project.created_at ? new Date(project.created_at).toLocaleString('ko-KR') : '시간 정보 없음';
                const updatedDate = project.updated_at ? new Date(project.updated_at).toLocaleString('ko-KR') : null;
                const segmentCount = project.segments?.length || 0;
                const statusText = project.status || 'draft';

                return `
                    <label class="source-option">
                        <input type="radio" name="project-selection" value="${project.id}">
                        <div class="source-option-body">
                            <div class="option-title">📁 ${escapeHtml(displayName)}</div>
                            <div class="option-meta">
                                <span>📊 세그먼트: ${segmentCount}개</span>
                                <span>📌 상태: ${statusText}</span>
                                <span>🕒 생성: ${escapeHtml(createdDate)}</span>
                                ${updatedDate ? `<span>✏️ 수정: ${escapeHtml(updatedDate)}</span>` : ''}
                            </div>
                        </div>
                    </label>
                `;
            }).join('');

            sourceSelectorList.innerHTML = html;
            sourceSelectorList.querySelectorAll('input[name="project-selection"]').forEach(input => {
                input.addEventListener('change', (event) => {
                    selectedProjectId = event.target.value;
                    selectedSourceIndex = null;
                    selectedSavedResultId = null;
                    updateSourceApplyState();
                });
            });
            updateSourceApplyState();
        }

        function loadSavedResultOptions() {
            sourceSelectorList.innerHTML = '<p class="empty-state">목록을 불러오는 중...</p>';
            fetch('/api/translator/saved-results')
                .then(res => res.ok ? res.json() : Promise.reject(new Error(`HTTP ${res.status}`)))
                .then(data => {
                    const results = Array.isArray(data?.results) ? data.results : [];
                    savedResultOptions = results;
                    renderSavedResultOptions();
                })
                .catch(err => {
                    console.error('Failed to load saved results:', err);
                    sourceSelectorList.innerHTML = '<p class="empty-state error">재해석 저장본을 불러오지 못했습니다.</p>';
                });
        }

        function renderSavedResultOptions() {
            if (!savedResultOptions.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">저장된 재해석 결과가 없습니다.</p>';
                return;
            }

            const html = savedResultOptions.map(item => {
                const name = item.name || '이름 없는 저장';
                const savedAt = item.saved_at ? new Date(item.saved_at).toLocaleString('ko-KR') : '시간 정보 없음';
                return `
                    <label class="source-option">
                        <input type="radio" name="saved-result-selection" value="${item.id}">
                        <div class="source-option-body">
                            <div class="option-title">${escapeHtml(name)}</div>
                            <div class="option-meta">
                                <span>🗂 ID: ${escapeHtml(item.id)}</span>
                                <span>🕒 ${escapeHtml(savedAt)}</span>
                            </div>
                        </div>
                    </label>
                `;
            }).join('');

            sourceSelectorList.innerHTML = html;
            sourceSelectorList.querySelectorAll('input[name="saved-result-selection"]').forEach(input => {
                input.addEventListener('change', async (event) => {
                    selectedSavedResultId = event.target.value;
                    selectedSourceIndex = null;
                    updateSourceApplyState();

                    if (selectedSavedResultId && !savedResultDetailCache[selectedSavedResultId]) {
                        try {
                            sourceSelectorApplyBtn.disabled = true;
                            const res = await fetch(`/api/translator/saved-results/${encodeURIComponent(selectedSavedResultId)}`);
                            if (!res.ok) {
                                throw new Error(`HTTP ${res.status}`);
                            }
                            const detail = await res.json();
                            savedResultDetailCache[selectedSavedResultId] = detail?.result;
                        } catch (error) {
                            console.error('Failed to fetch saved result detail:', error);
                            alert('재해석 저장본을 불러오지 못했습니다.');
                            selectedSavedResultId = null;
                        }
                    }
                    updateSourceApplyState();
                });
            });
            updateSourceApplyState();
        }

        function buildSelectionControls() {
            const container = document.createElement('div');
            container.className = 'selection-toolbar';
            container.innerHTML = `
                <div class="selection-summary">선택: <span id="selected-count">0</span>개</div>
                <div class="selection-buttons">
                    <button type="button" class="btn-secondary btn-sm" id="select-all-btn">전체 체크</button>
                    <button type="button" class="btn-secondary btn-sm" id="clear-selection-btn">전체 해제</button>
                    <button type="button" class="btn-secondary btn-sm" id="toggle-selection-btn">체크 반전</button>
                    <button type="button" class="btn-secondary btn-sm" id="select-speaker1-btn">화자1</button>
                    <button type="button" class="btn-secondary btn-sm" id="select-speaker2-btn">화자2</button>
                    <button type="button" class="btn-secondary btn-sm" id="select-speaker3-btn">화자3</button>
                </div>
                <div class="bulk-actions">
                    <label for="bulk-target-lang">번역 대상:</label>
                    <select id="bulk-target-lang" class="form-control form-control-sm">
                        <option value="ja">일본어</option>
                        <option value="ko">한국어</option>
                        <option value="en">영어</option>
                    </select>
                    <button type="button" class="btn-primary btn-sm" id="bulk-translate-btn">선택 자막 번역</button>
                    <button type="button" class="btn-secondary btn-sm" id="bulk-reverse-btn">선택 역번역 (한국어)</button>
                    <button type="button" class="btn-success btn-sm" id="save-selected-btn">체크 다른이름 저장</button>
                    <button type="button" class="btn-danger btn-sm" id="delete-unselected-btn">미선택 화자 전체 삭제</button>
                </div>
                <div class="audio-actions" style="margin-top: 10px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                    <label for="voice-select" style="margin: 0; font-weight: bold;">음성:</label>
                    <select id="voice-select" class="form-control form-control-sm" style="width: auto; min-width: 90px;">
                        <option value="nova">nova</option>
                        <option value="alloy">alloy</option>
                        <option value="echo">echo</option>
                        <option value="fable">fable</option>
                        <option value="onyx">onyx</option>
                        <option value="shimmer">shimmer</option>
                    </select>
                    <label for="audio-format-select" style="margin: 0; font-weight: bold;">포맷:</label>
                    <select id="audio-format-select" class="form-control form-control-sm" style="width: auto; min-width: 75px;">
                        <option value="wav" selected>WAV</option>
                        <option value="mp3">MP3</option>
                    </select>
                    <button type="button" class="btn-primary btn-sm" id="generate-selected-audio-btn">🔊 선택 자막 음성 생성</button>
                    <button type="button" class="btn-primary btn-sm" id="generate-all-audio-btn">🔊 전체 음성 생성</button>
                    <button type="button" class="btn-sm" id="play-all-audio-btn" style="background-color: #e0e0e0; color: #000; border: 1px solid #ccc;">▶️ 전체 듣기</button>
                    <button type="button" class="btn-success btn-sm" id="save-all-audio-btn">💾 전체 음성 저장</button>
                </div>
            `;

            selectionCountElem = container.querySelector('#selected-count');
            bulkTargetLangSelect = container.querySelector('#bulk-target-lang');
            bulkTranslateBtn = container.querySelector('#bulk-translate-btn');
            bulkReverseBtn = container.querySelector('#bulk-reverse-btn');
            voiceSelectElem = container.querySelector('#voice-select');
            audioFormatSelectElem = container.querySelector('#audio-format-select');

            if (voiceSelectElem) {
                try {
                    const savedVoice = localStorage.getItem('translatorVoiceChoice');
                    if (savedVoice && Array.from(voiceSelectElem.options).some(opt => opt.value === savedVoice)) {
                        voiceSelectElem.value = savedVoice;
                    }
                } catch (error) {
                    console.warn('음성 선택 저장을 위한 localStorage 접근 실패:', error);
                }
                voiceSelectElem.addEventListener('change', () => {
                    try {
                        localStorage.setItem('translatorVoiceChoice', voiceSelectElem.value);
                    } catch (error) {
                        console.warn('음성 선택 저장 실패:', error);
                    }
                });
            }

            if (audioFormatSelectElem) {
                try {
                    const savedFormat = localStorage.getItem('translatorAudioFormat');
                    if (savedFormat && Array.from(audioFormatSelectElem.options).some(opt => opt.value === savedFormat)) {
                        audioFormatSelectElem.value = savedFormat;
                    }
                } catch (error) {
                    console.warn('오디오 포맷 선택 저장을 위한 localStorage 접근 실패:', error);
                }
                audioFormatSelectElem.addEventListener('change', () => {
                    try {
                        localStorage.setItem('translatorAudioFormat', audioFormatSelectElem.value);
                    } catch (error) {
                        console.warn('오디오 포맷 선택 저장 실패:', error);
                    }
                });
            }

            const selectAllBtn = container.querySelector('#select-all-btn');
            const clearSelectionBtn = container.querySelector('#clear-selection-btn');
            const toggleSelectionBtn = container.querySelector('#toggle-selection-btn');
            const selectSpeaker1Btn = container.querySelector('#select-speaker1-btn');
            const selectSpeaker2Btn = container.querySelector('#select-speaker2-btn');
            const selectSpeaker3Btn = container.querySelector('#select-speaker3-btn');

            selectAllBtn.addEventListener('click', selectAllSegments);
            clearSelectionBtn.addEventListener('click', clearSelectedSegments);
            toggleSelectionBtn.addEventListener('click', toggleAllSegments);
            selectSpeaker1Btn.addEventListener('click', () => selectSegmentsBySpeakers(['화자1']));
            selectSpeaker2Btn.addEventListener('click', () => selectSegmentsBySpeakers(['화자2']));
            selectSpeaker3Btn.addEventListener('click', () => selectSegmentsBySpeakers(['화자3']));

            const saveSelectedBtn = container.querySelector('#save-selected-btn');
            const deleteUnselectedBtn = container.querySelector('#delete-unselected-btn');
            const generateSelectedAudioBtn = container.querySelector('#generate-selected-audio-btn');
            const generateAllAudioBtn = container.querySelector('#generate-all-audio-btn');
            const playAllAudioBtn = container.querySelector('#play-all-audio-btn');
            const saveAllAudioBtn = container.querySelector('#save-all-audio-btn');

            if (bulkTranslateBtn) {
                bulkTranslateBtn.addEventListener('click', bulkTranslateSelectedSegments);
            }
            if (bulkReverseBtn) {
                bulkReverseBtn.addEventListener('click', bulkReverseSelectedSegments);
            }
            if (saveSelectedBtn) {
                saveSelectedBtn.addEventListener('click', saveSelectedSegmentsAs);
            }
            if (deleteUnselectedBtn) {
                deleteUnselectedBtn.addEventListener('click', deleteUnselectedSegments);
            }
            if (generateSelectedAudioBtn) {
                generateSelectedAudioBtn.addEventListener('click', generateSelectedAudio);
            }
            if (generateAllAudioBtn) {
                generateAllAudioBtn.addEventListener('click', generateAllAudio);
            }
            if (playAllAudioBtn) {
                playAllAudioBtn.addEventListener('click', playAllAudio);
            }
            if (saveAllAudioBtn) {
                saveAllAudioBtn.addEventListener('click', saveAllAudio);
            }

            return container;
        }

        function selectAllSegments() {
            if (!currentProject) {
                return;
            }
            currentProject.segments.forEach(seg => selectedSegmentIds.add(seg.id));
            updateSelectionUI();
        }

        function clearSelectedSegments() {
            selectedSegmentIds.clear();
            updateSelectionUI();
        }

        function toggleAllSegments() {
            if (!currentProject) {
                return;
            }
            // 각 세그먼트의 선택 상태를 반전
            currentProject.segments.forEach(seg => {
                if (selectedSegmentIds.has(seg.id)) {
                    selectedSegmentIds.delete(seg.id);
                } else {
                    selectedSegmentIds.add(seg.id);
                }
            });
            updateSelectionUI();
        }

        function selectSegmentsBySpeakers(speakers) {
            if (!currentProject) {
                return;
            }
            const normalized = speakers.map(s => s.trim()).filter(Boolean);
            if (!normalized.length) {
                return;
            }
            currentProject.segments.forEach(seg => {
                if (seg.speaker_name && normalized.includes(seg.speaker_name)) {
                    selectedSegmentIds.add(seg.id);
                }
            });
            updateSelectionUI();
        }

        function getSelectedSegmentIds() {
            if (selectedSegmentIds.size) {
                return Array.from(selectedSegmentIds);
            }
            if (!currentProject) {
                return [];
            }
            return currentProject.segments.map(seg => seg.id);
        }

        function bulkTranslateSelectedSegments() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const segmentIds = selectedSegmentIds.size
                ? Array.from(selectedSegmentIds)
                : [];

            if (!segmentIds.length && !confirm('선택된 세그먼트가 없습니다. 전체 세그먼트를 번역할까요?')) {
                return;
            }

            const targetLang = bulkTargetLangSelect?.value || document.getElementById('target-lang')?.value || currentProject.target_lang || 'ja';
            const translationMode = document.getElementById('translation-mode')?.value || currentProject.translation_mode || 'reinterpret';
            const toneHintValue = document.getElementById('tone-hint')?.value || currentProject.tone_hint || null;

            if (bulkTranslateBtn) {
                const originalText = bulkTranslateBtn.textContent;
                bulkTranslateBtn.disabled = true;
                bulkTranslateBtn.textContent = '번역 중... 0%';
                bulkTranslateBtn.dataset.originalText = originalText;
            }

            // 진행률 폴링 시작
            let progressInterval = setInterval(() => {
                fetch(`/api/translator/projects/${currentProject.id}`)
                    .then(res => res.json())
                    .then(project => {
                        const progress = project.extra?.translation_progress;
                        if (progress && bulkTranslateBtn) {
                            bulkTranslateBtn.textContent = `번역 중... ${progress.percentage}% (${progress.completed}/${progress.total})`;
                        }
                    })
                    .catch(err => {
                        console.error('Failed to fetch progress:', err);
                    });
            }, 1000); // 1초마다 진행률 확인

            fetch(`/api/translator/projects/${currentProject.id}/translate-segments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    segment_ids: segmentIds,
                    target_lang: targetLang,
                    translation_mode: translationMode,
                    tone_hint: toneHintValue,
                })
            })
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    clearInterval(progressInterval);
                    renderProject(project);
                })
                .catch(err => {
                    clearInterval(progressInterval);
                    console.error('Failed to translate segments:', err);
                    alert('선택된 자막을 번역하지 못했습니다: ' + err.message);
                })
                .finally(() => {
                    clearInterval(progressInterval);
                    if (bulkTranslateBtn) {
                        bulkTranslateBtn.disabled = false;
                        bulkTranslateBtn.textContent = bulkTranslateBtn.dataset.originalText || '선택 자막 번역';
                    }
                });
        }

        function bulkReverseSelectedSegments() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const segmentIds = selectedSegmentIds.size
                ? Array.from(selectedSegmentIds)
                : [];

            if (!segmentIds.length && !confirm('선택된 세그먼트가 없습니다. 전체 세그먼트를 역번역할까요?')) {
                return;
            }

            if (bulkReverseBtn) {
                const originalText = bulkReverseBtn.textContent;
                bulkReverseBtn.disabled = true;
                bulkReverseBtn.textContent = '역번역 중... 0%';
                bulkReverseBtn.dataset.originalText = originalText;
            }

            // 진행률 폴링 시작
            let progressInterval = setInterval(() => {
                fetch(`/api/translator/projects/${currentProject.id}`)
                    .then(res => res.json())
                    .then(project => {
                        const progress = project.extra?.translation_progress;
                        if (progress && bulkReverseBtn) {
                            bulkReverseBtn.textContent = `역번역 중... ${progress.percentage}% (${progress.completed}/${progress.total})`;
                        }
                    })
                    .catch(err => {
                        console.error('Failed to fetch progress:', err);
                    });
            }, 1000); // 1초마다 진행률 확인

            fetch(`/api/translator/projects/${currentProject.id}/reverse-translate-segments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    segment_ids: segmentIds,
                })
            })
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    clearInterval(progressInterval);
                    renderProject(project);
                })
                .catch(err => {
                    clearInterval(progressInterval);
                    console.error('Failed to reverse translate segments:', err);
                    alert('선택된 자막을 역번역하지 못했습니다: ' + err.message);
                })
                .finally(() => {
                    clearInterval(progressInterval);
                    if (bulkReverseBtn) {
                        bulkReverseBtn.disabled = false;
                        bulkReverseBtn.textContent = bulkReverseBtn.dataset.originalText || '선택 역번역 (한국어)';
                    }
                });
        }

        async function generateSelectedAudio() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const segmentIds = selectedSegmentIds.size
                ? Array.from(selectedSegmentIds)
                : [];

            if (!segmentIds.length) {
                alert('선택된 세그먼트가 없습니다. 세그먼트를 선택해주세요.');
                return;
            }

            const voice = getSelectedVoice();
            const audioFormat = getSelectedAudioFormat();

            if (!confirm(`선택된 ${segmentIds.length}개 세그먼트를 ${voice} / ${audioFormat.toUpperCase()}로 생성하시겠습니까? (자막 시간에 맞춰 무음이 포함됩니다)`)) {
                return;
            }

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/generate-selected-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        segment_ids: segmentIds,
                        voice: voice,
                        audio_format: audioFormat
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                alert(`선택된 자막 음성 생성 완료!\n파일 경로: ${result.audio_path}`);
            } catch (err) {
                console.error('Failed to generate selected audio:', err);
                alert('선택된 자막 음성 생성에 실패했습니다: ' + err.message);
            }
        }

        async function generateAllAudio() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const voice = getSelectedVoice();
            const audioFormat = getSelectedAudioFormat();

            if (!confirm(`모든 세그먼트를 ${voice} / ${audioFormat.toUpperCase()}로 생성하시겠습니까?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/generate-all-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        voice: voice,
                        audio_format: audioFormat
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const project = await response.json();
                currentProject = project;
                renderProject(project);
                alert('전체 음성 생성 완료!');
            } catch (err) {
                console.error('Failed to generate all audio:', err);
                alert('전체 음성 생성에 실패했습니다: ' + err.message);
            }
        }

        function playAllAudio() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const audioSegments = currentProject.segments.filter(seg => seg.audio_path);
            if (audioSegments.length === 0) {
                alert('생성된 음성 파일이 없습니다.');
                return;
            }

            // 모든 음성 파일을 순차적으로 재생
            let currentIndex = 0;
            const audio = new Audio();

            audio.onended = () => {
                currentIndex++;
                if (currentIndex < audioSegments.length) {
                    audio.src = audioSegments[currentIndex].audio_path;
                    audio.play();
                }
            };

            audio.src = audioSegments[currentIndex].audio_path;
            audio.play();
        }

        function saveAllAudio() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            alert('전체 음성 저장 기능은 백엔드에서 구현되어야 합니다. 현재는 개별 세그먼트 음성 파일이 이미 저장되어 있습니다.');
        }

        function syncSelectionWithProject() {
            if (!currentProject) {
                selectedSegmentIds.clear();
                updateSelectionUI();
                return;
            }
            const validIds = new Set(currentProject.segments.map(seg => seg.id));
            Array.from(selectedSegmentIds).forEach(id => {
                if (!validIds.has(id)) {
                    selectedSegmentIds.delete(id);
                }
            });
            updateSelectionUI();
        }

        async function saveSelectedSegmentsAs() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            if (selectedSegmentIds.size === 0) {
                alert('저장할 세그먼트를 선택해주세요.');
                return;
            }

            const selectedSegments = currentProject.segments.filter(seg => selectedSegmentIds.has(seg.id));
            const newName = prompt(
                `${selectedSegments.length}개의 선택된 세그먼트를 새 프로젝트로 저장합니다.\n새 프로젝트 이름을 입력하세요:`,
                currentProject.base_name + '_선택본'
            );

            if (!newName || newName.trim() === '') {
                return;
            }

            const saveBtn = document.getElementById('save-selected-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = '💾 저장 중...';
            }

            try {
                const trimmedName = newName.trim();
                console.log(`💾 Saving selected segments with name: "${trimmedName}"`);

                // 먼저 프로젝트를 복제
                const clonePayload = { new_name: trimmedName };
                console.log('📤 Clone request payload:', clonePayload);

                const cloneResponse = await fetch(`/api/translator/projects/${currentProject.id}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(clonePayload)
                });

                if (!cloneResponse.ok) {
                    const errorText = await cloneResponse.text();
                    console.error('❌ Clone failed:', errorText);
                    throw new Error('프로젝트 복사 실패');
                }

                const newProject = await cloneResponse.json();
                console.log('✅ Project cloned:', {
                    id: newProject.id,
                    base_name: newProject.base_name,
                    expected_name: trimmedName
                });

                // 복제된 프로젝트에서 선택되지 않은 세그먼트 삭제
                const segmentsToDelete = newProject.segments.filter(seg => !selectedSegmentIds.has(seg.id));
                console.log(`🗑️ Deleting ${segmentsToDelete.length} unselected segments from cloned project...`);

                let deletedCount = 0;
                for (const segment of segmentsToDelete) {
                    try {
                        const deleteResponse = await fetch(`/api/translator/projects/${newProject.id}/segments/${segment.id}`, {
                            method: 'DELETE'
                        });

                        if (deleteResponse.ok) {
                            deletedCount++;
                        }
                    } catch (error) {
                        console.error(`Failed to delete segment ${segment.id}:`, error);
                    }
                }

                console.log(`✅ Deleted ${deletedCount} segments from cloned project`);

                alert(`✅ ${selectedSegments.length}개의 세그먼트가 "${newName}"로 저장되었습니다.`);

                // 새 프로젝트로 이동할지 물어보기
                if (confirm('저장된 프로젝트로 이동하시겠습니까?')) {
                    window.location.href = `/translator?id=${newProject.id}`;
                }
            } catch (error) {
                console.error('Save selected segments error:', error);
                alert('❌ 선택된 세그먼트 저장에 실패했습니다.');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = '체크 다른이름 저장';
                }
            }
        }

        async function deleteUnselectedSegments() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const unselectedSegments = currentProject.segments.filter(seg => !selectedSegmentIds.has(seg.id));

            if (unselectedSegments.length === 0) {
                alert('삭제할 미선택 세그먼트가 없습니다.');
                return;
            }

            const selectedCount = selectedSegmentIds.size;
            const totalCount = currentProject.segments.length;
            const deleteCount = unselectedSegments.length;

            const confirmMessage = `총 ${totalCount}개 중 ${selectedCount}개가 선택되었습니다.\n선택되지 않은 ${deleteCount}개의 세그먼트를 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`;
            if (!confirm(confirmMessage)) {
                return;
            }

            // Show progress
            const deleteBtn = document.getElementById('delete-unselected-btn');
            if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.textContent = `삭제 중... 0/${deleteCount}`;
            }

            let deletedCount = 0;
            let failedCount = 0;

            for (let i = 0; i < unselectedSegments.length; i++) {
                const segment = unselectedSegments[i];
                try {
                    const response = await fetch(`/api/translator/projects/${currentProject.id}/segments/${segment.id}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        deletedCount++;
                        // Update progress
                        if (deleteBtn) {
                            deleteBtn.textContent = `삭제 중... ${deletedCount}/${deleteCount}`;
                        }
                    } else {
                        failedCount++;
                        console.error(`Failed to delete segment ${segment.id}: ${response.status}`);
                    }
                } catch (error) {
                    failedCount++;
                    console.error(`Error deleting segment ${segment.id}:`, error);
                }
            }

            // Reset button
            if (deleteBtn) {
                deleteBtn.disabled = false;
                deleteBtn.textContent = '미선택 화자 전체 삭제';
            }

            if (failedCount > 0) {
                alert(`${deletedCount}개 삭제 완료, ${failedCount}개 실패`);
            } else {
                alert(`✅ ${deletedCount}개 세그먼트가 삭제되었습니다.`);
            }

            // Clear selection after deletion
            selectedSegmentIds.clear();

            // Reload the project to reflect changes
            try {
                console.log('🔄 Fetching updated project...');
                const response = await fetch(`/api/translator/projects/${currentProject.id}`);
                if (response.ok) {
                    const updatedProject = await response.json();

                    console.log('📦 Received project data:', {
                        id: updatedProject.id,
                        segmentCount: updatedProject.segments.length,
                        status: updatedProject.status
                    });

                    // Update current project reference
                    currentProject = updatedProject;

                    // Update project title and status
                    if (projectTitle) {
                        projectTitle.textContent = updatedProject.base_name;
                    }
                    if (projectStatus) {
                        projectStatus.textContent = `상태: ${updatedProject.status} | 세그먼트: ${updatedProject.segments.length}개`;
                    }

                    console.log('🎨 Re-rendering segments...');
                    // Re-render segments with updated data
                    renderSegments(updatedProject);

                    console.log('✅ Segments rendered. DOM element count:', document.querySelectorAll('.segment-item').length);

                    // Update selection UI
                    updateSelectionUI();

                    console.log('✅ Project reloaded successfully. New segment count:', updatedProject.segments.length);
                    console.log('📊 Segment IDs:', updatedProject.segments.map(s => s.id).join(', '));
                } else {
                    console.error('❌ Failed to reload project:', response.status);
                    alert('프로젝트 새로고침에 실패했습니다. 페이지를 새로고침합니다.');
                    window.location.reload();
                }
            } catch (error) {
                console.error('❌ Failed to reload project:', error);
                alert('프로젝트 새로고침 중 오류가 발생했습니다. 페이지를 새로고침합니다.');
                window.location.reload();
            }
        }

        function updateSelectionUI() {
            if (selectionCountElem) {
                selectionCountElem.textContent = selectedSegmentIds.size.toString();
            }
            document.querySelectorAll('.segment-select').forEach(cb => {
                const id = cb.dataset.segmentId;
                cb.checked = selectedSegmentIds.has(id);
            });
        }

        function attachSelectionCheckboxListeners() {
            document.querySelectorAll('.segment-select').forEach(cb => {
                const segmentId = cb.dataset.segmentId;
                cb.addEventListener('change', (event) => {
                    if (!segmentId) {
                        return;
                    }
                    if (event.target.checked) {
                        selectedSegmentIds.add(segmentId);
                    } else {
                        selectedSegmentIds.delete(segmentId);
                    }
                    updateSelectionUI();
                });
            });
        }

        function switchSourceSelectorMode(mode) {
            if (sourceSelectorMode === mode) {
                updateSourceApplyState();
                return;
            }

            sourceSelectorMode = mode;
            selectedSourceIndex = null;
            selectedSavedResultId = null;
            selectedProjectId = null;
            updateSourceApplyState();

            if (sourceSelectorTabs) {
                sourceSelectorTabs.querySelectorAll('.tab').forEach(tab => {
                    const tabMode = tab.dataset.mode;
                    if (tabMode === mode) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
            }

            if (mode === 'downloads') {
                loadDownloadSources();
            } else if (mode === 'projects') {
                loadTranslatorProjects();
            } else {
                loadSavedResultOptions();
            }
        }

        function applySourceSelection() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }
            sourceSelectorApplyBtn.disabled = true;
            const originalLabel = sourceSelectorApplyBtn.textContent;
            sourceSelectorApplyBtn.textContent = '적용 중...';

            let request;

            if (sourceSelectorMode === 'downloads') {
                if (selectedSourceIndex === null || selectedSourceIndex < 0) {
                    alert('사용할 파일을 선택하세요.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                const option = availableSourceOptions[selectedSourceIndex];
                if (!option || !option.video_path) {
                    alert('선택한 항목이 올바르지 않습니다.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                const payload = {
                    source_video: option.video_path,
                    source_subtitle: option.subtitle_path || null
                };

                request = fetch(`/api/translator/projects/${currentProject.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
            } else if (sourceSelectorMode === 'projects') {
                if (!selectedProjectId) {
                    alert('불러올 프로젝트를 선택하세요.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                // 선택한 프로젝트로 이동
                window.location.href = `/translator?id=${selectedProjectId}`;
                return;
            } else {
                if (!selectedSavedResultId) {
                    alert('재해석 저장본을 선택하세요.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }
                const savedResult = savedResultDetailCache[selectedSavedResultId];
                if (!savedResult) {
                    alert('저장본 데이터를 불러오지 못했습니다. 다시 시도해주세요.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                request = fetch(`/api/translator/projects/${currentProject.id}/apply-saved-result`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ saved_result: savedResult })
                });
            }

            request
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    renderProject(project);
                    closeSourceSelectorModal();
                })
                .catch(err => {
                    console.error('Failed to update project source:', err);
                    alert('소스를 업데이트하지 못했습니다: ' + err.message);
                })
                .finally(() => {
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                });
        }



        function renderDownloads(items) {
            if (!items || !items.length) {
                downloadsList.innerHTML = '<p class="empty-state">다운로드된 영상이 없습니다. <a href="/ytdl">유튜브 다운로드</a> 도구를 사용하여 먼저 영상을 받아주세요.</p>';
                return;
            }
            const html = items.map((item, index) => {
                const hasSubtitle = item.subtitle_path;
                const videoName = item.base_name;
                const subtitleName = hasSubtitle ? item.subtitle_path.split('/').pop() : '자막 없음';
                return `
                    <div class="download-item" data-index="${index}">
                        <div class="item-header">
                            <input type="radio" name="source" id="source-${index}" value="${index}">
                            <label for="source-${index}">${videoName}</label>
                        </div>
                        <div class="item-meta">
                            <span>${item.video_path}</span>
                            <span class="${hasSubtitle ? 'text-success' : 'text-warning'}">${subtitleName}</span>
                        </div>
                    </div>
                `;
            }).join('');
            downloadsList.innerHTML = `<div class="form-group">${html}</div>`;
            downloadsList.querySelectorAll('input[name="source"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    const selectedIndex = parseInt(event.target.value, 10);
                    selectedSource = items[selectedIndex];
                    showAICommentarySection();
                });
            });
        }

        function fetchDownloads() {
            downloadsList.innerHTML = '<p class="empty-state">API 호출 중...</p>';

            // Add cache busting parameter
            const cacheBuster = Date.now();
            fetch(`/api/translator/downloads?_cb=${cacheBuster}`)
                .then(res => {
                    if (res.ok) {
                        return res.json();
                    } else {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                })
                .then(data => {
                    renderDownloads(data);
                })
                .catch(err => {
                    console.error('Download fetch error:', err);
                    downloadsList.innerHTML = `<p class="empty-state error">오류가 발생했습니다: ${err.message}</p>`;
                });
        }

        function applySettings(settings) {
            // alert('Received settings: ' + JSON.stringify(settings));
            if (settings) {
                document.getElementById('target-lang').value = settings.target_lang || 'ja';
                document.getElementById('translation-mode').value = settings.translation_mode || 'reinterpret';
                document.getElementById('tone-hint').value = settings.tone_hint || '드라마하고 유쾌하면서 유머러스하게';
            }
        }

        const loadSettingsBtn = document.getElementById('load-settings-btn');
        if (loadSettingsBtn) {
            loadSettingsBtn.addEventListener('click', () => {
                fetch('/api/translator/settings')
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(applySettings)
                    .catch(err => {
                        console.error(err);
                        alert('설정을 불러오는 데 실패했습니다.');
                    });
            });
        }

        const saveSettingsBtn = document.getElementById('save-settings-btn');
        if (saveSettingsBtn) {
            saveSettingsBtn.addEventListener('click', () => {
                const formData = new FormData(creationForm);
                const settings = {
                    target_lang: formData.get('target_lang'),
                    translation_mode: formData.get('translation_mode'),
                    tone_hint: formData.get('tone_hint') || null,
                };

                fetch('/api/translator/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings),
                })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(result => {
                    alert('설정이 저장되었습니다.');
                })
                .catch(err => {
                    console.error(err);
                    alert('설정 저장에 실패했습니다.');
                });
            });
        }

        creationForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selectedSource) {
                alert('번역할 소스 파일을 선택해주세요.');
                return;
            }
            const formData = new FormData(creationForm);
            const payload = {
                source_video: selectedSource.video_path,
                source_subtitle: selectedSource.subtitle_path || null,
                target_lang: formData.get('target_lang'),
                translation_mode: formData.get('translation_mode'),
                tone_hint: formData.get('tone_hint') || null,
            };
            const submitButton = creationForm.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.textContent = '생성 중...';
            fetch('/api/translator/projects', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            })
            .then(res => res.ok ? res.json() : Promise.reject(res))
            .then(project => {
                window.location.href = `/translator?id=${project.id}`;
            })
            .catch(err => {
                console.error(err);
                alert('오류가 발생했습니다.');
            })
            .finally(() => {
                submitButton.disabled = false;
                submitButton.textContent = '번역 프로젝트 생성';
            });
        });

        function renderProject(project) {
            currentProject = project;
            syncSelectionWithProject();
            creationView.classList.add('hidden');
            projectView.classList.remove('hidden');

            if (openSourceSelectorBtn) {
                openSourceSelectorBtn.style.display = 'inline-flex';
            }

            // base_name 또는 id에서 타임스탬프 제거한 값 표시
            let displayTitle = project.base_name || project.id || '이름 없음';
            if (displayTitle.startsWith('backup_')) {
                displayTitle = displayTitle.substring(7);
            }
            displayTitle = displayTitle.replace(/_\d{8}_\d{6}$/, '');

            projectTitle.textContent = displayTitle;
            projectStatus.textContent = `상태: ${project.status}`;

            // Reconstruct selectedSource from project data
            if (project.source_video) {
                selectedSource = {
                    video_path: project.source_video,
                    subtitle_path: project.source_subtitle,
                    base_name: project.base_name,
                    video_name: extractFileName(project.source_video),
                    subtitle_name: extractFileName(project.source_subtitle)
                };
            }

            projectActions.innerHTML = ''; // Clear actions

            const timelineToggleBtn = document.createElement('button');
            timelineToggleBtn.id = 'timeline-toggle-btn';
            timelineToggleBtn.className = 'btn-secondary';
            // 현재 모드를 표시: 타임라인 모드면 "📋 타임라인 편집기 (현재)", 카드 모드면 "타임라인 편집기로 전환"
            timelineToggleBtn.textContent = isTimelineView ? '📋 카드 보기' : '📋 타임라인 편집기';
            timelineToggleBtn.addEventListener('click', () => {
                isTimelineView = !isTimelineView;
                timelineToggleBtn.textContent = isTimelineView ? '📋 카드 보기' : '📋 타임라인 편집기';
                renderSegments(currentProject);
            });

            const sourceSelectorActionBtn = document.createElement('button');
            sourceSelectorActionBtn.id = 'project-source-selector-btn';
            sourceSelectorActionBtn.className = 'btn-secondary';
            sourceSelectorActionBtn.textContent = '파일 불러오기';
            sourceSelectorActionBtn.addEventListener('click', openSourceSelectorModal);
            projectActions.appendChild(sourceSelectorActionBtn);
            projectActions.appendChild(timelineToggleBtn);

            const selectionControls = buildSelectionControls();
            projectActions.appendChild(selectionControls);
            updateSelectionUI();

            // Save buttons
            const saveBtn = document.createElement('button');
            saveBtn.id = 'save-project-btn';
            saveBtn.className = 'btn-primary';
            saveBtn.textContent = '💾 저장';
            saveBtn.addEventListener('click', saveProject);
            projectActions.appendChild(saveBtn);

            const saveAsBtn = document.createElement('button');
            saveAsBtn.id = 'save-as-project-btn';
            saveAsBtn.className = 'btn-secondary';
            saveAsBtn.textContent = '💾 다른 이름으로 저장';
            saveAsBtn.addEventListener('click', saveProjectAs);
            projectActions.appendChild(saveAsBtn);

            // Always show delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.id = 'delete-project-btn';
            deleteBtn.className = 'btn-secondary';
            deleteBtn.style.background = 'linear-gradient(120deg, #ff6d6d, #ff3d7f)';
            deleteBtn.style.color = '#fff6f6';
            deleteBtn.textContent = '프로젝트 삭제';
            deleteBtn.addEventListener('click', deleteProject);
            projectActions.appendChild(deleteBtn);

            if (project.status === 'segmenting' || project.status === 'draft') {
                const translateBtn = document.createElement('button');
                translateBtn.id = 'translate-btn';
                translateBtn.className = 'btn-primary';
                translateBtn.textContent = '번역 실행';
                translateBtn.addEventListener('click', runTranslation);
                projectActions.appendChild(translateBtn);

                const commentaryBtn = document.createElement('button');
                commentaryBtn.id = 'korean-commentary-btn';
                commentaryBtn.className = 'btn-secondary';
                commentaryBtn.textContent = '한국어 AI 해설 넣기';
                commentaryBtn.style.background = '#28a745';
                commentaryBtn.style.color = 'white';
                commentaryBtn.addEventListener('click', generateKoreanCommentary);
                projectActions.appendChild(commentaryBtn);
            } else if (project.status === 'voice_ready') {
                // Voice synthesis mode selector
                const voiceModeDiv = document.createElement('div');
                voiceModeDiv.style.display = 'flex';
                voiceModeDiv.style.alignItems = 'center';
                voiceModeDiv.style.gap = '10px';
                voiceModeDiv.style.marginBottom = '10px';

                const voiceModeLabel = document.createElement('label');
                voiceModeLabel.textContent = '음성 합성 대상:';
                voiceModeLabel.style.fontWeight = 'bold';

                const voiceModeSelect = document.createElement('select');
                voiceModeSelect.id = 'voice-synthesis-mode';
                voiceModeSelect.innerHTML = `
                    <option value="subtitle" ${project.voice_synthesis_mode === 'subtitle' ? 'selected' : ''}>자막만</option>
                    <option value="commentary" ${project.voice_synthesis_mode === 'commentary' ? 'selected' : ''}>해설만</option>
                    <option value="both" ${project.voice_synthesis_mode === 'both' ? 'selected' : ''}>자막+해설</option>
                `;
                voiceModeSelect.addEventListener('change', updateVoiceSynthesisMode);

                voiceModeDiv.appendChild(voiceModeLabel);
                voiceModeDiv.appendChild(voiceModeSelect);
                projectActions.appendChild(voiceModeDiv);

                const voiceBtn = document.createElement('button');
                voiceBtn.id = 'voice-btn';
                voiceBtn.className = 'btn-primary';
                voiceBtn.textContent = '음성 생성';
                voiceBtn.addEventListener('click', runVoiceSynthesis);
                projectActions.appendChild(voiceBtn);

                const reverseTranslateAllBtn = document.createElement('button');
                reverseTranslateAllBtn.id = 'reverse-translate-all-btn';
                reverseTranslateAllBtn.className = 'btn-secondary';
                reverseTranslateAllBtn.style.background = 'rgba(255, 209, 102, 0.15)';
                reverseTranslateAllBtn.style.border = '1px solid rgba(255, 209, 102, 0.6)';
                reverseTranslateAllBtn.style.color = '#ffd166';
                reverseTranslateAllBtn.textContent = '전체 역번역';
                reverseTranslateAllBtn.addEventListener('click', runReverseTranslateAll);
                projectActions.appendChild(reverseTranslateAllBtn);
            } else if (project.status === 'voice_complete') {
                // Voice synthesis mode selector (keep it for re-generation)
                const voiceModeDiv = document.createElement('div');
                voiceModeDiv.style.display = 'flex';
                voiceModeDiv.style.alignItems = 'center';
                voiceModeDiv.style.gap = '10px';
                voiceModeDiv.style.marginBottom = '10px';

                const voiceModeLabel = document.createElement('label');
                voiceModeLabel.textContent = '음성 합성 대상:';
                voiceModeLabel.style.fontWeight = 'bold';

                const voiceModeSelect = document.createElement('select');
                voiceModeSelect.id = 'voice-synthesis-mode';
                voiceModeSelect.innerHTML = `
                    <option value="subtitle" ${project.voice_synthesis_mode === 'subtitle' ? 'selected' : ''}>자막만</option>
                    <option value="commentary" ${project.voice_synthesis_mode === 'commentary' ? 'selected' : ''}>해설만</option>
                    <option value="both" ${project.voice_synthesis_mode === 'both' ? 'selected' : ''}>자막+해설</option>
                `;
                voiceModeSelect.addEventListener('change', updateVoiceSynthesisMode);

                voiceModeDiv.appendChild(voiceModeLabel);
                voiceModeDiv.appendChild(voiceModeSelect);
                projectActions.appendChild(voiceModeDiv);

                const editBtn = document.createElement('button');
                editBtn.id = 'edit-btn';
                editBtn.className = 'btn-secondary';
                editBtn.textContent = '편집 모드로 돌아가기';
                editBtn.addEventListener('click', () => {
                    // Reset project status to allow editing
                    fetch(`/api/translator/projects/${currentProject.id}/reset-to-translated`, {
                        method: 'POST'
                    })
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(renderProject)
                    .catch(err => {
                        console.error(err);
                        alert('편집 모드 전환 중 오류가 발생했습니다.');
                    });
                });
                projectActions.appendChild(editBtn);

                const voiceBtn = document.createElement('button');
                voiceBtn.id = 'voice-btn';
                voiceBtn.className = 'btn-secondary';
                voiceBtn.textContent = '음성 재생성';
                voiceBtn.addEventListener('click', runVoiceSynthesis);
                projectActions.appendChild(voiceBtn);

                const reverseTranslateAllBtn = document.createElement('button');
                reverseTranslateAllBtn.id = 'reverse-translate-all-btn';
                reverseTranslateAllBtn.className = 'btn-secondary';
                reverseTranslateAllBtn.textContent = '전체 역번역';
                reverseTranslateAllBtn.addEventListener('click', runReverseTranslateAll);
                projectActions.appendChild(reverseTranslateAllBtn);

                const renderBtn = document.createElement('button');
                renderBtn.id = 'render-btn';
                renderBtn.className = 'btn-primary';
                renderBtn.textContent = '비디오 렌더링';
                renderBtn.addEventListener('click', runRender);
                projectActions.appendChild(renderBtn);
            }

            renderSegments(project);

            // Update AI commentary section with selected source info
            showAICommentarySection();
        }

        function runTranslation() {
            const btn = document.getElementById('translate-btn');
            btn.disabled = true;
            btn.textContent = '번역 중...';

            fetch(`/api/translator/projects/${currentProject.id}/translate`, { method: 'POST' })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(renderProject)
                .catch(err => {
                    console.error(err);
                    alert('번역 실행 중 오류가 발생했습니다.');
                })
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = '번역 실행';
                    }
                });
        }

        function runVoiceSynthesis() {
            const btn = document.getElementById('voice-btn');
            btn.disabled = true;
            btn.textContent = '음성 생성 중...';

            fetch(`/api/translator/projects/${currentProject.id}/voice`, { method: 'POST' })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(renderProject)
                .catch(err => {
                    console.error(err);
                    alert('음성 생성 중 오류가 발생했습니다.');
                })
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = '음성 생성';
                    }
                });
        }

        function runRender() {
            const btn = document.getElementById('render-btn');
            btn.disabled = true;
            btn.textContent = '렌더링 중...';

            fetch(`/api/translator/projects/${currentProject.id}/render`, { method: 'POST' })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(project => {
                    renderProject(project);
                    const videoPath = project.extra.rendered_video_path;
                    if (videoPath) {
                        const videoLink = document.createElement('a');
                        videoLink.href = videoPath.replace('/home/sk/ws/mcp-playwright', '');
                        videoLink.textContent = '다운로드';
                        videoLink.target = '_blank';
                        projectActions.appendChild(videoLink);
                    }
                })
                .catch(err => {
                    console.error(err);
                    alert('렌더링 중 오류가 발생했습니다.');
                })
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = '비디오 렌더링';
                    }
                });
        }

    async function saveSegmentText(segmentId, textType, textValue) {
        try {
            const response = await fetch(`/api/translator/projects/${currentProject.id}/segments`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    segment_id: segmentId,
                    text_type: textType,
                    text_value: textValue
                })
            });

            if (response.ok) {
                updateSegmentCache(segmentId, textType, textValue);
                console.log(`Successfully saved ${textType} text for segment ${segmentId}`);
                return true;
            } else {
                console.error('Failed to save segment text:', response.status, response.statusText);
                return false;
            }
        } catch (error) {
            console.error('Error saving segment text:', error);
            return false;
        }
    }

        function loadProject(id) {
            fetch(`/api/translator/projects/${id}`)
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(renderProject)
                .catch(err => {
                    console.error(err);
                    creationView.innerHTML = '<p class="empty-state error">프로젝트를 불러오지 못했습니다.</p>';
                });
        }

        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('id') || urlParams.get('project');
        const viewModeParam = urlParams.get('view') || urlParams.get('mode');
        if (viewModeParam) {
            const normalized = viewModeParam.toLowerCase();
            if (normalized === 'card' || normalized === 'list') {
                isTimelineView = false;
            } else if (normalized === 'timeline') {
                isTimelineView = true;
            }
        }

        function loadInitialSettings() {
            const cacheBuster = Date.now();
            fetch(`/api/translator/settings?_cb=${cacheBuster}`)
                .then(res => {
                    if (res.ok) {
                        return res.json();
                    } else {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                })
                .then(settings => {
                    applySettings(settings);
                })
                .catch(err => {
                    console.error('Failed to load initial settings:', err);
                });
        }

        function attachSegmentEventListeners() {
            // Edit text buttons
            document.querySelectorAll('.btn-edit-text').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const textType = e.target.dataset.type;
                    const textContent = e.target.closest('.text-content');
                    const textDisplay = textContent.querySelector('.text-display');
                    const textEdit = textContent.querySelector('.text-edit');

                    if (e.target.textContent === '수정') {
                        // Enter edit mode
                        textEdit.value = textDisplay.textContent;
                        textDisplay.style.display = 'none';
                        textEdit.style.display = '';
                        textEdit.focus();
                        e.target.textContent = '저장';
                    } else if (e.target.textContent === '저장') {
                        // Save changes
                        const newText = textEdit.value.trim();

                        // 저장 중 표시
                        const originalText = e.target.textContent;
                        e.target.textContent = '저장 중...';
                        e.target.disabled = true;

                        // 서버에 저장
                        saveSegmentText(segmentId, textType, newText).then(success => {
                            if (success) {
                                textDisplay.textContent = newText;
                                textDisplay.style.display = '';
                                textEdit.style.display = 'none';
                                textEdit.value = newText;
                                e.target.textContent = '수정';

                                // 저장 시간 표시
                                const now = new Date();
                                const timeString = now.toLocaleString('ko-KR', {
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit'
                                });
                                const lastModifiedDiv = textContent.querySelector('.last-modified');
                                lastModifiedDiv.textContent = `마지막 저장: ${timeString}`;
                                lastModifiedDiv.style.color = '#28a745';

                                // 성공 표시
                                const originalColor = e.target.style.backgroundColor;
                                e.target.textContent = '✓ 저장완료';
                                e.target.style.backgroundColor = '#28a745';
                                e.target.style.color = 'white';
                                setTimeout(() => {
                                    e.target.textContent = '수정';
                                    e.target.style.backgroundColor = originalColor;
                                    e.target.style.color = '';
                                    // 저장 시간 색상을 원래대로
                                    lastModifiedDiv.style.color = '#888';
                                }, 3000);
                            } else {
                                alert('저장에 실패했습니다. 다시 시도해주세요.');
                                e.target.textContent = '저장';
                            }
                            e.target.disabled = false;
                        });
                    }
                });
            });

            // Copy text buttons
            document.querySelectorAll('.btn-copy-text').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const textType = e.target.dataset.type;
                    const textDisplay = e.target.closest('.text-content').querySelector('.text-display');
                    const textToCopy = textDisplay.textContent.trim();

                    if (!textToCopy) {
                        alert('복사할 텍스트가 없습니다.');
                        return;
                    }

                    try {
                        await navigator.clipboard.writeText(textToCopy);
                        e.target.textContent = '복사됨';
                        setTimeout(() => {
                            e.target.textContent = '복사';
                        }, 1000);
                    } catch (err) {
                        console.error('클립보드 복사 실패:', err);
                        // Fallback for older browsers
                        const textarea = document.createElement('textarea');
                        textarea.value = textToCopy;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);

                        e.target.textContent = '복사됨';
                        setTimeout(() => {
                            e.target.textContent = '복사';
                        }, 1000);
                    }
                });
            });

            // Reverse translate buttons (Japanese to Korean)
            document.querySelectorAll('.btn-translate-reverse').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const japaneseText = e.target.closest('.text-content').querySelector('.text-display').textContent.trim();

                    if (!japaneseText) {
                        alert('번역할 일본어 텍스트가 없습니다.');
                        return;
                    }

                    e.target.disabled = true;
                    e.target.textContent = '번역중...';

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/reverse-translate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                segment_id: segmentId,
                                japanese_text: japaneseText
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const result = await response.json();

                        // Update reverse translation Korean text display
                        const segmentItem = e.target.closest('.segment-item');
                        const reverseKoreanTextDisplay = segmentItem.querySelector('.text-row.korean.reverse .text-display');
                        if (reverseKoreanTextDisplay) {
                            reverseKoreanTextDisplay.textContent = result.korean_text;
                            const reverseTextContent = reverseKoreanTextDisplay.closest('.text-content');
                            if (reverseTextContent) {
                                const reverseEdit = reverseTextContent.querySelector('.text-edit');
                                if (reverseEdit) {
                                    reverseEdit.value = result.korean_text;
                                }
                                const reverseLastModified = reverseTextContent.querySelector('.last-modified');
                                if (reverseLastModified) {
                                    const now = new Date();
                                    const timeString = now.toLocaleString('ko-KR', {
                                        month: '2-digit',
                                        day: '2-digit',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                    reverseLastModified.textContent = `마지막 저장: ${timeString}`;
                                    reverseLastModified.style.color = '#28a745';
                                    setTimeout(() => {
                                        reverseLastModified.style.color = '#888';
                                    }, 3000);
                                }
                            }
                        } else {
                            console.error('Cannot find reverse translation text display element');
                        }

                        // Update the server with the new reverse translated text
                        updateSegmentText(segmentId, 'reverse_translated', result.korean_text);

                    } catch (err) {
                        console.error('역번역 실패:', err);
                        alert('역번역에 실패했습니다: ' + err.message);
                    } finally {
                        e.target.disabled = false;
                        e.target.textContent = '역번역';
                    }
                });
            });

            // Delete text buttons
            document.querySelectorAll('.btn-delete-text').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const textType = e.target.dataset.type;
                    const label = TEXT_TYPE_LABELS[textType] || '선택한 내용';

                    if (confirm(`정말로 "${label}" 내용을 삭제하시겠습니까?`)) {
                        updateSegmentText(segmentId, textType, '');
                        const textContent = e.target.closest('.text-content');
                        const textDisplay = textContent.querySelector('.text-display');
                        const textEdit = textContent.querySelector('.text-edit');
                        const lastModifiedDiv = textContent.querySelector('.last-modified');
                        textDisplay.textContent = '';
                        if (textEdit) {
                            textEdit.value = '';
                        }
                        if (lastModifiedDiv) {
                            lastModifiedDiv.textContent = '';
                        }
                    }
                });
            });

            // Delete segment buttons
            document.querySelectorAll('.btn-delete-segment').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    if (!segmentId) {
                        return;
                    }
                    if (!confirm('이 세그먼트를 삭제하시겠습니까?')) {
                        return;
                    }
                    deleteSegment(segmentId, e.target);
                });
            });

            // Move up buttons
            document.querySelectorAll('.btn-move-up').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    moveSegment(segmentId, 'up');
                });
            });

            // Move down buttons
            document.querySelectorAll('.btn-move-down').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    moveSegment(segmentId, 'down');
                });
            });

            // Play audio buttons
            document.querySelectorAll('.btn-play-audio').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const audioPath = e.target.dataset.audioPath;
                    if (!audioPath) {
                        alert('음성 파일 경로가 없습니다.');
                        return;
                    }
                    const audio = new Audio(audioPath);
                    audio.play().catch(err => {
                        console.error('Failed to play audio:', err);
                        alert('음성 재생에 실패했습니다: ' + err.message);
                    });
                });
            });

            // Generate audio buttons
            document.querySelectorAll('.btn-generate-audio').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    if (!segmentId) {
                        return;
                    }

                    const voice = getSelectedVoice();
                    const audioFormat = getSelectedAudioFormat();

                    e.target.disabled = true;
                    const originalText = e.target.textContent;
                    e.target.textContent = '생성 중...';

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/generate-audio`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                segment_id: segmentId,
                                voice: voice,
                                audio_format: audioFormat
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const project = await response.json();
                        currentProject = project;
                        renderProject(project);
                        alert('음성 생성 완료!');
                    } catch (err) {
                        console.error('Failed to generate audio:', err);
                        alert('음성 생성에 실패했습니다: ' + err.message);
                    } finally {
                        e.target.disabled = false;
                        e.target.textContent = originalText;
                    }
                });
            });
        }

        function updateSegmentText(segmentId, textType, newText) {
            const payload = {
                segment_id: segmentId,
                text_type: textType,
                text_value: newText
            };

            fetch(`/api/translator/projects/${currentProject.id}/segments`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                // Update successful
                updateSegmentCache(segmentId, textType, newText);
                console.log(`Updated ${textType} for segment ${segmentId}`);
            })
            .catch(err => {
                console.error('Failed to update segment text:', err);
                alert('텍스트 업데이트에 실패했습니다.');
            });
        }

        function moveSegment(segmentId, direction) {
            const segments = currentProject.segments;
            const currentIndex = segments.findIndex(seg => seg.id === segmentId);

            if (currentIndex === -1) {
                console.error('Segment not found:', segmentId);
                return;
            }

            let newIndex;
            if (direction === 'up' && currentIndex > 0) {
                newIndex = currentIndex - 1;
            } else if (direction === 'down' && currentIndex < segments.length - 1) {
                newIndex = currentIndex + 1;
            } else {
                // Cannot move - already at boundary
                return;
            }

            // Swap segments in the array
            const segmentToMove = segments[currentIndex];
            const segmentAtTarget = segments[newIndex];

            segments[currentIndex] = segmentAtTarget;
            segments[newIndex] = segmentToMove;

            // Update clip_index values to maintain order
            segments.forEach((seg, index) => {
                seg.clip_index = index;
            });

            // Save the reordered segments to the server
            fetch(`/api/translator/projects/${currentProject.id}/reorder-segments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    segment_orders: segments.map((seg, index) => ({
                        segment_id: seg.id,
                        new_index: index
                    }))
                })
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                // Re-render the project to show the new order
                renderProject(currentProject);
            })
            .catch(err => {
                console.error('Failed to reorder segments:', err);
                alert('세그먼트 순서 변경에 실패했습니다.');
                // Revert the local changes
                segments[newIndex] = segmentToMove;
                segments[currentIndex] = segmentAtTarget;
            });
        }

        function deleteSegment(segmentId, triggerBtn) {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            if (triggerBtn) {
                triggerBtn.disabled = true;
            }

            selectedSegmentIds.delete(segmentId);
            updateSelectionUI();

            fetch(`/api/translator/projects/${currentProject.id}/segments/${segmentId}`, {
                method: 'DELETE'
            })
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    renderProject(project);
                })
                .catch(err => {
                    console.error('Failed to delete segment:', err);
                    alert('세그먼트를 삭제하지 못했습니다: ' + err.message);
                    if (triggerBtn) {
                        triggerBtn.disabled = false;
                    }
                });
        }

        function updateVoiceSynthesisMode() {
            const select = document.getElementById('voice-synthesis-mode');
            const mode = select.value;

            fetch(`/api/translator/projects/${currentProject.id}/voice-synthesis-mode`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ voice_synthesis_mode: mode })
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                console.log(`Voice synthesis mode updated to: ${mode}`);
                currentProject.voice_synthesis_mode = mode;
            })
            .catch(err => {
                console.error('Failed to update voice synthesis mode:', err);
                alert('음성 합성 모드 업데이트에 실패했습니다.');
                // Revert select to previous value
                select.value = currentProject.voice_synthesis_mode;
            });
        }

        function runReverseTranslateAll() {
            const btn = document.getElementById('reverse-translate-all-btn');
            btn.disabled = true;
            btn.textContent = '전체 역번역 중...';

            let completedCount = 0;
            const totalSegments = currentProject.segments.filter(seg => seg.translated_text).length;

            if (totalSegments === 0) {
                alert('역번역할 일본어 텍스트가 없습니다.');
                btn.disabled = false;
                btn.textContent = '전체 역번역';
                return;
            }

            // Process each segment with Japanese text
            currentProject.segments.forEach(async (segment, index) => {
                if (!segment.translated_text) return;

                try {
                    const response = await fetch(`/api/translator/projects/${currentProject.id}/reverse-translate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            segment_id: segment.id,
                            japanese_text: segment.translated_text
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();

                        // Update UI
                        const segmentElement = document.querySelector(`[data-segment-id="${segment.id}"]`);
                        if (segmentElement) {
                            const reverseDisplay = segmentElement.querySelector('.text-row.korean.reverse .text-display');
                            if (reverseDisplay) {
                                reverseDisplay.textContent = result.korean_text;
                            }
                        }

                        // Update server
                        updateSegmentText(segment.id, 'reverse_translated', result.korean_text);
                    }
                } catch (err) {
                    console.error(`Failed to reverse translate segment ${segment.id}:`, err);
                }

                completedCount++;
                if (completedCount === totalSegments) {
                    btn.disabled = false;
                    btn.textContent = '전체 역번역';
                    alert(`전체 역번역 완료! (${completedCount}개 세그먼트)`);
                }
            });
        }

        function showAICommentarySection() {
            const aiCommentarySection = document.getElementById('ai-commentary-section');
            const translationSettingsSection = document.getElementById('translation-settings-section');

            // Show AI commentary section
            aiCommentarySection.style.display = 'block';

            // Keep translation settings section visible
            translationSettingsSection.style.display = 'block';

            // Update selected source info if selectedSource is available
            const videoNameElem = document.getElementById('selected-video-name');
            const subtitleNameElem = document.getElementById('selected-subtitle-name');

            const fallbackVideoPath = (selectedSource && selectedSource.video_path) || (currentProject && currentProject.source_video) || null;
            const fallbackSubtitlePath = (selectedSource && selectedSource.subtitle_path) || (currentProject && currentProject.source_subtitle) || null;

            if (!selectedSource && (fallbackVideoPath || fallbackSubtitlePath) && currentProject) {
                selectedSource = {
                    video_path: fallbackVideoPath,
                    subtitle_path: fallbackSubtitlePath,
                    base_name: currentProject.base_name,
                    video_name: extractFileName(fallbackVideoPath),
                    subtitle_name: extractFileName(fallbackSubtitlePath)
                };
            }

            const videoLabel = extractFileName(fallbackVideoPath) || (currentProject && currentProject.base_name) || '선택되지 않음';
            const subtitleLabel = fallbackSubtitlePath ? extractFileName(fallbackSubtitlePath) : '자막 없음';

            videoNameElem.textContent = videoLabel;
            subtitleNameElem.textContent = subtitleLabel;

            // Scroll to AI commentary section with a slight delay for better UX
            setTimeout(() => {
                aiCommentarySection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }, 100);
        }

        // Make function globally accessible for debugging
        window.showAICommentarySection = showAICommentarySection;

        function showTranslationSettings() {
            const translationSettingsSection = document.getElementById('translation-settings-section');
            translationSettingsSection.style.display = 'block';

            // Scroll to translation settings
            translationSettingsSection.scrollIntoView({ behavior: 'smooth' });
        }

        async function generateAICommentary() {
            if (!selectedSource) {
                alert('소스가 선택되지 않았습니다.');
                return;
            }

            const generateBtn = document.getElementById('generate-commentary-btn');
            const skipBtn = document.getElementById('skip-commentary-btn');
            const statusDiv = document.getElementById('commentary-generation-status');

            // Disable buttons and show status
            generateBtn.disabled = true;
            skipBtn.disabled = true;
            generateBtn.textContent = 'AI 해설 생성 중...';
            statusDiv.style.display = 'block';

            try {
                // First create the project
                const projectData = {
                    source_video: selectedSource.video_path,
                    source_subtitle: selectedSource.subtitle_path || null,
                    target_lang: 'ja',
                    translation_mode: 'literal',
                    tone_hint: '간결하게'
                };

                const createResponse = await fetch('/api/translator/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectData)
                });

                if (!createResponse.ok) {
                    throw new Error(`프로젝트 생성 실패: ${createResponse.status}`);
                }

                const project = await createResponse.json();

                // Then generate AI commentary
                const commentaryResponse = await fetch(`/api/translator/projects/${project.id}/generate-commentary`, {
                    method: 'POST'
                });

                if (!commentaryResponse.ok) {
                    throw new Error(`AI 해설 생성 실패: ${commentaryResponse.status}`);
                }

                const updatedProject = await commentaryResponse.json();

                // Load the project in the UI
                renderProject(updatedProject);

            } catch (error) {
                console.error('AI 해설 생성 오류:', error);
                alert(`AI 해설 생성 중 오류가 발생했습니다: ${error.message}`);

                // Re-enable buttons
                generateBtn.disabled = false;
                skipBtn.disabled = false;
                generateBtn.textContent = 'AI 해설 생성하기';
                statusDiv.style.display = 'none';
            }
        }

        function skipAICommentary() {
            showTranslationSettings();
        }

        async function generateKoreanCommentary() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const btn = document.getElementById('korean-commentary-btn');
            btn.disabled = true;
            btn.textContent = '한국어 AI 해설 생성 중...';

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/generate-korean-commentary`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response details:', {
                        status: response.status,
                        statusText: response.statusText,
                        url: response.url,
                        body: errorText
                    });
                    throw new Error(`한국어 AI 해설 생성 실패: ${response.status} - ${response.statusText} - ${errorText}`);
                }

                const updatedProject = await response.json();

                // Update current project and re-render
                renderProject(updatedProject);

                alert('한국어 AI 해설이 성공적으로 생성되었습니다!');

            } catch (error) {
                console.error('한국어 해설 생성 오류:', error);
                alert(`한국어 AI 해설 생성 중 오류가 발생했습니다: ${error.message}`);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = '한국어 AI 해설 넣기';
                }
            }
        }

        async function saveProject() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const saveBtn = document.getElementById('save-project-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = '💾 저장 중...';
            }

            try {
                // 현재 프로젝트 상태를 서버에 저장 (이미 각 수정 시 저장되므로 확인 메시지만 표시)
                const response = await fetch(`/api/translator/projects/${currentProject.id}`);
                if (response.ok) {
                    alert('✅ 프로젝트가 저장되었습니다.');
                } else {
                    throw new Error('프로젝트 저장 실패');
                }
            } catch (error) {
                console.error('Save project error:', error);
                alert('❌ 프로젝트 저장에 실패했습니다.');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = '💾 저장';
                }
            }
        }

        async function saveProjectAs() {
            if (!currentProject) {
                alert('프로젝트가 로드되지 않았습니다.');
                return;
            }

            const newName = prompt('새 프로젝트 이름을 입력하세요:', currentProject.base_name + '_복사본');
            if (!newName || newName.trim() === '') {
                return;
            }

            const saveAsBtn = document.getElementById('save-as-project-btn');
            if (saveAsBtn) {
                saveAsBtn.disabled = true;
                saveAsBtn.textContent = '💾 저장 중...';
            }

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_name: newName.trim() })
                });

                if (response.ok) {
                    const newProject = await response.json();
                    alert(`✅ 프로젝트가 "${newProject.base_name}"로 복사되었습니다.`);

                    // 새 프로젝트로 이동할지 물어보기
                    if (confirm('복사된 프로젝트로 이동하시겠습니까?')) {
                        window.location.href = `/translator?id=${newProject.id}`;
                    }
                } else {
                    throw new Error('프로젝트 복사 실패');
                }
            } catch (error) {
                console.error('Save project as error:', error);
                alert('❌ 프로젝트 복사에 실패했습니다.');
            } finally {
                if (saveAsBtn) {
                    saveAsBtn.disabled = false;
                    saveAsBtn.textContent = '💾 다른 이름으로 저장';
                }
            }
        }

        function deleteProject() {
            if (!confirm('정말로 이 프로젝트를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                return;
            }

            const deleteBtn = document.getElementById('delete-project-btn');
            deleteBtn.disabled = true;
            deleteBtn.textContent = '삭제 중...';

            fetch(`/api/translator/projects/${currentProject.id}`, {
                method: 'DELETE'
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                alert('프로젝트가 삭제되었습니다.');
                window.location.href = '/translator';
            })
            .catch(err => {
                console.error('Failed to delete project:', err);
                alert('프로젝트 삭제에 실패했습니다.');
            })
            .finally(() => {
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = '프로젝트 삭제';
                }
            });
        }

        function attachTimeEditListeners() {
            // Time display click to edit
            document.querySelectorAll('.time-display').forEach(timeDisplay => {
                timeDisplay.addEventListener('click', () => {
                    const segmentTimeDiv = timeDisplay.closest('.segment-time');
                    if (!segmentTimeDiv) {
                        return;
                    }
                    const timeEdit = segmentTimeDiv.querySelector('.time-edit');
                    if (!timeEdit) {
                        return;
                    }

                    // Hide display, show edit
                    timeDisplay.style.display = 'none';
                    timeEdit.style.display = 'flex';

                    // Focus on first input
                    const startInput = timeEdit.querySelector('.start-input');
                    if (startInput) {
                        startInput.focus();
                        startInput.select();
                    }
                });
            });

            // Save time button
            document.querySelectorAll('.btn-save-time').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentTimeDiv = e.target.closest('.segment-time');
                    const segmentId = segmentTimeDiv.dataset.segmentId;
                    const timeDisplay = segmentTimeDiv.querySelector('.time-display');
                    const timeEdit = segmentTimeDiv.querySelector('.time-edit');
                    if (!timeDisplay || !timeEdit) {
                        return;
                    }

                    const startInput = timeEdit.querySelector('.start-input');
                    const endInput = timeEdit.querySelector('.end-input');

                    const startTime = parseFloat(startInput.value);
                    const endTime = parseFloat(endInput.value);

                    // Validation
                    if (Number.isNaN(startTime) || Number.isNaN(endTime)) {
                        alert('시간 형식이 올바르지 않습니다.');
                        return;
                    }

                    if (startTime >= endTime) {
                        alert('시작 시간은 종료 시간보다 작아야 합니다.');
                        return;
                    }

                    if (startTime < 0 || endTime < 0) {
                        alert('시간은 0보다 크거나 같아야 합니다.');
                        return;
                    }

                    // Save to server
                    btn.disabled = true;
                    const originalText = btn.textContent;
                    btn.textContent = '저장 중...';

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/segments/time`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                segment_id: segmentId,
                                start_time: startTime,
                                end_time: endTime
                            })
                        });

                        if (response.ok) {
                            // Update display
                            const startLabel = timeDisplay.querySelector('.start-time');
                            const endLabel = timeDisplay.querySelector('.end-time');
                            const durationLabel = timeDisplay.querySelector('.time-duration');

                            if (startLabel) {
                                startLabel.textContent = formatTimestamp(startTime);
                            }
                            if (endLabel) {
                                endLabel.textContent = formatTimestamp(endTime);
                            }
                            if (durationLabel) {
                                durationLabel.textContent = `(${Math.max(endTime - startTime, 0).toFixed(1)}초)`;
                            }

                            timeEdit.style.display = 'none';
                            timeDisplay.style.display = 'flex';

                            // Success feedback
                            btn.textContent = '✓';
                            btn.style.background = '#28a745';
                            setTimeout(() => {
                                btn.textContent = originalText || '저장';
                                btn.style.background = '';
                            }, 1500);
                        } else {
                            throw new Error('서버 저장 실패');
                        }
                    } catch (error) {
                        console.error('Time save error:', error);
                        alert('시간 저장에 실패했습니다.');
                    } finally {
                        btn.disabled = false;
                        if (btn.textContent === '저장 중...') {
                            btn.textContent = originalText || '저장';
                        }
                    }
                });
            });

            // Cancel time edit button
            document.querySelectorAll('.btn-cancel-time').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentTimeDiv = e.target.closest('.segment-time');
                    const timeDisplay = segmentTimeDiv.querySelector('.time-display');
                    const timeEdit = segmentTimeDiv.querySelector('.time-edit');

                    // Reset inputs to original values
                    const segmentId = segmentTimeDiv.dataset.segmentId;
                    const segment = currentProject.segments.find(s => s.id === segmentId);
                    if (segment) {
                        timeEdit.querySelector('.start-input').value = segment.start.toFixed(2);
                        timeEdit.querySelector('.end-input').value = segment.end.toFixed(2);
                    }

                    // Hide edit, show display
                    timeEdit.style.display = 'none';
                    timeDisplay.style.display = 'flex';
                });
            });
        }

        if (openSourceSelectorBtn) {
            openSourceSelectorBtn.addEventListener('click', openSourceSelectorModal);
        }
        if (sourceSelectorCloseBtn) {
            sourceSelectorCloseBtn.addEventListener('click', closeSourceSelectorModal);
        }
        if (sourceSelectorCancelBtn) {
            sourceSelectorCancelBtn.addEventListener('click', closeSourceSelectorModal);
        }
        if (sourceSelectorApplyBtn) {
            sourceSelectorApplyBtn.addEventListener('click', applySourceSelection);
        }
        if (sourceSelectorModal) {
            sourceSelectorModal.addEventListener('click', (event) => {
                if (event.target === sourceSelectorModal) {
                    closeSourceSelectorModal();
                }
            });
        }
        if (sourceSelectorTabs) {
            sourceSelectorTabs.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const mode = tab.dataset.mode;
                    if (mode) {
                        switchSourceSelectorMode(mode);
                    }
                });
            });
        }
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && sourceSelectorModal && !sourceSelectorModal.classList.contains('hidden')) {
                closeSourceSelectorModal();
            }
        });

        // Add event listeners for AI commentary buttons
        document.getElementById('generate-commentary-btn').addEventListener('click', generateAICommentary);
        document.getElementById('skip-commentary-btn').addEventListener('click', skipAICommentary);

        if (projectId) {
            loadProject(projectId);
        } else {
            creationView.classList.remove('hidden');
            projectView.classList.add('hidden');
            fetchDownloads();
            loadInitialSettings();

            // Show AI commentary section on initial load
            showAICommentarySection();
        }
    })();
    </script>

    <style>
        .text-row.commentary {
            background: #f8f9ff;
            border-left: 3px solid #6c5ce7;
            padding-left: 10px;
            margin: 8px 0;
        }

        .text-row.commentary label {
            color: #6c5ce7;
            font-weight: bold;
        }

        .text-row.commentary .text-edit {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }

        .text-row.commentary .text-display {
            font-style: italic;
            color: #555;
            min-height: 20px;
        }

        .text-row.commentary .text-display:empty::before {
            content: '해설을 입력하세요...';
            color: #999;
            font-style: italic;
        }

        #voice-synthesis-mode {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            color: #333;
        }

        #ai-commentary-section {
            border: 2px solid #007bff;
            border-radius: 10px;
            background: #f8fbff;
            box-shadow: 0 2px 10px rgba(0, 123, 255, 0.1);
        }

        #ai-commentary-section .panel-header h2 {
            color: #007bff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #ai-commentary-section .panel-header h2::before {
            content: '🤖';
            font-size: 1.2em;
        }

        .source-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .source-details h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .source-details p {
            margin: 5px 0;
            color: #6c757d;
        }

        .ai-commentary-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        .ai-commentary-controls button {
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
        }

        .status-message {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            color: #1565c0;
            font-weight: bold;
        }

        .status-message p {
            margin: 0;
        }

        .selection-toolbar {
            background: #ffffff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .selection-summary {
            font-weight: bold;
            color: #000000;
            font-size: 14px;
        }

        .selection-summary #selected-count {
            color: #007bff;
            font-size: 16px;
            font-weight: bold;
        }

        .selection-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .selection-buttons button {
            background: #ffffff;
            color: #000000;
            border: 1px solid #333;
        }

        .selection-buttons button:hover {
            background: #f0f0f0;
            color: #000000;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            padding-top: 10px;
            border-top: 2px solid #333;
        }

        .bulk-actions label {
            font-weight: bold;
            color: #000000;
            margin: 0;
        }

        .bulk-actions select {
            min-width: 120px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #333;
        }

        .bulk-actions button {
            background: #ffffff;
            color: #000000;
            border: 1px solid #333;
        }

        .bulk-actions button:hover {
            background: #f0f0f0;
            color: #000000;
        }

        .bulk-actions button.btn-primary {
            background: #007bff;
            color: #ffffff;
            border: 1px solid #0056b3;
        }

        .bulk-actions button.btn-primary:hover {
            background: #0056b3;
            color: #ffffff;
        }

        .bulk-actions button.btn-success {
            background: #28a745;
            color: #ffffff;
            border: 1px solid #218838;
        }

        .bulk-actions button.btn-success:hover {
            background: #218838;
            color: #ffffff;
        }

        .bulk-actions button.btn-danger {
            background: #dc3545;
            color: #ffffff;
            border: 1px solid #bd2130;
        }

        .bulk-actions button.btn-danger:hover {
            background: #bd2130;
            color: #ffffff;
        }

        .segment-select {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
        }

        .segment-select-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .segment-index {
            font-weight: bold;
            color: #000000;
            min-width: 30px;
        }

        .btn-sm {
            padding: 4px 12px;
            font-size: 13px;
        }
    </style>
</body>
</html>
