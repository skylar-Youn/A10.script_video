<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‡¼ì¸  ë²ˆì—­ ë° ì¬í•´ì„ê¸°</title>
    <link rel="stylesheet" href="/static/style.css?v=2">
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
    <style>
        ::selection {
            background-color: #0066cc !important;
            color: #ffffff !important;
        }
        ::-moz-selection {
            background-color: #0066cc !important;
            color: #ffffff !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="brand">
                <h1><a href="/">ìœ íŠœë¸Œ ì œì‘ê¸°</a> / ì‡¼ì¸  ë²ˆì—­ê¸°</h1>
            </div>
            <div class="header-actions">
                <button type="button" class="btn-secondary btn-sm" id="btn-open-videoanalysis">ğŸ“Š ìœ íŠœë¸Œì½˜í…ì¸ ë©”ì´ì»¤ë¡œ ì´ë™</button>
            </div>
        </header>

        <div id="project-view" class="hidden">
            <section class="panel">
                <div class="panel-header">
                    <h2 id="project-title"></h2>
                    <p id="project-status" class="panel-subtitle"></p>
                </div>
                <div id="project-actions"></div>
            </section>
            <section class="panel">
                <h3>ë²ˆì—­ ê²°ê³¼</h3>
                <div id="segments-table" class="segments-table"></div>
            </section>
        </div>

        <div id="creation-view">
            <section class="panel">
                <div class="panel-header">
                    <h2>1. ì†ŒìŠ¤ ì„ íƒ</h2>
                    <p class="panel-subtitle">ë²ˆì—­í•  ì˜ìƒê³¼ ìë§‰ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”. íŒŒì¼ì€ <code>youtube/download</code> í´ë”ì—ì„œ ê°€ì ¸ì˜µë‹ˆë‹¤.</p>
                </div>
                <div id="downloads-list" class="downloads-list">
                    <p class="empty-state">ë‹¤ìš´ë¡œë“œëœ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
                    <p class="empty-state" style="color: #666; font-size: 0.9em;">
                        ë§Œì•½ ì´ ë©”ì‹œì§€ê°€ ê³„ì† í‘œì‹œëœë‹¤ë©´
                        <button onclick="location.reload(true)" style="margin: 0 5px; padding: 2px 8px;">ê°•ì œ ìƒˆë¡œê³ ì¹¨</button>
                        ë˜ëŠ” ê°œë°œì ë„êµ¬(F12)ì—ì„œ ì½˜ì†” ì˜¤ë¥˜ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.
                    </p>
                </div>
            </section>

            <section class="panel" id="ai-commentary-section">
                <div class="panel-header">
                    <h2>2. AI í•´ì„¤ ìƒì„±</h2>
                    <p class="panel-subtitle">ì„ íƒëœ ì˜ìƒì˜ ìë§‰ì„ ë¶„ì„í•˜ì—¬ AIê°€ ìë™ìœ¼ë¡œ í•´ì„¤ì„ ìƒì„±í•©ë‹ˆë‹¤.</p>
                </div>
                <div id="selected-source-info" class="source-info">
                    <div class="source-details">
                        <h4 id="selected-source-title">ì„ íƒëœ ì†ŒìŠ¤</h4>
                        <p><strong>ì˜ìƒ:</strong> <span id="selected-video-name">ì„ íƒë˜ì§€ ì•ŠìŒ</span></p>
                        <p><strong>ìë§‰:</strong> <span id="selected-subtitle-name">ì„ íƒë˜ì§€ ì•ŠìŒ</span></p>
                    </div>
                    <div class="source-actions">
                        <button type="button" id="open-source-selector-btn" class="btn-secondary btn-sm">íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                    </div>
                </div>
                <div class="ai-commentary-controls">
                    <button type="button" id="generate-commentary-btn" class="btn-primary">
                        AI í•´ì„¤ ìƒì„±í•˜ê¸°
                    </button>
                    <button type="button" id="skip-commentary-btn" class="btn-secondary">
                        ê±´ë„ˆë›°ê¸°
                    </button>
                </div>
                <div id="commentary-generation-status" class="status-message" style="display: none;">
                    <p>AIê°€ í•´ì„¤ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
                </div>
            </section>

            <section class="panel" id="translation-settings-section">
                <div class="panel-header">
                    <h2>3. ë²ˆì—­ ì„¤ì •</h2>
                    <div>
                        <button type="button" id="load-settings-btn" class="btn-secondary btn-sm">ì§€ë‚œ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°</button>
                        <button type="button" id="save-settings-btn" class="btn-secondary btn-sm">ì„¤ì • ì €ì¥</button>
                    </div>
                </div>
                <form id="creation-form" class="form-grid" autocomplete="off">
                    <div class="form-group">
                        <label for="target-lang">ëª©í‘œ ì–¸ì–´</label>
                        <select id="target-lang" name="target_lang" class="form-control" autocomplete="off">
                            <option value="ko">í•œêµ­ì–´</option>
                            <option value="en">English</option>
                            <option value="ja" selected>æ—¥æœ¬èª</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="translation-mode">ë²ˆì—­ ëª¨ë“œ</label>
                        <select id="translation-mode" name="translation_mode" class="form-control">
                            <option value="adaptive">ì ì‘í˜•</option>
                            <option value="literal">ì§ì—­</option>
                            <option value="reinterpret" selected>ì¬í•´ì„ (ê¸°ë³¸)</option>
                        </select>
                    </div>
                    <div class="form-group form-group-full">
                        <label for="tone-hint">í†¤/ìŠ¤íƒ€ì¼ íŒíŠ¸ (ì„ íƒ ì‚¬í•­)</label>
                        <input type="text" id="tone-hint" name="tone_hint" class="form-control" placeholder="ë“œë¼ë§ˆí•˜ê³  ìœ ì¾Œí•˜ë©´ì„œ ìœ ë¨¸ëŸ¬ìŠ¤í•˜ê²Œ" value="ë“œë¼ë§ˆí•˜ê³  ìœ ì¾Œí•˜ë©´ì„œ ìœ ë¨¸ëŸ¬ìŠ¤í•˜ê²Œ">
                    </div>
                    <div class="form-group form-group-full">
                        <button type="submit" class="btn-primary">ë²ˆì—­ í”„ë¡œì íŠ¸ ìƒì„±</button>
                    </div>
                </form>
            </section>
        </div>
    </div>


    <div id="source-selector-modal" class="modal hidden" role="dialog" aria-modal="true">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3>ì˜ìƒ/ìë§‰ íŒŒì¼ ì„ íƒ</h3>
                <button type="button" class="modal-close" id="source-selector-close" aria-label="ë‹«ê¸°">Ã—</button>
            </div>
            <div class="modal-body">
                <p class="modal-description">`youtube/download` í´ë”ì—ì„œ ì‚¬ìš©í•  ì˜ìƒê³¼ ìë§‰ì„ ì„ íƒí•˜ì„¸ìš”.</p>
                <div class="source-selector-tabs" id="source-selector-tabs">
                    <button type="button" class="tab active" data-mode="downloads">ë‹¤ìš´ë¡œë“œëœ íŒŒì¼</button>
                    <button type="button" class="tab" data-mode="projects">ì €ì¥ëœ í”„ë¡œì íŠ¸</button>
                    <button type="button" class="tab" data-mode="saved">ì¬í•´ì„ ì €ì¥ë³¸</button>
                </div>
                <div id="source-selector-list" class="source-selector-list">
                    <p class="empty-state">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" id="source-selector-cancel">ì·¨ì†Œ</button>
                <button type="button" class="btn-primary" id="source-selector-apply" disabled>ì ìš©</button>
            </div>
        </div>
    </div>



    <script>
    (function () {
        const creationView = document.getElementById('creation-view');
        const projectView = document.getElementById('project-view');
        const downloadsList = document.getElementById('downloads-list');
        const creationForm = document.getElementById('creation-form');

        const projectTitle = document.getElementById('project-title');
        const projectStatus = document.getElementById('project-status');
        const projectActions = document.getElementById('project-actions');
        const segmentsTable = document.getElementById('segments-table');
        const openSourceSelectorBtn = document.getElementById('open-source-selector-btn');
        const sourceSelectorModal = document.getElementById('source-selector-modal');
        const sourceSelectorList = document.getElementById('source-selector-list');
        const sourceSelectorApplyBtn = document.getElementById('source-selector-apply');
        const sourceSelectorCloseBtn = document.getElementById('source-selector-close');
        const sourceSelectorCancelBtn = document.getElementById('source-selector-cancel');
        const sourceSelectorTabs = document.getElementById('source-selector-tabs');

        let selectedSource = null;
        let currentProject = null;
        let isTimelineView = false;
        let availableSourceOptions = [];
        let selectedSourceIndex = null;
        let sourceSelectorMode = 'downloads';
        let savedResultOptions = [];
        const savedResultDetailCache = {};
        let selectedSavedResultId = null;
        let translatorProjects = [];
        let selectedProjectId = null;
        const selectedSegmentIds = new Set();
        let selectionCountElem = null;
        let bulkTargetLangSelect = null;
        let bulkTranslateBtn = null;
        let bulkReverseBtn = null;
        let voiceSelectElem = null;
        let audioFormatSelectElem = null;
        let stopAllAudioBtn = null;

        let singleSegmentAudio = null;
        let singleSegmentSegmentId = null;
        let allAudioPlayer = null;
        let allAudioQueue = [];
        let allAudioIndex = 0;
        let allAudioCurrentSegmentId = null;
        let highlightedSegmentId = null;
        let originalTimelineWaveform = null;
        let translatedTimelineWaveform = null;
        let originalTimelineUrl = null;
        let translatedTimelineUrl = null;
        let timelineActiveWaveformKey = null;
        let timelinePauseBtn = null;
        let timelineStopBtn = null;
        let timelinePlayOriginalBtn = null;
        let timelinePlayTranslatedBtn = null;
        let timelinePlayBothBtn = null;
        let timelinePlayCheckedBtn = null;
        let timelineDeleteCheckedBtn = null;
        let timelineStatusElem = null;
        let timelineOriginalDurationElem = null;
        let timelineTranslatedDurationElem = null;
        let translatedMuteBtn = null;
        let translatedTrimBtn = null;
        let translatedTimelineMuted = false;
        let bgmPlaybackVolume = 1;
        let bgmTrimMode = false;
        let bgmActiveRegion = null;
        let bgmRegionsPlugin = null;
        let bgmV2PlaybackVolume = 1;
        let bgmV2PlaybackLimit = null;
        let bgmV2AudioProcessHandler = null;
        let bgmV2TrimMode = false;
        let bgmV2ActiveRegion = null;
        let bgmV2RegionsPlugin = null;
        let bgmV2AutoDuckEnabled = false;
        let isDialogueMutedPlaying = false;
        let isTranslatedTimelinePlaying = false;
        let bgmV2BaseDuration = null;
        let bgmVolumeRangeInput = document.getElementById('bgm-volume-range');
        let bgmVolumeValueLabel = document.getElementById('bgm-volume-value');
        let bgmVolumeApplyButton = document.getElementById('btn-bgm-apply-volume');
        let bgmTrimToggleButton = document.getElementById('btn-bgm-trim-mode');
        let bgmTrimDeleteButton = document.getElementById('btn-bgm-trim-delete');
        let bgmV2VolumeRangeInput = document.getElementById('bgm-v2-volume-range');
        let bgmV2VolumeValueLabel = document.getElementById('bgm-v2-volume-value');
        let bgmV2VolumeApplyButton = document.getElementById('btn-bgm-v2-apply-volume');
        let bgmV2TrimToggleButton = document.getElementById('btn-bgm-v2-trim-mode');
        let bgmV2TrimDeleteButton = document.getElementById('btn-bgm-v2-trim-delete');
        let bgmV2SaveCopyButton = document.getElementById('btn-bgm-v2-save-copy');
        let bgmV2DuckToggleButton = document.getElementById('btn-bgm-v2-duck-toggle');
        let bgmV2PlaybackTimeLabel = document.getElementById('bgm-v2-playback-time');
        let bgmV2JumpButton = document.getElementById('btn-bgm-v2-jump-end');
        const BGM_V2_DUCK_RATIO = 0.35;

        function clamp(value, min, max) {
            if (Number.isNaN(value)) {
                return min;
            }
            return Math.min(Math.max(value, min), max);
        }

        function clearBgmRegion() {
            if (bgmActiveRegion) {
                try {
                    bgmActiveRegion.remove();
                } catch (error) {
                    console.debug('Failed to remove BGM region:', error);
                }
            }
            bgmActiveRegion = null;
            if (bgmTrimDeleteButton) {
                bgmTrimDeleteButton.disabled = true;
            }
        }

        function clearBgmV2Region() {
            if (bgmV2ActiveRegion) {
                try {
                    bgmV2ActiveRegion.remove();
                } catch (error) {
                    console.debug('Failed to remove BGM V2 region:', error);
                }
            }
            bgmV2ActiveRegion = null;
            if (bgmV2TrimDeleteButton) {
                bgmV2TrimDeleteButton.disabled = true;
            }
        }

        function updateBgmVolumeUI(hasTrack) {
            if (!bgmVolumeRangeInput || !bgmVolumeValueLabel) {
                return;
            }
            if (hasTrack) {
                const percent = Math.round(bgmPlaybackVolume * 100);
                bgmVolumeRangeInput.disabled = false;
                bgmVolumeRangeInput.value = String(percent);
                bgmVolumeValueLabel.textContent = `${percent}%`;
                const inlineBgmBtn = document.getElementById('btn-bgm-load');
                if (inlineBgmBtn) {
                    inlineBgmBtn.disabled = false;
                }
            } else {
                bgmVolumeRangeInput.disabled = true;
                bgmVolumeRangeInput.value = '100';
                bgmVolumeValueLabel.textContent = '--';
                const inlineBgmBtn = document.getElementById('btn-bgm-load');
                if (inlineBgmBtn) {
                    inlineBgmBtn.disabled = true;
                }
            }
            if (bgmVolumeApplyButton) {
                bgmVolumeApplyButton.disabled = !hasTrack;
            }
            if (bgmTrimToggleButton) {
                if (!hasTrack) {
                    bgmTrimMode = false;
                    bgmTrimToggleButton.classList.remove('active');
                    bgmTrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸°';
                    clearBgmRegion();
                }
                bgmTrimToggleButton.disabled = !hasTrack;
            }
            if (bgmTrimDeleteButton) {
                bgmTrimDeleteButton.disabled = !hasTrack || !bgmActiveRegion;
            }
        }

        function updateBgmV2VolumeUI(hasTrack) {
            if (bgmV2VolumeRangeInput) {
                bgmV2VolumeRangeInput.disabled = !hasTrack;
                if (!hasTrack) {
                    bgmV2VolumeRangeInput.value = '100';
                }
            }
            if (bgmV2VolumeValueLabel) {
                bgmV2VolumeValueLabel.textContent = hasTrack ? `${Math.round(bgmV2PlaybackVolume * 100)}%` : '--';
            }
            if (bgmV2VolumeApplyButton) {
                bgmV2VolumeApplyButton.disabled = !hasTrack;
            }
            if (bgmV2TrimToggleButton) {
                if (!hasTrack) {
                    bgmV2TrimMode = false;
                    bgmV2TrimToggleButton.classList.remove('active');
                    bgmV2TrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸°';
                    clearBgmV2Region();
                }
                bgmV2TrimToggleButton.disabled = !hasTrack;
            }
            if (bgmV2TrimDeleteButton) {
                bgmV2TrimDeleteButton.disabled = !hasTrack;
            }
            if (bgmV2SaveCopyButton) {
                bgmV2SaveCopyButton.disabled = !hasTrack;
            }
            if (!hasTrack) {
                bgmV2BaseDuration = null;
            }
            updateBgmV2JumpButtonState();
            updateBgmV2DuckButtonState();
        }

        function applyBgmPlaybackVolume(percent) {
            const clampedPercent = clamp(Number(percent) || 0, 0, 200);
            bgmPlaybackVolume = clampedPercent / 100;
            if (bgmVolumeValueLabel) {
                bgmVolumeValueLabel.textContent = `${clampedPercent}%`;
            }
            if (bgmVolumeRangeInput && bgmVolumeRangeInput.value !== String(clampedPercent)) {
                bgmVolumeRangeInput.value = String(clampedPercent);
            }
            if (window.bgmTimelineWaveform && typeof window.bgmTimelineWaveform.setVolume === 'function') {
                window.bgmTimelineWaveform.setVolume(Math.min(bgmPlaybackVolume, 2));
            }
            updateBgmVolumeUI(Boolean(window.bgmTimelineWaveform));
        }

        function applyBgmV2PlaybackVolume(percent) {
            const clampedPercent = clamp(Number(percent) || 0, 0, 200);
            bgmV2PlaybackVolume = clampedPercent / 100;
            if (bgmV2VolumeValueLabel) {
                bgmV2VolumeValueLabel.textContent = `${clampedPercent}%`;
            }
            updateBgmV2VolumeLabel(clampedPercent);
            if (bgmV2VolumeRangeInput && bgmV2VolumeRangeInput.value !== String(clampedPercent)) {
                bgmV2VolumeRangeInput.value = String(clampedPercent);
            }
            updateBgmV2WaveformVolume();
            updateBgmV2VolumeUI(Boolean(window.bgmV2TimelineWaveform));
        }

        function updateBgmV2PlaybackTime(seconds) {
            if (!bgmV2PlaybackTimeLabel) {
                return;
            }
            if (!Number.isFinite(seconds) || seconds < 0) {
                bgmV2PlaybackTimeLabel.textContent = '--';
                return;
            }
            bgmV2PlaybackTimeLabel.textContent = `${seconds.toFixed(2)}ì´ˆ`;
        }

        function shouldDuckBgmV2() {
            return bgmV2AutoDuckEnabled && (isDialogueMutedPlaying || isTranslatedTimelinePlaying);
        }

        function updateBgmV2WaveformVolume() {
            if (!window.bgmV2TimelineWaveform || typeof window.bgmV2TimelineWaveform.setVolume !== 'function') {
                return;
            }
            const ratio = shouldDuckBgmV2() ? BGM_V2_DUCK_RATIO : 1;
            window.bgmV2TimelineWaveform.setVolume(Math.min(bgmV2PlaybackVolume * ratio, 2));
        }

        function updateBgmV2JumpButtonState() {
            if (!bgmV2JumpButton) {
                return;
            }
            if (Number.isFinite(bgmV2BaseDuration) && bgmV2BaseDuration > 0) {
                bgmV2JumpButton.textContent = `â© ${bgmV2BaseDuration.toFixed(2)}ì´ˆ`;
                bgmV2JumpButton.disabled = false;
            } else {
                bgmV2JumpButton.textContent = 'â© ê¸°ì¤€';
                bgmV2JumpButton.disabled = true;
            }
        }

        function jumpBgmV2ToBase() {
            if (!window.bgmV2TimelineWaveform) {
                alert('ë°°ê²½ìŒì•… V2 íŠ¸ë™ì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.');
                return;
            }
            const duration = window.bgmV2TimelineWaveform.getDuration();
            const target = Number.isFinite(bgmV2BaseDuration) && bgmV2BaseDuration > 0
                ? Math.min(bgmV2BaseDuration, duration)
                : duration;
            if (!Number.isFinite(target) || target <= 0) {
                alert('ì´ë™í•  ê¸°ì¤€ ì‹œê°„ì„ ê³„ì‚°í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
                return;
            }
            const wasPlaying = typeof window.bgmV2TimelineWaveform.isPlaying === 'function'
                ? window.bgmV2TimelineWaveform.isPlaying()
                : false;
            try {
                window.bgmV2TimelineWaveform.setTime(target);
                if (wasPlaying && typeof window.bgmV2TimelineWaveform.play === 'function') {
                    window.bgmV2TimelineWaveform.play();
                }
                updateBgmV2PlaybackTime(target);
                refreshBgmV2DuckState();
            } catch (error) {
                console.debug('Failed to set BGM V2 playback position:', error);
                alert('ì¬ìƒ ìœ„ì¹˜ë¥¼ ì´ë™í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            }
        }

        function updateBgmV2DuckButtonState() {
            if (!bgmV2DuckToggleButton) {
                return;
            }
            const hasTrack = Boolean(window.bgmV2TimelineWaveform);
            bgmV2DuckToggleButton.disabled = !hasTrack;
            if (!hasTrack) {
                bgmV2AutoDuckEnabled = false;
                bgmV2DuckToggleButton.classList.remove('active');
                bgmV2DuckToggleButton.textContent = 'ğŸ§ ìë™ê°ì‡  OFF';
                return;
            }
            bgmV2DuckToggleButton.classList.toggle('active', bgmV2AutoDuckEnabled);
            bgmV2DuckToggleButton.textContent = bgmV2AutoDuckEnabled ? 'ğŸ§ ìë™ê°ì‡  ON' : 'ğŸ§ ìë™ê°ì‡  OFF';
        }

        function refreshBgmV2DuckState() {
            updateBgmV2WaveformVolume();
            updateBgmV2DuckButtonState();
        }

        function toggleBgmV2AutoDuck() {
            if (!window.bgmV2TimelineWaveform) {
                alert('ë°°ê²½ìŒì•… V2 íŠ¸ë™ì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.');
                return;
            }
            bgmV2AutoDuckEnabled = !bgmV2AutoDuckEnabled;
            refreshBgmV2DuckState();
        }

        function recalcDuckFlagsFromPlayback() {
            isDialogueMutedPlaying = Boolean(window.dialogueMutedTimelineWaveform?.isPlaying?.());
            isTranslatedTimelinePlaying = Boolean(translatedTimelineWaveform?.isPlaying?.());
            refreshBgmV2DuckState();
        }

        function clearBgmV2PlaybackLimit() {
            if (window.bgmV2TimelineWaveform && bgmV2AudioProcessHandler && typeof window.bgmV2TimelineWaveform.un === 'function') {
                try {
                    window.bgmV2TimelineWaveform.un('audioprocess', bgmV2AudioProcessHandler);
                } catch (error) {
                    console.debug('Failed to detach BGM V2 audio limit handler:', error);
                }
            }
            bgmV2AudioProcessHandler = null;
            bgmV2PlaybackLimit = null;
        }

        function destroyBgmWaveform() {
            if (bgmRegionsPlugin) {
                try {
                    bgmRegionsPlugin.clearRegions();
                } catch (error) {
                    console.debug('Failed to clear BGM regions:', error);
                }
                if (typeof bgmRegionsPlugin.destroy === 'function') {
                    try {
                        bgmRegionsPlugin.destroy();
                    } catch (error) {
                        console.debug('Failed to destroy BGM regions plugin:', error);
                    }
                }
            }
            bgmRegionsPlugin = null;
            bgmActiveRegion = null;
            if (window.bgmTimelineWaveform) {
                try {
                    window.bgmTimelineWaveform.destroy();
                } catch (error) {
                    console.debug('Failed to destroy BGM waveform:', error);
                }
            }
            window.bgmTimelineWaveform = null;
            window.bgmTimelineUrl = '';
            const inlineBgmBtn = document.getElementById('btn-bgm-load');
            if (inlineBgmBtn) {
                inlineBgmBtn.disabled = true;
            }
            const durationTarget = document.getElementById('timeline-bgm-duration');
            if (durationTarget) {
                updateTimelineDuration(0, durationTarget);
            }
        }

        function updateBgmV2VolumeLabel(percent) {
            const label = document.getElementById('bgm-v2-volume-percent');
            if (!label) {
                return;
            }
            if (Number.isFinite(percent)) {
                label.textContent = `${Math.round(percent)}%`;
            } else {
                label.textContent = '--';
            }
        }

        function destroyBgmV2Waveform() {
            const durationTarget = document.getElementById('timeline-bgm-v2-duration');
            if (durationTarget) {
                updateTimelineDuration(0, durationTarget);
            }
            clearBgmV2PlaybackLimit();
            if (bgmV2RegionsPlugin) {
                try {
                    bgmV2RegionsPlugin.clearRegions();
                } catch (error) {
                    console.debug('Failed to clear BGM V2 regions:', error);
                }
                if (typeof bgmV2RegionsPlugin.destroy === 'function') {
                    try {
                        bgmV2RegionsPlugin.destroy();
                    } catch (error) {
                        console.debug('Failed to destroy BGM V2 regions plugin:', error);
                    }
                }
            }
            bgmV2RegionsPlugin = null;
            bgmV2ActiveRegion = null;
            if (window.bgmV2TimelineWaveform) {
                try {
                    window.bgmV2TimelineWaveform.destroy();
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.debug('Failed to destroy BGM V2 waveform:', error);
                    }
                }
            }
            window.bgmV2TimelineWaveform = null;
            window.bgmV2TimelineUrl = '';
            const container = document.getElementById('timeline-track-bgm-v2');
            if (container) {
                container.style.display = 'none';
            }
            const checkbox = document.getElementById('track-checkbox-bgm-v2');
            if (checkbox) {
                checkbox.checked = false;
            }
            const clearBtn = document.getElementById('btn-bgm-v2-clear');
            if (clearBtn) {
                clearBtn.disabled = true;
            }
            updateBgmV2VolumeLabel(null);
            updateBgmV2VolumeUI(false);
            updateBgmV2PlaybackTime(0);
            bgmV2TrimMode = false;
            bgmV2BaseDuration = null;
            if (bgmV2TrimToggleButton) {
                bgmV2TrimToggleButton.classList.remove('active');
                bgmV2TrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸°';
            }
            if (bgmV2JumpButton) {
                bgmV2JumpButton.textContent = 'â© ê¸°ì¤€';
                bgmV2JumpButton.disabled = true;
            }
            if (bgmV2SaveCopyButton) {
                bgmV2SaveCopyButton.disabled = true;
            }
            if (bgmV2DuckToggleButton) {
                bgmV2DuckToggleButton.disabled = true;
                bgmV2DuckToggleButton.classList.remove('active');
                bgmV2DuckToggleButton.textContent = 'ğŸ§ ìë™ê°ì‡  OFF';
            }
            bgmV2AutoDuckEnabled = false;
            isDialogueMutedPlaying = false;
            isTranslatedTimelinePlaying = false;
            refreshBgmV2DuckState();
        }

        function getComparisonBaseDuration() {
            const candidates = [
                () => window.bgmTimelineWaveform && typeof window.bgmTimelineWaveform.getDuration === 'function' ? window.bgmTimelineWaveform.getDuration() : null,
                () => originalTimelineWaveform && typeof originalTimelineWaveform.getDuration === 'function' ? originalTimelineWaveform.getDuration() : null,
                () => translatedTimelineWaveform && typeof translatedTimelineWaveform.getDuration === 'function' ? translatedTimelineWaveform.getDuration() : null,
                () => {
                    if (currentProject && Number.isFinite(Number(currentProject.duration))) {
                        return Number(currentProject.duration);
                    }
                    return null;
                },
            ];
            for (const getter of candidates) {
                try {
                    const value = getter();
                    if (Number.isFinite(value) && value > 0) {
                        return value;
                    }
                } catch (error) {
                    console.debug('Failed to evaluate comparison duration candidate:', error);
                }
            }
            return null;
        }

        async function setBgmV2Track(rawPath, options = {}) {
            const trackContainer = document.getElementById('timeline-track-bgm-v2');
            const waveformContainer = document.getElementById('timeline-bgm-v2-waveform');
            const hasRawPath = typeof rawPath === 'string' && rawPath.trim().length > 0;

            if (!trackContainer || !waveformContainer) {
                return;
            }

            if (!hasRawPath) {
                destroyBgmV2Waveform();
                return;
            }

            const normalizedPath = toWebAudioPath(rawPath).trim();
            const previousPath = window.bgmV2TimelineUrl || '';
            const forceReload = Boolean(options.force);
            const volumePercent = clamp(
                Number.isFinite(Number(options.volumePercent)) ? Number(options.volumePercent) : 100,
                0,
                200,
            );
            const cacheToken = options.cacheToken || Date.now();
            const separator = normalizedPath.includes('?') ? '&' : '?';
            const cacheBustedUrl = `${normalizedPath}${separator}v=${cacheToken}`;

            const previousTrimMode = bgmV2TrimMode;
            bgmV2TrimMode = false;
            if (bgmV2TrimToggleButton) {
                bgmV2TrimToggleButton.classList.remove('active');
                bgmV2TrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸°';
            }
            clearBgmV2Region();

            if (!forceReload && previousPath === normalizedPath && window.bgmV2TimelineWaveform) {
                const baseDuration = getComparisonBaseDuration();
                if (Number.isFinite(baseDuration) && baseDuration > 0) {
                    bgmV2BaseDuration = baseDuration;
                } else {
                    const trackDuration = window.bgmV2TimelineWaveform.getDuration();
                    bgmV2BaseDuration = Number.isFinite(trackDuration) && trackDuration > 0 ? trackDuration : null;
                }
                updateBgmV2JumpButtonState();
                updateBgmV2VolumeLabel(volumePercent);
                applyBgmV2PlaybackVolume(volumePercent);
                refreshBgmV2DuckState();
                return;
            }

            destroyBgmV2Waveform();
            trackContainer.style.display = '';
            updateBgmV2VolumeLabel(volumePercent);
            applyBgmV2PlaybackVolume(volumePercent);

            const clearBtn = document.getElementById('btn-bgm-v2-clear');
            if (clearBtn) {
                clearBtn.disabled = false;
            }

            if (typeof WaveSurfer === 'undefined') {
                console.warn('WaveSurfer is not loaded; cannot render BGM V2 track.');
                return;
            }

            if (window.WaveSurfer && window.WaveSurfer.Regions) {
                try {
                    bgmV2RegionsPlugin = window.WaveSurfer.Regions.create({
                        dragSelection: bgmV2TrimMode
                            ? { color: 'rgba(6, 214, 160, 0.28)' }
                            : false,
                    });
                } catch (error) {
                    console.debug('Failed to create BGM V2 regions plugin:', error);
                    bgmV2RegionsPlugin = null;
                }
            }

            window.bgmV2TimelineWaveform = WaveSurfer.create({
                container: '#timeline-bgm-v2-waveform',
                height: 90,
                waveColor: '#06d6a0',
                progressColor: '#118ab2',
                cursorColor: '#ffffff',
                normalize: true,
                responsive: true,
                plugins: bgmV2RegionsPlugin ? [bgmV2RegionsPlugin] : [],
            });

            if (bgmV2RegionsPlugin) {
                bgmV2RegionsPlugin.on('region-created', (region) => {
                    if (bgmV2ActiveRegion && bgmV2ActiveRegion.id !== region.id) {
                        try {
                            bgmV2ActiveRegion.remove();
                        } catch (error) {
                            console.debug('Failed to remove previous BGM V2 region:', error);
                        }
                    }
                    region.color = 'rgba(6, 214, 160, 0.32)';
                    bgmV2ActiveRegion = region;
                    if (bgmV2TrimDeleteButton) {
                        bgmV2TrimDeleteButton.disabled = false;
                    }
                    region.on('click', () => {
                        bgmV2ActiveRegion = region;
                        if (bgmV2TrimDeleteButton) {
                            bgmV2TrimDeleteButton.disabled = false;
                        }
                    });
                    region.on('remove', () => {
                        if (bgmV2ActiveRegion === region) {
                            bgmV2ActiveRegion = null;
                            if (bgmV2TrimDeleteButton) {
                                bgmV2TrimDeleteButton.disabled = true;
                            }
                        }
                    });
                });
            }

            const durationTarget = document.getElementById('timeline-bgm-v2-duration');

            window.bgmV2TimelineWaveform.on('ready', () => {
                window.bgmV2TimelineUrl = normalizedPath;
                const baseDuration = getComparisonBaseDuration();
                const trackDuration = window.bgmV2TimelineWaveform.getDuration();
                if (Number.isFinite(baseDuration) && baseDuration > 0) {
                    bgmV2BaseDuration = baseDuration;
                } else {
                    bgmV2BaseDuration = Number.isFinite(trackDuration) && trackDuration > 0 ? trackDuration : null;
                }
                const effectiveDuration = Number.isFinite(bgmV2BaseDuration) && bgmV2BaseDuration > 0
                    ? Math.min(trackDuration, bgmV2BaseDuration)
                    : trackDuration;
                if (durationTarget) {
                    updateTimelineDuration(effectiveDuration, durationTarget);
                }
                clearBgmV2PlaybackLimit();
                if (Number.isFinite(bgmV2BaseDuration) && bgmV2BaseDuration > 0 && trackDuration > bgmV2BaseDuration) {
                    bgmV2PlaybackLimit = bgmV2BaseDuration;
                }
                updateBgmV2JumpButtonState();

                const handleAudioProcess = (time) => {
                    if (Number.isFinite(time)) {
                        updateBgmV2PlaybackTime(time);
                    }
                    if (bgmV2PlaybackLimit !== null && Number.isFinite(time) && time >= bgmV2PlaybackLimit - 0.01) {
                        try {
                            window.bgmV2TimelineWaveform.stop();
                            window.bgmV2TimelineWaveform.setTime(bgmV2PlaybackLimit);
                        } catch (error) {
                            console.debug('Failed to clamp BGM V2 playback:', error);
                        }
                        handleTimelineFinish('bgm_v2');
                    }
                }
                bgmV2AudioProcessHandler = handleAudioProcess;
                if (typeof window.bgmV2TimelineWaveform.on === 'function') {
                    window.bgmV2TimelineWaveform.on('audioprocess', handleAudioProcess);
                    window.bgmV2TimelineWaveform.on('seek', (progress) => {
                        const duration = window.bgmV2TimelineWaveform.getDuration();
                        if (Number.isFinite(duration)) {
                            updateBgmV2PlaybackTime(progress * duration);
                        }
                    });
                    window.bgmV2TimelineWaveform.on('finish', () => {
                        updateBgmV2PlaybackTime(window.bgmV2TimelineWaveform.getDuration());
                        handleTimelineFinish('bgm_v2');
                    });
                }
                updateBgmV2PlaybackTime(0);
                applyBgmV2PlaybackVolume(volumePercent);
                updateBgmV2VolumeUI(true);
                refreshBgmV2DuckState();
                if (bgmV2RegionsPlugin) {
                    if (previousTrimMode && typeof bgmV2RegionsPlugin.enableDragSelection === 'function') {
                        bgmV2TrimMode = true;
                        bgmV2RegionsPlugin.enableDragSelection({ color: 'rgba(6, 214, 160, 0.28)' });
                        if (bgmV2TrimToggleButton) {
                            bgmV2TrimToggleButton.classList.add('active');
                            bgmV2TrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸° ì¢…ë£Œ';
                        }
                    } else if (typeof bgmV2RegionsPlugin.disableDragSelection === 'function') {
                        bgmV2RegionsPlugin.disableDragSelection();
                    }
                }
            });

            window.bgmV2TimelineWaveform.on('error', (error) => {
                if (error?.name !== 'AbortError') {
                    console.error('BGM V2 waveform load error:', error, cacheBustedUrl);
                }
                destroyBgmV2Waveform();
            });

            try {
                await window.bgmV2TimelineWaveform.load(cacheBustedUrl);
            } catch (error) {
                if (error?.name !== 'AbortError') {
                    console.error('Failed to load BGM V2 waveform:', error, cacheBustedUrl);
                }
                destroyBgmV2Waveform();
            }
        }

        function setBgmTrack(rawPath, options = {}) {
            const trackContainer = document.getElementById('timeline-track-bgm');
            const waveformContainer = document.getElementById('timeline-bgm-waveform');
            const hasRawPath = typeof rawPath === 'string' && rawPath.trim().length > 0;

            if (!trackContainer || !waveformContainer) {
                return;
            }

            if (!hasRawPath) {
                destroyBgmWaveform();
                trackContainer.style.display = 'none';
                updateBgmVolumeUI(false);
                clearBgmRegion();
                return;
            }

            const normalizedPath = toWebAudioPath(rawPath).trim();
            const previousPath = window.bgmTimelineUrl || '';
            const forceReload = Boolean(options.force);
            const initialPercent = clamp(
                Number.isFinite(Number(options.volumePercent)) ? Number(options.volumePercent) : Math.round(bgmPlaybackVolume * 100),
                0,
                200,
            );
            const cacheToken = options.cacheToken || Date.now();
            const separator = normalizedPath.includes('?') ? '&' : '?';
            const cacheBustedUrl = `${normalizedPath}${separator}v=${cacheToken}`;

            const previousTrimMode = bgmTrimMode;
            bgmTrimMode = false;
            if (bgmTrimToggleButton) {
                bgmTrimToggleButton.classList.remove('active');
                bgmTrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸°';
            }
            clearBgmRegion();

            if (!forceReload && previousPath === normalizedPath && window.bgmTimelineWaveform) {
                bgmPlaybackVolume = initialPercent / 100;
                applyBgmPlaybackVolume(initialPercent);
                updateBgmVolumeUI(true);
                return;
            }

            destroyBgmWaveform();
            trackContainer.style.display = '';

            if (typeof WaveSurfer === 'undefined') {
                console.warn('WaveSurfer is not loaded; cannot render BGM track.');
                updateBgmVolumeUI(true);
                return;
            }

            if (window.WaveSurfer && window.WaveSurfer.Regions) {
                try {
                    bgmRegionsPlugin = window.WaveSurfer.Regions.create({
                        dragSelection: bgmTrimMode
                            ? { color: 'rgba(255, 214, 0, 0.28)' }
                            : false,
                    });
                } catch (error) {
                    console.debug('Failed to create BGM regions plugin:', error);
                    bgmRegionsPlugin = null;
                }
            }

            window.bgmTimelineWaveform = WaveSurfer.create({
                container: '#timeline-bgm-waveform',
                height: 90,
                waveColor: '#ffd166',
                progressColor: '#f4a261',
                cursorColor: '#ffffff',
                normalize: true,
                responsive: true,
                plugins: bgmRegionsPlugin ? [bgmRegionsPlugin] : [],
            });

            if (bgmRegionsPlugin) {
                bgmRegionsPlugin.on('region-created', (region) => {
                    if (bgmActiveRegion && bgmActiveRegion.id !== region.id) {
                        try {
                            bgmActiveRegion.remove();
                        } catch (error) {
                            console.debug('Failed to remove previous BGM region:', error);
                        }
                    }
                    region.color = 'rgba(255, 214, 0, 0.32)';
                    bgmActiveRegion = region;
                    if (bgmTrimDeleteButton) {
                        bgmTrimDeleteButton.disabled = false;
                    }
                    region.on('click', () => {
                        bgmActiveRegion = region;
                        if (bgmTrimDeleteButton) {
                            bgmTrimDeleteButton.disabled = false;
                        }
                    });
                    region.on('remove', () => {
                        if (bgmActiveRegion === region) {
                            bgmActiveRegion = null;
                            if (bgmTrimDeleteButton) {
                                bgmTrimDeleteButton.disabled = true;
                            }
                        }
                    });
                });
            }

            window.bgmTimelineWaveform.on('ready', () => {
                window.bgmTimelineUrl = normalizedPath;
                bgmPlaybackVolume = initialPercent / 100;
                applyBgmPlaybackVolume(initialPercent);
                updateBgmVolumeUI(true);
                const durationTarget = document.getElementById('timeline-bgm-duration');
                if (durationTarget) {
                    updateTimelineDuration(window.bgmTimelineWaveform.getDuration(), durationTarget);
                }
                if (bgmRegionsPlugin) {
                    if (previousTrimMode && typeof bgmRegionsPlugin.enableDragSelection === 'function') {
                        bgmTrimMode = true;
                        bgmRegionsPlugin.enableDragSelection({ color: 'rgba(255, 214, 0, 0.28)' });
                        if (bgmTrimToggleButton) {
                            bgmTrimToggleButton.classList.add('active');
                            bgmTrimToggleButton.textContent = 'âœ‚ï¸ ìë¥´ê¸° ì¢…ë£Œ';
                        }
                    } else if (typeof bgmRegionsPlugin.disableDragSelection === 'function') {
                        bgmRegionsPlugin.disableDragSelection();
                    }
                }
            });

            window.bgmTimelineWaveform.on('error', (error) => {
                console.error('BGM waveform load error:', error, cacheBustedUrl);
            });

            window.bgmTimelineWaveform.load(cacheBustedUrl);
        }

        async function commitBgmVolume() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }
            if (!bgmVolumeRangeInput) {
                alert('ë³¼ë¥¨ ì¡°ì ˆ ìŠ¬ë¼ì´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            if (!window.bgmTimelineWaveform) {
                alert('ë°°ê²½ìŒì•… íŠ¸ë™ì´ ì¤€ë¹„ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
            }

            const percent = clamp(Number(bgmVolumeRangeInput.value || '100'), 0, 200);

            try {
                if (bgmVolumeApplyButton) {
                    bgmVolumeApplyButton.disabled = true;
                    bgmVolumeApplyButton.textContent = 'ì ìš© ì¤‘...';
                }

                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/volume`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ percent }),
                });

                if (!response.ok) {
                    let detail = 'ë°°ê²½ìŒì•… ë³¼ë¥¨ì„ ì¡°ì •í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                    try {
                        const errorPayload = await response.json();
                        if (errorPayload?.detail) {
                            detail = errorPayload.detail;
                        }
                    } catch (error) {
                        console.debug('Failed to parse BGM volume error payload:', error);
                    }
                    throw new Error(detail);
                }

                const result = await response.json();
                const appliedPercent = clamp(result.bgm_volume_percent ?? percent, 0, 200);
                const cacheToken = result.cache_token || Date.now();

                if (!currentProject.extra) {
                    currentProject.extra = {};
                }
                currentProject.extra.bgm_path = result.bgm_path;
                currentProject.extra.bgm_volume_percent = appliedPercent;
                currentProject.extra.bgm_cache_token = cacheToken;

                setBgmTrack(result.bgm_path, {
                    volumePercent: appliedPercent,
                    cacheToken,
                    force: true,
                });

                alert(`ë°°ê²½ìŒì•… ë³¼ë¥¨ì„ ${Math.round(appliedPercent)}%ë¡œ ì¡°ì •í–ˆìŠµë‹ˆë‹¤.`);
            } catch (error) {
                console.error('BGM volume apply failed:', error);
                alert(error?.message || 'ë°°ê²½ìŒì•… ë³¼ë¥¨ì„ ì¡°ì •í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (bgmVolumeApplyButton) {
                    bgmVolumeApplyButton.disabled = !window.bgmTimelineWaveform;
                    bgmVolumeApplyButton.textContent = 'ğŸšï¸ ì ìš©';
                }
            }
        }

        async function commitBgmV2Volume() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }
            if (!bgmV2VolumeRangeInput) {
                alert('V2 ë³¼ë¥¨ ìŠ¬ë¼ì´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            const v2Path = currentProject.extra?.bgm_v2_path || currentProject.extra?.bgm_custom_v2_path;
            if (!v2Path) {
                alert('ë°°ê²½ìŒì•… V2ê°€ ì¤€ë¹„ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
            }
            const percent = clamp(Number(bgmV2VolumeRangeInput.value || '100'), 0, 200);

            try {
                if (bgmV2VolumeApplyButton) {
                    bgmV2VolumeApplyButton.disabled = true;
                    bgmV2VolumeApplyButton.textContent = 'ì ìš© ì¤‘...';
                }

                const payload = {
                    path: v2Path,
                    kind: 'custom_v2',
                    volume_percent: percent,
                };
                const baseBgmUrl = currentProject.extra?.bgm_path || currentProject.extra?.bgm_custom_path;
                if (baseBgmUrl) {
                    payload.base_duration = getComparisonBaseDuration() ?? null;
                    payload.base_bgm_path = baseBgmUrl;
                }
                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/apply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) {
                    const errorPayload = await response.text();
                    throw new Error(errorPayload || `HTTP ${response.status}`);
                }

                const result = await response.json();
                const appliedPercent = clamp(result.bgm_v2_volume_percent ?? percent, 0, 200);
                const cacheToken = result.bgm_v2_cache_token || Date.now();
                if (!currentProject.extra) {
                    currentProject.extra = {};
                }
                if (result.bgm_v2_path) {
                    currentProject.extra.bgm_v2_path = result.bgm_v2_path;
                }
                if (result.bgm_v2_volume_percent !== undefined) {
                    currentProject.extra.bgm_v2_volume_percent = appliedPercent;
                }
                if (result.bgm_v2_cache_token !== undefined) {
                    currentProject.extra.bgm_v2_cache_token = cacheToken;
                }

                setBgmV2Track(currentProject.extra.bgm_v2_path || currentProject.extra.bgm_custom_v2_path, {
                    volumePercent: appliedPercent,
                    cacheToken,
                    force: true,
                });

                alert(`ë°°ê²½ìŒì•… V2 ë³¼ë¥¨ì„ ${Math.round(appliedPercent)}%ë¡œ ì¡°ì •í–ˆìŠµë‹ˆë‹¤.`);
            } catch (error) {
                console.error('BGM V2 volume apply failed:', error);
                alert(error?.message || 'ë°°ê²½ìŒì•… V2 ë³¼ë¥¨ì„ ì¡°ì •í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (bgmV2VolumeApplyButton) {
                    bgmV2VolumeApplyButton.disabled = !window.bgmV2TimelineWaveform;
                    bgmV2VolumeApplyButton.textContent = 'ğŸšï¸ ì ìš©';
                }
            }
        }

        async function saveCurrentBgmV2As() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }
            if (!currentProject.extra || (!currentProject.extra.bgm_v2_path && !currentProject.extra.bgm_custom_v2_path)) {
                alert('ì €ì¥í•  ë°°ê²½ìŒì•… V2ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const defaultName = `bgm_v2_${new Date().toISOString().replace(/[-:.TZ]/g, '').slice(0, 14)}`;
            const inputName = window.prompt('ìƒˆ íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (í™•ì¥ì ì œì™¸)', defaultName);
            if (inputName === null) {
                return;
            }
            const trimmedName = inputName.trim();
            if (!trimmedName) {
                alert('íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }

            const applyAfter = window.confirm('ì €ì¥í•œ íŒŒì¼ì„ ë°°ê²½ìŒì•… V2ë¡œ ë°”ë¡œ ì ìš©í• ê¹Œìš”?');

            try {
                if (bgmV2SaveCopyButton) {
                    bgmV2SaveCopyButton.disabled = true;
                    bgmV2SaveCopyButton.textContent = 'ì €ì¥ ì¤‘...';
                }

                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/v2/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: trimmedName, apply: applyAfter }),
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                const result = await response.json();
                const candidate = result.candidate;

                if (applyAfter && result.bgm_v2_path) {
                    if (!currentProject.extra) {
                        currentProject.extra = {};
                    }
                    currentProject.extra.bgm_v2_path = result.bgm_v2_path;
                    currentProject.extra.bgm_custom_v2_path = result.bgm_v2_path;
                    currentProject.extra.bgm_v2_volume_percent = result.bgm_v2_volume_percent ?? currentProject.extra.bgm_v2_volume_percent ?? 100;
                    currentProject.extra.bgm_v2_cache_token = result.bgm_v2_cache_token || Date.now();

                    setBgmV2Track(result.bgm_v2_path, {
                        volumePercent: currentProject.extra.bgm_v2_volume_percent ?? 100,
                        cacheToken: currentProject.extra.bgm_v2_cache_token,
                        force: true,
                    });
                    alert(result.message || 'ë°°ê²½ìŒì•… V2ë¥¼ ì €ì¥í•˜ê³  ì ìš©í–ˆìŠµë‹ˆë‹¤.');
                } else {
                    let infoMessage = result.message || 'ë°°ê²½ìŒì•… V2ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤.';
                    if (candidate?.path) {
                        infoMessage += `\níŒŒì¼ ìœ„ì¹˜: ${candidate.path}`;
                    }
                    alert(infoMessage);
                    updateBgmV2JumpButtonState();
                    updateBgmV2DuckButtonState();
                }
            } catch (error) {
                console.error('Failed to save BGM V2 copy:', error);
                alert(error?.message || 'ë°°ê²½ìŒì•… V2 ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (bgmV2SaveCopyButton) {
                    bgmV2SaveCopyButton.disabled = false;
                    bgmV2SaveCopyButton.textContent = 'ğŸ’¾ ë‹¤ë¥¸ì´ë¦„';
                }
            }
        }

        function setBgmTrimMode(enabled) {
            if (!window.bgmTimelineWaveform || !bgmRegionsPlugin) {
                alert('ë°°ê²½ìŒì•… íŠ¸ë™ì„ ë¨¼ì € ì¤€ë¹„í•˜ì„¸ìš”.');
                return;
            }

            bgmTrimMode = Boolean(enabled);
            if (bgmTrimToggleButton) {
                bgmTrimToggleButton.classList.toggle('active', bgmTrimMode);
                bgmTrimToggleButton.textContent = bgmTrimMode ? 'âœ‚ï¸ ìë¥´ê¸° ì¢…ë£Œ' : 'âœ‚ï¸ ìë¥´ê¸°';
            }

            if (bgmRegionsPlugin) {
                if (bgmTrimMode && typeof bgmRegionsPlugin.enableDragSelection === 'function') {
                    bgmRegionsPlugin.enableDragSelection({ color: 'rgba(255, 214, 0, 0.28)' });
                } else if (typeof bgmRegionsPlugin.disableDragSelection === 'function') {
                    bgmRegionsPlugin.disableDragSelection();
                    clearBgmRegion();
                }
            }
        }

        function setBgmV2TrimMode(enabled) {
            if (!window.bgmV2TimelineWaveform || !bgmV2RegionsPlugin) {
                alert('ë°°ê²½ìŒì•… V2 íŠ¸ë™ì„ ë¨¼ì € ì¤€ë¹„í•˜ì„¸ìš”.');
                return;
            }

            bgmV2TrimMode = Boolean(enabled);
            if (bgmV2TrimToggleButton) {
                bgmV2TrimToggleButton.classList.toggle('active', bgmV2TrimMode);
                bgmV2TrimToggleButton.textContent = bgmV2TrimMode ? 'âœ‚ï¸ ìë¥´ê¸° ì¢…ë£Œ' : 'âœ‚ï¸ ìë¥´ê¸°';
            }

            if (bgmV2RegionsPlugin) {
                if (bgmV2TrimMode && typeof bgmV2RegionsPlugin.enableDragSelection === 'function') {
                    bgmV2RegionsPlugin.enableDragSelection({ color: 'rgba(6, 214, 160, 0.28)' });
                } else if (typeof bgmV2RegionsPlugin.disableDragSelection === 'function') {
                    bgmV2RegionsPlugin.disableDragSelection();
                    clearBgmV2Region();
                }
            }
        }

        async function deleteSelectedBgmV2Region() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }
            const currentTime = Number(window.bgmV2TimelineWaveform?.getCurrentTime?.()) || 0;
            if (!Number.isFinite(currentTime) || currentTime < 0) {
                alert('ì¬ìƒ ëˆˆê¸ˆì„ ë¨¼ì € ì´ë™í•œ ë’¤ ë²„ë¦¬ê¸°ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.');
                return;
            }

            const trackDuration = Number(window.bgmV2TimelineWaveform?.getDuration?.()) || 0;
            const effectiveEnd = Number.isFinite(bgmV2BaseDuration) && bgmV2BaseDuration > 0
                ? Math.min(trackDuration || bgmV2BaseDuration, bgmV2BaseDuration)
                : (trackDuration > 0 ? trackDuration : currentTime);

            if (effectiveEnd <= currentTime + 0.05) {
                alert('í˜„ì¬ ìœ„ì¹˜ ì´í›„ì— ì‚­ì œí•  êµ¬ê°„ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (!window.confirm('í˜„ì¬ ëˆˆê¸ˆ ì´í›„ì˜ ë°°ê²½ìŒì•… V2ë¥¼ ì‚­ì œí• ê¹Œìš”?')) {
                return;
            }

            try {
                if (bgmV2TrimDeleteButton) {
                    bgmV2TrimDeleteButton.disabled = true;
                    bgmV2TrimDeleteButton.textContent = 'ì‚­ì œ ì¤‘...';
                }

                const payload = {
                    start: currentTime,
                    end: effectiveEnd,
                    mode: 'trim_after',
                };

                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/v2/cut`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) {
                    let detail = 'ë°°ê²½ìŒì•… V2 êµ¬ê°„ì„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                    try {
                        const errPayload = await response.json();
                        if (errPayload?.detail) {
                            detail = errPayload.detail;
                        }
                    } catch (error) {
                        console.debug('Failed to parse BGM V2 delete error payload:', error);
                    }
                    throw new Error(detail);
                }

                const result = await response.json();

                if (!currentProject.extra) {
                    currentProject.extra = {};
                }
                if (result.bgm_v2_path) {
                    currentProject.extra.bgm_v2_path = result.bgm_v2_path;
                    currentProject.extra.bgm_custom_v2_path = result.bgm_v2_path;
                }
                if (result.bgm_v2_volume_percent !== undefined) {
                    currentProject.extra.bgm_v2_volume_percent = result.bgm_v2_volume_percent;
                }
                if (result.bgm_v2_cache_token !== undefined) {
                    currentProject.extra.bgm_v2_cache_token = result.bgm_v2_cache_token;
                }

                clearBgmV2Region();

                setBgmV2Track(currentProject.extra.bgm_v2_path || currentProject.extra.bgm_custom_v2_path, {
                    volumePercent: currentProject.extra.bgm_v2_volume_percent ?? 100,
                    cacheToken: currentProject.extra.bgm_v2_cache_token || Date.now(),
                    force: true,
                });

                alert('ë°°ê²½ìŒì•… V2ì˜ ë’¤ìª½ êµ¬ê°„ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.');
            } catch (error) {
                console.error('Failed to delete BGM V2 region:', error);
                alert(error?.message || 'ë°°ê²½ìŒì•… V2 êµ¬ê°„ì„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (bgmV2TrimDeleteButton) {
                    bgmV2TrimDeleteButton.disabled = !window.bgmV2TimelineWaveform;
                    bgmV2TrimDeleteButton.textContent = 'ğŸ—‘ï¸ ë²„ë¦¬ê¸°';
                }
            }
        }

        function clearDialogueTimelineTrack() {
            let changed = false;
            if (window.dialogueTimelineWaveform) {
                try {
                    window.dialogueTimelineWaveform.destroy();
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.debug('Failed to destroy dialogue waveform:', error);
                    }
                }
                changed = true;
            }
            window.dialogueTimelineWaveform = null;
            window.dialogueTimelineUrl = '';

            const track = document.getElementById('timeline-track-dialogue');
            if (track) {
                track.style.display = 'none';
            }
            const checkbox = document.getElementById('track-checkbox-dialogue');
            if (checkbox) {
                checkbox.checked = false;
            }
            const durationElem = document.getElementById('timeline-dialogue-duration');
            if (durationElem) {
                updateTimelineDuration(0, durationElem);
            }

            if (currentProject?.extra && currentProject.extra.dialogue_path) {
                delete currentProject.extra.dialogue_path;
                changed = true;
            }

            return changed;
        }

        function clearDialogueMutedTimelineTrack() {
            let changed = false;
            if (window.dialogueMutedTimelineWaveform) {
                try {
                    window.dialogueMutedTimelineWaveform.destroy();
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.debug('Failed to destroy dialogue-muted waveform:', error);
                    }
                }
                changed = true;
            }
            window.dialogueMutedTimelineWaveform = null;
            window.dialogueMutedTimelineUrl = '';

            const track = document.getElementById('timeline-track-dialogue-muted');
            if (track) {
                track.style.display = 'none';
            }
            const checkbox = document.getElementById('track-checkbox-dialogue-muted');
            if (checkbox) {
                checkbox.checked = false;
            }
            const durationElem = document.getElementById('timeline-dialogue-muted-duration');
            if (durationElem) {
                updateTimelineDuration(0, durationElem);
            }

            if (currentProject?.extra && currentProject.extra.dialogue_muted_path) {
                delete currentProject.extra.dialogue_muted_path;
                changed = true;
            }

            return changed;
        }

        async function persistCurrentTrackState() {
            if (!currentProject) {
                return false;
            }
            if (!currentProject.extra) {
                currentProject.extra = {};
            }

            const trackState = {
                bgm_path: currentProject.extra.bgm_path ?? null,
                bgm_volume_percent: currentProject.extra.bgm_volume_percent ?? Math.round(bgmPlaybackVolume * 100),
                bgm_v2_path: currentProject.extra.bgm_v2_path ?? currentProject.extra.bgm_custom_v2_path ?? null,
                bgm_v2_volume_percent: currentProject.extra.bgm_v2_volume_percent ?? 100,
                dialogue_path: currentProject.extra.dialogue_path ?? null,
                dialogue_muted_path: currentProject.extra.dialogue_muted_path ?? null,
            };

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/save-tracks`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(trackState),
                });

                if (!response.ok) {
                    const text = await response.text();
                    console.warn('Track state persistence failed:', text || `HTTP ${response.status}`);
                    return false;
                }
                return true;
            } catch (error) {
                console.warn('Track state persistence error:', error);
                return false;
            }
        }

        async function deleteCheckedTracks() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            if (!currentProject.extra) {
                currentProject.extra = {};
            }

            const deleteBtn = document.getElementById('timeline-delete-checked-btn');
            const originalLabel = deleteBtn ? deleteBtn.textContent : '';
            if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.textContent = 'ì‚­ì œ ì¤‘...';
            }

            const removableTracks = [
                {
                    id: 'track-checkbox-bgm',
                    label: 'ë°°ê²½ìŒì•…',
                    remove: () => {
                        const hadTrack = Boolean(
                            window.bgmTimelineWaveform ||
                            currentProject.extra.bgm_path ||
                            currentProject.extra.bgm_custom_path
                        );
                        setBgmTrack('', { force: true });
                        delete currentProject.extra.bgm_path;
                        delete currentProject.extra.bgm_custom_path;
                        delete currentProject.extra.bgm_volume_percent;
                        delete currentProject.extra.bgm_cache_token;
                        return hadTrack;
                    },
                },
                {
                    id: 'track-checkbox-bgm-v2',
                    label: 'ë°°ê²½ìŒì•… V2',
                    remove: () => {
                        const hadTrack = Boolean(
                            window.bgmV2TimelineWaveform ||
                            currentProject.extra.bgm_v2_path ||
                            currentProject.extra.bgm_custom_v2_path
                        );
                        setBgmV2Track('', { force: true });
                        delete currentProject.extra.bgm_v2_path;
                        delete currentProject.extra.bgm_custom_v2_path;
                        delete currentProject.extra.bgm_v2_volume_percent;
                        delete currentProject.extra.bgm_v2_cache_token;
                        return hadTrack;
                    },
                },
                {
                    id: 'track-checkbox-dialogue',
                    label: 'ì›ë³¸ ëŒ€ì‚¬',
                    remove: () => clearDialogueTimelineTrack(),
                },
                {
                    id: 'track-checkbox-dialogue-muted',
                    label: 'ì›ë³¸ ëŒ€ì‚¬ (ë²ˆì—­ ì œì™¸)',
                    remove: () => clearDialogueMutedTimelineTrack(),
                },
            ];

            const nonRemovableTracks = [
                { id: 'track-checkbox-original', label: 'ì›ë³¸ ìŒì„±' },
                { id: 'track-checkbox-translated', label: 'ë²ˆì—­ ìŒì„±' },
            ];

            const removedLabels = [];
            const blockedLabels = [];

            for (const { id, remove, label } of removableTracks) {
                const checkbox = document.getElementById(id);
                if (checkbox && checkbox.checked) {
                    const removed = remove();
                    checkbox.checked = false;
                    if (removed) {
                        removedLabels.push(label);
                    }
                }
            }

            for (const { id, label } of nonRemovableTracks) {
                const checkbox = document.getElementById(id);
                if (checkbox && checkbox.checked) {
                    blockedLabels.push(label);
                    checkbox.checked = false;
                }
            }

            if (!removedLabels.length) {
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = originalLabel || 'ğŸ—‘ï¸ ì²´í¬ íŠ¸ë™ ì‚­ì œ';
                }

                if (blockedLabels.length) {
                    alert(`${blockedLabels.join(', ')} íŠ¸ë™ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                } else {
                    alert('ì‚­ì œí•  íŠ¸ë™ì„ ì„ íƒí•˜ì„¸ìš”.');
                }
                return;
            }

            try {
                await persistCurrentTrackState();
                await updateComparisonTimeline();
            } finally {
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = originalLabel || 'ğŸ—‘ï¸ ì²´í¬ íŠ¸ë™ ì‚­ì œ';
                }
            }

            const blockedSuffix = blockedLabels.length ? ` (ì‚­ì œ ë¶ˆê°€: ${blockedLabels.join(', ')})` : '';
            alert(`${removedLabels.join(', ')} íŠ¸ë™ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.${blockedSuffix}`);
        }

        async function deleteSelectedBgmRegion() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }
            if (!bgmActiveRegion) {
                alert('ì‚­ì œí•  êµ¬ê°„ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const start = clamp(Number(bgmActiveRegion.start || 0), 0, Number.POSITIVE_INFINITY);
            const end = clamp(Number(bgmActiveRegion.end || 0), 0, Number.POSITIVE_INFINITY);

            if (end - start < 0.05) {
                alert('0.05ì´ˆ ì´ìƒ ì„ íƒí•´ì•¼ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }

            if (!window.confirm('ì„ íƒí•œ êµ¬ê°„ì˜ ë°°ê²½ìŒì•…ì„ ì‚­ì œí• ê¹Œìš”?')) {
                return;
            }

            try {
                if (bgmTrimDeleteButton) {
                    bgmTrimDeleteButton.disabled = true;
                    bgmTrimDeleteButton.textContent = 'ì‚­ì œ ì¤‘...';
                }

                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/cut`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start,
                        end,
                        mode: 'remove',
                    }),
                });

                if (!response.ok) {
                    let detail = 'ì„ íƒ êµ¬ê°„ì„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                    try {
                        const errorPayload = await response.json();
                        if (errorPayload?.detail) {
                            detail = errorPayload.detail;
                        }
                    } catch (error) {
                        console.debug('Failed to parse BGM cut error payload:', error);
                    }
                    throw new Error(detail);
                }

                const result = await response.json();
                const appliedPercent = clamp(result.bgm_volume_percent ?? (currentProject.extra?.bgm_volume_percent ?? 100), 0, 200);
                const cacheToken = result.cache_token || Date.now();

                if (!currentProject.extra) {
                    currentProject.extra = {};
                }
                currentProject.extra.bgm_path = result.bgm_path;
                currentProject.extra.bgm_volume_percent = appliedPercent;
                currentProject.extra.bgm_cache_token = cacheToken;

                clearBgmRegion();
                setBgmTrack(result.bgm_path, {
                    volumePercent: appliedPercent,
                    cacheToken,
                    force: true,
                });

                alert('ì„ íƒí•œ êµ¬ê°„ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.');
            } catch (error) {
                console.error('BGM trim delete failed:', error);
                alert(error?.message || 'ì„ íƒ êµ¬ê°„ì„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (bgmTrimDeleteButton) {
                    bgmTrimDeleteButton.disabled = !bgmActiveRegion;
                    bgmTrimDeleteButton.textContent = 'ğŸ—‘ï¸ ë²„ë¦¬ê¸°';
                }
            }
        }

        async function uploadBgmFile(file, { mode = 'replace', buttonEl = null } = {}) {
            if (!currentProject) {
                throw new Error('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('mode', mode);

            let originalText = null;
            if (buttonEl) {
                originalText = buttonEl.textContent;
                buttonEl.disabled = true;
                buttonEl.textContent = 'ì—…ë¡œë“œ ì¤‘...';
            }

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/upload`, {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                const result = await response.json();

                if (!currentProject.extra) {
                    currentProject.extra = {};
                }
                currentProject.extra.bgm_path = result.bgm_path;
                currentProject.extra.bgm_volume_percent = result.bgm_volume_percent;
                currentProject.extra.bgm_cache_token = result.bgm_cache_token;
                if (result.bgm_source_path) {
                    currentProject.extra.bgm_source_path = result.bgm_source_path;
                }
                currentProject.extra.bgm_custom_path = result.bgm_path;

                setBgmTrack(result.bgm_path, {
                    volumePercent: result.bgm_volume_percent,
                    cacheToken: result.bgm_cache_token,
                    force: true,
                });

                return result;
            } catch (error) {
                throw error;
            } finally {
                if (buttonEl) {
                    buttonEl.disabled = false;
                    buttonEl.textContent = originalText || 'íŒŒì¼ ì°¾ê¸°';
                }
            }
        }

        if (bgmVolumeRangeInput && !bgmVolumeRangeInput.dataset.bound) {
            bgmVolumeRangeInput.dataset.bound = '1';
            updateBgmVolumeUI(false);
            const handleBgmSlider = (event) => {
                applyBgmPlaybackVolume(event?.target?.value ?? bgmVolumeRangeInput.value);
            };
            bgmVolumeRangeInput.addEventListener('input', handleBgmSlider);
            bgmVolumeRangeInput.addEventListener('change', handleBgmSlider);
        } else if (bgmVolumeValueLabel) {
            bgmVolumeValueLabel.textContent = '--';
        }

        if (bgmV2VolumeRangeInput && !bgmV2VolumeRangeInput.dataset.bound) {
            bgmV2VolumeRangeInput.dataset.bound = '1';
            updateBgmV2VolumeUI(false);
            const handleV2SliderInit = (event) => {
                const value = event?.target?.value ?? bgmV2VolumeRangeInput.value;
                applyBgmV2PlaybackVolume(Number(value));
                updateBgmV2VolumeLabel(Number(value));
            };
            bgmV2VolumeRangeInput.addEventListener('input', handleV2SliderInit);
            bgmV2VolumeRangeInput.addEventListener('change', handleV2SliderInit);
        } else if (bgmV2VolumeValueLabel) {
            bgmV2VolumeValueLabel.textContent = '--';
        }

        if (bgmVolumeApplyButton && !bgmVolumeApplyButton.dataset.bound) {
            bgmVolumeApplyButton.dataset.bound = '1';
            bgmVolumeApplyButton.addEventListener('click', () => {
                commitBgmVolume().catch((error) => console.error('Failed to commit BGM volume:', error));
            });
        }

        if (bgmV2VolumeApplyButton && !bgmV2VolumeApplyButton.dataset.bound) {
            bgmV2VolumeApplyButton.dataset.bound = '1';
            bgmV2VolumeApplyButton.addEventListener('click', () => {
                commitBgmV2Volume().catch((error) => console.error('Failed to commit BGM V2 volume:', error));
            });
        }

        if (bgmTrimToggleButton) {
            bgmTrimToggleButton.addEventListener('click', () => {
                if (!window.bgmTimelineWaveform || !bgmRegionsPlugin) {
                    alert('ë°°ê²½ìŒì•… íŠ¸ë™ì´ ì¤€ë¹„ëœ í›„ì— ì‚¬ìš©í•´ ì£¼ì„¸ìš”.');
                    return;
                }
                setBgmTrimMode(!bgmTrimMode);
            });
        }

        if (bgmTrimDeleteButton) {
            bgmTrimDeleteButton.addEventListener('click', () => {
                deleteSelectedBgmRegion().catch((error) => console.error('Failed to delete BGM region:', error));
            });
        }

        function updateTranslatedMuteButton(hasTrack) {
            if (!translatedMuteBtn) {
                return;
            }

            const label = translatedTimelineMuted ? 'ğŸ”Š ë²ˆì—­êµ¬ê°„ ìœ ìŒ' : 'ğŸ”‡ ë²ˆì—­êµ¬ê°„ ë¬´ìŒ';
            translatedMuteBtn.textContent = label;
            translatedMuteBtn.title = translatedTimelineMuted
                ? 'ë²ˆì—­ ìŒì„± íŠ¸ë™ì„ ë‹¤ì‹œ ë“¤ë¦¬ê²Œ í•©ë‹ˆë‹¤'
                : 'ë²ˆì—­ ìŒì„± íŠ¸ë™ì„ ë¬´ìŒ ì²˜ë¦¬í•©ë‹ˆë‹¤';
            translatedMuteBtn.disabled = !hasTrack;
        }

        function applyTranslatedMuteState() {
            const hasTrack = Boolean(translatedTimelineWaveform);
            if (translatedTimelineWaveform && typeof translatedTimelineWaveform.setVolume === 'function') {
                translatedTimelineWaveform.setVolume(translatedTimelineMuted ? 0 : 1);
            }
            updateTranslatedMuteButton(hasTrack);
        }

        function handleTranslatedMuteClick() {
            if (!translatedTimelineWaveform) {
                return;
            }
            translatedTimelineMuted = !translatedTimelineMuted;
            applyTranslatedMuteState();
        }

        async function handleTranslatedTrimClick() {
            if (!currentProject?.id) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.');
                return;
            }
            if (!translatedTrimBtn) {
                return;
            }

            const originalLabel = translatedTrimBtn.textContent;
            translatedTrimBtn.dataset.originalText = originalLabel;
            translatedTrimBtn.disabled = true;
            translatedTrimBtn.textContent = 'âœ‚ï¸ ìë¥´ëŠ” ì¤‘...';
            translatedTrimBtn.dataset.locked = '1';

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/trim-translated`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}`;
                    try {
                        const payload = await response.json();
                        errorMessage = payload.detail || payload.message || errorMessage;
                    } catch (parseError) {
                        const text = await response.text();
                        if (text) {
                            errorMessage = text;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                if (data && data.message) {
                    alert(data.message);
                } else {
                    alert('ë²ˆì—­ ìŒì„± ê¸¸ì´ë¥¼ ì¡°ì •í–ˆìŠµë‹ˆë‹¤.');
                }

                // ì„œë²„ ìƒíƒœì™€ ë™ê¸°í™”
                loadProject(currentProject.id);
            } catch (error) {
                console.error('Trim translated audio failed:', error);
                alert((error && error.message) || 'ë²ˆì—­ ìŒì„± ìë¥´ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                translatedTrimBtn.disabled = false;
                translatedTrimBtn.textContent = translatedTrimBtn.dataset.originalText || 'âœ‚ï¸ ì›ë³¸ìŒì„±ë³´ë‹¤ ê¸´ ê²ƒ ìë¥´ê¸°';
                delete translatedTrimBtn.dataset.originalText;
                delete translatedTrimBtn.dataset.locked;
            }
        }

        if (openSourceSelectorBtn) {
            openSourceSelectorBtn.style.display = 'none';
        }

        const TEXT_FIELDS_MAP = {
            source: 'source_text',
            translated: 'translated_text',
            reverse_translated: 'reverse_translated_text',
            commentary: 'commentary',
            commentary_korean: 'commentary_korean',
            commentary_japanese: 'commentary_japanese',
            commentary_reverse_korean: 'commentary_reverse_korean',
        };

        const TEXT_TYPE_LABELS = {
            source: 'í˜„ì¬ ìë§‰ (í•œêµ­ì–´)',
            commentary_korean: 'ì¬í•´ì„ ìë§‰ (í•œêµ­ì–´)',
            translated: 'ë²ˆì—­ ì¼ë³¸ì–´ ìë§‰',
            reverse_translated: 'ì—­ë²ˆì—­ ìë§‰ (í•œêµ­ì–´)',
            commentary: 'í•´ì„¤',
            commentary_japanese: 'í•´ì„¤ ì¼ë³¸ì–´',
            commentary_reverse_korean: 'í•´ì„¤ ì—­ë²ˆì—­ í•œêµ­ì–´',
        };

        function escapeHtml(text) {
            if (text === undefined || text === null) {
                return '';
            }
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function getSelectedVoice() {
            return voiceSelectElem && voiceSelectElem.value ? voiceSelectElem.value : 'nova';
        }

        function getSelectedAudioFormat() {
            return audioFormatSelectElem && audioFormatSelectElem.value ? audioFormatSelectElem.value : 'wav';
        }

        function toWebAudioPath(path) {
            if (!path) {
                return '';
            }
            if (typeof path !== 'string') {
                path = String(path);
            }
            if (path.startsWith('/outputs/')) {
                return path;
            }

            // /youtube/download/ ê²½ë¡œ ì²˜ë¦¬
            const youtubeMarker = '/youtube/download/';
            if (path.includes(youtubeMarker)) {
                const parts = path.split(youtubeMarker);
                if (parts.length > 1) {
                    // íŒŒì¼ëª…ì„ URL ì¸ì½”ë”©í•˜ì—¬ ë°˜í™˜
                    const filename = parts[1];
                    return '/youtube/download/' + encodeURIComponent(filename);
                }
            }

            const marker = '/ai_shorts_maker/outputs/';
            if (path.includes(marker)) {
                const parts = path.split(marker);
                if (parts.length > 1) {
                    return '/outputs/' + parts[1];
                }
            }
            return path;
        }

        function normalizeTrackSavePath(rawPath) {
            if (!rawPath && rawPath !== 0) {
                return null;
            }
            let path = String(rawPath).trim();
            if (!path) {
                return null;
            }

            const hashIndex = path.indexOf('#');
            if (hashIndex >= 0) {
                path = path.slice(0, hashIndex);
            }

            const queryIndex = path.indexOf('?');
            if (queryIndex >= 0) {
                path = path.slice(0, queryIndex);
            }

            if (path.startsWith('/web-audio/')) {
                path = path.slice('/web-audio/'.length);
                if (!path.startsWith('/')) {
                    path = '/' + path;
                }
            } else if (!path.startsWith('/') && (path.startsWith('outputs/') || path.startsWith('youtube/download/'))) {
                path = '/' + path;
            }

            return path;
        }

        function resolveTrackStatePath(...candidates) {
            for (const candidate of candidates) {
                const normalized = normalizeTrackSavePath(candidate);
                if (normalized) {
                    return normalized;
                }
            }
            return null;
        }

        function updateSegmentCache(segmentId, textType, value) {
            if (!currentProject) {
                return;
            }
            const field = TEXT_FIELDS_MAP[textType];
            if (!field) {
                return;
            }
            const target = currentProject.segments.find(seg => seg.id === segmentId);
            if (target) {
                target[field] = value;
            }
        }

        function getSegmentElements(segmentId) {
            if (!segmentId) {
                return [];
            }
            return Array.from(document.querySelectorAll(`.segment-item[data-segment-id="${segmentId}"]`));
        }

        function scrollToSegmentElement(element) {
            if (!element || typeof element.scrollIntoView !== 'function') {
                return;
            }
            element.scrollIntoView({ behavior: 'auto', block: 'center' });
        }

        function clearSegmentHighlight() {
            if (!highlightedSegmentId) {
                return;
            }
            getSegmentElements(highlightedSegmentId).forEach(el => el.classList.remove('segment-playing'));
            highlightedSegmentId = null;
        }

        function applySegmentHighlight(segmentId, { scroll = false } = {}) {
            if (!segmentId) {
                clearSegmentHighlight();
                return;
            }

            if (highlightedSegmentId !== segmentId) {
                clearSegmentHighlight();
                highlightedSegmentId = segmentId;
            }

            const elements = getSegmentElements(segmentId);
            elements.forEach(el => el.classList.add('segment-playing'));

            if (scroll && elements.length) {
                scrollToSegmentElement(elements[0]);
            }
        }

        function reapplyHighlight() {
            if (!highlightedSegmentId) {
                return;
            }
            getSegmentElements(highlightedSegmentId).forEach(el => el.classList.add('segment-playing'));
        }

        function stopSingleAudioPlayback({ clearHighlight = true } = {}) {
            if (singleSegmentAudio) {
                singleSegmentAudio.pause();
                try {
                    singleSegmentAudio.currentTime = 0;
                } catch (err) {
                    /* ignore reset errors */
                }
                singleSegmentAudio = null;
            }
            if (clearHighlight && highlightedSegmentId === singleSegmentSegmentId) {
                clearSegmentHighlight();
            }
            singleSegmentSegmentId = null;
        }

        function stopAllAudio({ clearHighlight = true } = {}) {
            if (allAudioPlayer) {
                allAudioPlayer.pause();
                try {
                    allAudioPlayer.currentTime = 0;
                } catch (err) {
                    /* ignore reset errors */
                }
                allAudioPlayer.removeEventListener('ended', handleAllAudioEnded);
                allAudioPlayer.removeEventListener('error', handleAllAudioError);
                allAudioPlayer.src = '';
                allAudioPlayer = null;
            }
            allAudioQueue = [];
            allAudioIndex = 0;
            if (clearHighlight && highlightedSegmentId === allAudioCurrentSegmentId) {
                clearSegmentHighlight();
            }
            allAudioCurrentSegmentId = null;
            if (stopAllAudioBtn) {
                stopAllAudioBtn.disabled = true;
            }
        }

        function handleAllAudioEnded() {
            allAudioIndex += 1;
            if (allAudioIndex < allAudioQueue.length) {
                playCurrentAllAudioSegment();
            } else {
                stopAllAudio({ clearHighlight: true });
            }
        }

        function handleAllAudioError(event) {
            console.error('Failed during multi-segment audio playback:', event?.error || event);
            alert('ì „ì²´ ìŒì„± ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            stopAllAudio({ clearHighlight: true });
        }

        function playCurrentAllAudioSegment() {
            if (!allAudioPlayer || allAudioIndex >= allAudioQueue.length) {
                stopAllAudio({ clearHighlight: true });
                return;
            }

            const { segmentId, path } = allAudioQueue[allAudioIndex];
            allAudioCurrentSegmentId = segmentId;
            applySegmentHighlight(segmentId, { scroll: true });

            allAudioPlayer.src = path;
            const playPromise = allAudioPlayer.play();
            if (playPromise && typeof playPromise.catch === 'function') {
                playPromise.catch(err => {
                    console.error('Failed to play audio:', err);
                    alert('ìŒì„± ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    stopAllAudio({ clearHighlight: true });
                });
            }
        }

        async function destroyComparisonWaveforms() {
            if (originalTimelineWaveform) {
                try {
                    originalTimelineWaveform.pause();
                    await new Promise(resolve => setTimeout(resolve, 50)); // ì•½ê°„ì˜ ì§€ì—°
                    originalTimelineWaveform.destroy();
                } catch (err) {
                    // AbortErrorëŠ” ë¬´ì‹œ
                    if (err.name !== 'AbortError') {
                        console.debug('Failed to destroy original waveform:', err);
                    }
                }
                originalTimelineWaveform = null;
            }
            if (translatedTimelineWaveform) {
                try {
                    translatedTimelineWaveform.pause();
                    await new Promise(resolve => setTimeout(resolve, 50)); // ì•½ê°„ì˜ ì§€ì—°
                    translatedTimelineWaveform.destroy();
                } catch (err) {
                    // AbortErrorëŠ” ë¬´ì‹œ
                    if (err.name !== 'AbortError') {
                        console.debug('Failed to destroy translated waveform:', err);
                    }
                }
                translatedTimelineWaveform = null;
            }
            destroyBgmV2Waveform();
            timelineActiveWaveformKey = null;
            updateTranslatedMuteButton(false);
        }

        function isAbortError(error) {
            if (!error) {
                return false;
            }
            if (error.name === 'AbortError') {
                return true;
            }
            if (typeof error.message === 'string' && error.message.includes('aborted')) {
                return true;
            }
            return false;
        }

        function logWaveformError(context, error, url) {
            if (isAbortError(error)) {
                console.debug(`${context} waveform load aborted (likely stale request).`, { url, error });
                return;
            }
            console.error(`${context} waveform load error:`, error, 'URL:', url);
        }

        function getAllTimelineWaveforms() {
            const waveforms = [];
            if (originalTimelineWaveform) waveforms.push(originalTimelineWaveform);
            if (translatedTimelineWaveform) waveforms.push(translatedTimelineWaveform);
            if (window.bgmTimelineWaveform) waveforms.push(window.bgmTimelineWaveform);
            if (window.bgmV2TimelineWaveform) waveforms.push(window.bgmV2TimelineWaveform);
            if (window.dialogueTimelineWaveform) waveforms.push(window.dialogueTimelineWaveform);
            if (window.dialogueMutedTimelineWaveform) waveforms.push(window.dialogueMutedTimelineWaveform);
            return waveforms;
        }

        function stopComparisonTimeline({ clearHighlight = false } = {}) {
            getAllTimelineWaveforms().forEach((waveform) => {
                try {
                    if (typeof waveform.stop === 'function') {
                        waveform.stop();
                    } else {
                        waveform.pause();
                        waveform.seekTo(0);
                    }
                } catch (err) {
                    console.debug('Timeline stop failed:', err);
                }
            });
            timelineActiveWaveformKey = null;
            if (timelinePauseBtn) {
                timelinePauseBtn.disabled = true;
            }
            if (timelineStopBtn) {
                timelineStopBtn.disabled = true;
            }
            if (clearHighlight) {
                clearSegmentHighlight();
            }
            isDialogueMutedPlaying = false;
            isTranslatedTimelinePlaying = false;
            refreshBgmV2DuckState();
        }

        function handleTimelineFinish(trackKey) {
            if (timelineActiveWaveformKey === trackKey) {
                timelineActiveWaveformKey = null;
            }
            clearSegmentHighlight();
            const anyPlaying = getAllTimelineWaveforms().some(wf => wf?.isPlaying?.());
            if (!anyPlaying) {
                if (timelinePauseBtn) {
                    timelinePauseBtn.disabled = true;
                }
                if (timelineStopBtn) {
                    timelineStopBtn.disabled = true;
                }
            }
            if (trackKey === 'translated') {
                isTranslatedTimelinePlaying = false;
            }
            if (trackKey === 'dialogue-muted') {
                isDialogueMutedPlaying = false;
            }
            if (!anyPlaying) {
                isTranslatedTimelinePlaying = false;
                isDialogueMutedPlaying = false;
            }
            refreshBgmV2DuckState();
        }

        function updateTimelineDuration(duration, target) {
            if (!target) {
                return;
            }
            const safe = Number.isFinite(duration) ? duration : 0;
            target.textContent = safe > 0 ? `${safe.toFixed(2)}ì´ˆ` : '';
        }

        function findSegmentByTime(time) {
            if (!currentProject?.segments?.length || !Number.isFinite(time)) {
                return null;
            }
            return currentProject.segments.find(seg => time >= seg.start && time <= seg.end + 0.05) || null;
        }

        function handleTimelineTimeUpdate(trackKey, rawTime) {
            const time = Number.isFinite(rawTime) ? rawTime : 0;
            const segment = findSegmentByTime(time);
            if (!segment) {
                return;
            }
            if (highlightedSegmentId !== segment.id) {
                applySegmentHighlight(segment.id, { scroll: false });
            }
        }

        function getOriginalTimelineAudioUrl() {
            if (!currentProject) {
                return '';
            }

            const extras = currentProject.extra || {};
            const audioFiles = extras.audio_files || {};
            const candidateKeys = ['original', 'source', 'original_audio', 'source_audio'];

            for (const key of candidateKeys) {
                const candidate = audioFiles[key];
                if (typeof candidate === 'string' && candidate.trim()) {
                    return candidate;
                }
            }

            if (typeof extras.original_audio_path === 'string') {
                return extras.original_audio_path;
            }

            if (typeof currentProject.source_video === 'string') {
                return currentProject.source_video;
            }

            return '';
        }

        function getTranslatedTimelineAudioUrl() {
            console.log('getTranslatedTimelineAudioUrl called');

            if (!currentProject?.segments?.length) {
                console.log('No current project or segments');
                return '';
            }

            const extras = currentProject.extra || {};
            console.log('Project extras:', extras);

            if (typeof extras.voice_path === 'string' && extras.voice_path.trim()) {
                console.log('Found voice_path in extras:', extras.voice_path);
                return extras.voice_path;
            }

            const uniquePaths = new Set(
                currentProject.segments
                    .map(seg => seg.audio_path)
                    .filter(path => typeof path === 'string' && path.trim())
            );

            console.log('Unique audio paths from segments:', uniquePaths);

            if (uniquePaths.size === 1) {
                const path = [...uniquePaths][0];
                console.log('Using single audio path from segments:', path);
                return path;
            }

            if (uniquePaths.size > 1) {
                const parseSegmentCount = (path) => {
                    if (typeof path !== 'string') {
                        return null;
                    }
                    const match = path.match(/selected_audio_(\d+)_segments/i);
                    if (match) {
                        const parsed = parseInt(match[1], 10);
                        return Number.isFinite(parsed) ? parsed : null;
                    }
                    return null;
                };

                const scorePath = (path) => {
                    const count = parseSegmentCount(path);
                    if (count !== null) {
                        return count;
                    }
                    // Prefer combined timeline style files over raw segment clips
                    if (typeof path === 'string' && /selected_audio_/i.test(path)) {
                        return 0.5;
                    }
                    return 0;
                };

                const candidates = [...uniquePaths];
                let bestPath = '';
                let bestScore = -1;
                candidates.forEach((candidate) => {
                    const score = scorePath(candidate);
                    if (score > bestScore) {
                        bestScore = score;
                        bestPath = candidate;
                    }
                });

                if (bestPath) {
                    console.log('Selected best timeline audio from segments:', bestPath, 'score:', bestScore);
                    return bestPath;
                }
            }

            const audioFiles = extras.audio_files || {};
            console.log('Audio files:', audioFiles);

            const candidateKeys = ['combined', 'merged', 'translated', 'timeline'];
            for (const key of candidateKeys) {
                const candidate = audioFiles[key];
                if (typeof candidate === 'string' && candidate.trim()) {
                    console.log(`Found audio file with key "${key}":`, candidate);
                    return candidate;
                }
            }

            console.log('No translated audio URL found');
            return '';
        }

        function playTimelineTrack(trackKey) {
            stopSingleAudioPlayback({ clearHighlight: false });
            stopAllAudio({ clearHighlight: false });
            applyTranslatedMuteState();
            isDialogueMutedPlaying = false;
            isTranslatedTimelinePlaying = false;

            // ì²´í¬ëœ íŠ¸ë™ë§Œ ì¬ìƒ ëª¨ë“œ
            if (trackKey === 'checked') {
                const tracksToPlay = [];
                let willPlayTranslated = false;
                let willPlayDialogueMuted = false;

                // ê° íŠ¸ë™ì˜ ì²´í¬ë°•ìŠ¤ ìƒíƒœ í™•ì¸
                const checkboxes = [
                    { id: 'track-checkbox-original', waveform: originalTimelineWaveform, url: originalTimelineUrl },
                    { id: 'track-checkbox-bgm', waveform: window.bgmTimelineWaveform, url: window.bgmTimelineUrl },
                    { id: 'track-checkbox-bgm-v2', waveform: window.bgmV2TimelineWaveform, url: window.bgmV2TimelineUrl },
                    { id: 'track-checkbox-dialogue', waveform: window.dialogueTimelineWaveform, url: window.dialogueTimelineUrl },
                    { id: 'track-checkbox-dialogue-muted', waveform: window.dialogueMutedTimelineWaveform, url: window.dialogueMutedTimelineUrl },
                    { id: 'track-checkbox-translated', waveform: translatedTimelineWaveform, url: translatedTimelineUrl }
                ];

                for (const { id, waveform, url } of checkboxes) {
                    const checkbox = document.getElementById(id);
                    if (checkbox && checkbox.checked && waveform && url) {
                        tracksToPlay.push(waveform);
                        if (id === 'track-checkbox-translated') {
                            willPlayTranslated = true;
                        }
                        if (id === 'track-checkbox-dialogue-muted') {
                            willPlayDialogueMuted = true;
                        }
                    }
                }

                if (tracksToPlay.length === 0) {
                    alert('ì¬ìƒí•  íŠ¸ë™ì„ ì„ íƒí•˜ì„¸ìš” (ì²´í¬ë°•ìŠ¤ ì„ íƒ)');
                    return;
                }

                isTranslatedTimelinePlaying = willPlayTranslated;
                isDialogueMutedPlaying = willPlayDialogueMuted;
                refreshBgmV2DuckState();

                timelineActiveWaveformKey = 'checked';
                if (timelinePauseBtn) {
                    timelinePauseBtn.disabled = false;
                }
                if (timelineStopBtn) {
                    timelineStopBtn.disabled = false;
                }

                // ì²´í¬ëœ íŠ¸ë™ë“¤ ë™ì‹œ ì¬ìƒ
                tracksToPlay.forEach((waveform, index) => {
                    const playPromise = waveform.play();
                    if (playPromise && typeof playPromise.catch === 'function') {
                        playPromise.catch(err => {
                            console.error(`Track ${index + 1} playback failed:`, err);
                        });
                    }
                });
                return;
            }

            // ë™ì‹œì¬ìƒ ëª¨ë“œ
            if (trackKey === 'both') {
                if (!originalTimelineWaveform && !translatedTimelineWaveform) {
                    alert('ì¬ìƒí•  íŠ¸ë™ì´ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                isTranslatedTimelinePlaying = Boolean(translatedTimelineWaveform);
                isDialogueMutedPlaying = false;
                refreshBgmV2DuckState();

                timelineActiveWaveformKey = 'both';
                if (timelinePauseBtn) {
                    timelinePauseBtn.disabled = false;
                }
                if (timelineStopBtn) {
                    timelineStopBtn.disabled = false;
                }

                // ë‘ íŠ¸ë™ ë™ì‹œ ì¬ìƒ
                if (originalTimelineWaveform) {
                    const playPromise1 = originalTimelineWaveform.play();
                    if (playPromise1 && typeof playPromise1.catch === 'function') {
                        playPromise1.catch(err => {
                            console.error('Original timeline playback failed:', err);
                        });
                    }
                }
                if (translatedTimelineWaveform) {
                    const playPromise2 = translatedTimelineWaveform.play();
                    if (playPromise2 && typeof playPromise2.catch === 'function') {
                        playPromise2.catch(err => {
                            console.error('Translated timeline playback failed:', err);
                        });
                    }
                }
                return;
            }

            // ë‹¨ì¼ íŠ¸ë™ ì¬ìƒ ëª¨ë“œ
            const waveform = trackKey === 'original' ? originalTimelineWaveform : translatedTimelineWaveform;
            if (!waveform) {
                return;
            }

            if (trackKey === 'original' && translatedTimelineWaveform) {
                translatedTimelineWaveform.pause();
                isTranslatedTimelinePlaying = false;
            } else if (trackKey === 'translated' && originalTimelineWaveform) {
                originalTimelineWaveform.pause();
            }

            if (trackKey === 'translated') {
                isTranslatedTimelinePlaying = Boolean(translatedTimelineWaveform);
                isDialogueMutedPlaying = false;
            } else if (trackKey === 'original') {
                isTranslatedTimelinePlaying = false;
                isDialogueMutedPlaying = false;
            } else if (trackKey === 'dialogue-muted') {
                isDialogueMutedPlaying = Boolean(window.dialogueMutedTimelineWaveform);
                isTranslatedTimelinePlaying = false;
            }
            refreshBgmV2DuckState();

            timelineActiveWaveformKey = trackKey;
            if (timelinePauseBtn) {
                timelinePauseBtn.disabled = false;
            }
            if (timelineStopBtn) {
                timelineStopBtn.disabled = false;
            }

            const playPromise = waveform.play();
            if (playPromise && typeof playPromise.catch === 'function') {
                playPromise.catch(err => {
                    console.error('Timeline playback failed:', err);
                    alert('íƒ€ì„ íŠ¸ë™ ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                });
            }
        }

        function pauseTimelinePlayback() {
            if (['both', 'checked'].includes(timelineActiveWaveformKey)) {
                getAllTimelineWaveforms().forEach(waveform => waveform?.pause?.());
            } else if (timelineActiveWaveformKey === 'original' && originalTimelineWaveform) {
                originalTimelineWaveform.pause();
            } else if (timelineActiveWaveformKey === 'translated' && translatedTimelineWaveform) {
                translatedTimelineWaveform.pause();
            }
            isDialogueMutedPlaying = false;
            isTranslatedTimelinePlaying = false;
            refreshBgmV2DuckState();
        }

        async function updateComparisonTimeline() {
            const panel = document.getElementById('comparison-timeline-panel');
            if (!panel) {
                return;
            }

            timelineStatusElem = panel.querySelector('#timeline-status');
            timelinePlayOriginalBtn = panel.querySelector('#timeline-play-original-btn');
            timelinePlayTranslatedBtn = panel.querySelector('#timeline-play-translated-btn');
            timelinePlayBothBtn = panel.querySelector('#timeline-play-both-btn');
            timelinePlayCheckedBtn = panel.querySelector('#timeline-play-checked-btn');
            timelineDeleteCheckedBtn = panel.querySelector('#timeline-delete-checked-btn');
            timelinePauseBtn = panel.querySelector('#timeline-pause-btn');
            timelineStopBtn = panel.querySelector('#timeline-stop-btn');
            timelineOriginalDurationElem = panel.querySelector('#timeline-original-duration');
            timelineTranslatedDurationElem = panel.querySelector('#timeline-translated-duration');
            translatedMuteBtn = panel.querySelector('#btn-translated-mute');
            translatedTrimBtn = panel.querySelector('#btn-translated-trim');

            if (translatedMuteBtn && !translatedMuteBtn.dataset.boundMute) {
                translatedMuteBtn.addEventListener('click', handleTranslatedMuteClick);
                translatedMuteBtn.dataset.boundMute = '1';
            }
            if (translatedTrimBtn && !translatedTrimBtn.dataset.boundTrim) {
                translatedTrimBtn.addEventListener('click', handleTranslatedTrimClick);
                translatedTrimBtn.dataset.boundTrim = '1';
            }

            updateTranslatedMuteButton(Boolean(translatedTimelineWaveform));

            const originalTrackContainer = panel.querySelector('#timeline-track-original');
            const translatedTrackContainer = panel.querySelector('#timeline-track-translated');

            stopComparisonTimeline({ clearHighlight: false });
            await destroyComparisonWaveforms();

            if (typeof WaveSurfer === 'undefined') {
                if (timelineStatusElem) {
                    timelineStatusElem.textContent = 'WaveSurfer ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ ì£¼ì„¸ìš”.';
                }
                if (timelinePlayOriginalBtn) timelinePlayOriginalBtn.disabled = true;
                if (timelinePlayTranslatedBtn) timelinePlayTranslatedBtn.disabled = true;
                if (timelinePauseBtn) timelinePauseBtn.disabled = true;
                if (timelineStopBtn) timelineStopBtn.disabled = true;
                return;
            }

            const extras = currentProject?.extra || {};
            const storedBgmPath = extras.bgm_path || extras.bgm_custom_path || '';
            const storedBgmPercent = Number.isFinite(Number(extras.bgm_volume_percent))
                ? Number(extras.bgm_volume_percent)
                : 100;
            const storedBgmCache = extras.bgm_cache_token || Date.now();
            if (storedBgmPath) {
                setBgmTrack(storedBgmPath, {
                    volumePercent: storedBgmPercent,
                    cacheToken: storedBgmCache,
                });
            } else {
                setBgmTrack('', { force: true });
            }

            const storedBgmV2Path = extras.bgm_v2_path || extras.bgm_custom_v2_path || '';
            const storedBgmV2Percent = Number.isFinite(Number(extras.bgm_v2_volume_percent))
                ? Number(extras.bgm_v2_volume_percent)
                : 100;
            const storedBgmV2Cache = extras.bgm_v2_cache_token || Date.now();
            if (storedBgmV2Path) {
                setBgmV2Track(storedBgmV2Path, {
                    volumePercent: storedBgmV2Percent,
                    cacheToken: storedBgmV2Cache,
                });
            } else {
                setBgmV2Track('', { force: true });
            }

            const rawOriginalUrl = getOriginalTimelineAudioUrl();
            const rawTranslatedUrl = getTranslatedTimelineAudioUrl();
            const originalUrl = rawOriginalUrl ? toWebAudioPath(rawOriginalUrl) : '';
            const translatedUrl = rawTranslatedUrl ? toWebAudioPath(rawTranslatedUrl) : '';

            updateTranslatedMuteButton(Boolean(translatedUrl));
            if (translatedTrimBtn) {
                if (!translatedTrimBtn.dataset.locked) {
                    translatedTrimBtn.disabled = !translatedUrl;
                }
            }

            // í•­ìƒ ë‘ íŠ¸ë™ ì»¨í…Œì´ë„ˆë¥¼ í‘œì‹œ
            if (originalTrackContainer) {
                originalTrackContainer.style.display = '';
            }
            if (translatedTrackContainer) {
                translatedTrackContainer.style.display = '';
            }

            const hasAnyTrack = Boolean(originalUrl || translatedUrl);

            if (!hasAnyTrack) {
                if (timelineStatusElem) {
                    timelineStatusElem.textContent = 'íƒ€ì„ íŠ¸ë™ì„ í‘œì‹œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì›ë³¸ ìŒì„± ë˜ëŠ” ë²ˆì—­ ìŒì„±ì„ ë¨¼ì € ì¤€ë¹„í•´ì£¼ì„¸ìš”.';
                }
                if (timelinePlayOriginalBtn) timelinePlayOriginalBtn.disabled = true;
                if (timelinePlayTranslatedBtn) timelinePlayTranslatedBtn.disabled = true;
                if (timelinePauseBtn) timelinePauseBtn.disabled = true;
                if (timelineStopBtn) timelineStopBtn.disabled = true;
                updateTimelineDuration(0, timelineOriginalDurationElem);
                updateTimelineDuration(0, timelineTranslatedDurationElem);
                return;
            }

            if (timelineStatusElem) {
                const notices = [];
                if (!originalUrl) {
                    notices.push('ì›ë³¸ ìŒì„± íŒŒì¼ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì›ë³¸ ì˜ìƒì„ ë“±ë¡í•˜ë©´ íƒ€ì„ íŠ¸ë™ì— í‘œì‹œë©ë‹ˆë‹¤.');
                }
                if (!translatedUrl) {
                    notices.push('ë²ˆì—­ ìŒì„± íŠ¸ë™ì„ ë§Œë“¤ë ¤ë©´ "ì„ íƒ ìë§‰ ìŒì„± ìƒì„±" ë˜ëŠ” "ì „ì²´ ìŒì„± ìƒì„±"ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.');
                }
                timelineStatusElem.textContent = notices.length
                    ? notices.join(' ')
                    : 'íƒ€ì„ íŠ¸ë™ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ì›í•˜ëŠ” íŠ¸ë™ì„ ì„ íƒí•´ ë¹„êµí•˜ì„¸ìš”.';
            }

            if (timelinePauseBtn) timelinePauseBtn.disabled = true;
            if (timelineStopBtn) timelineStopBtn.disabled = true;

            if (timelinePlayOriginalBtn) timelinePlayOriginalBtn.disabled = !originalUrl;
            if (timelinePlayTranslatedBtn) timelinePlayTranslatedBtn.disabled = !translatedUrl;

            if (timelinePlayOriginalBtn) {
                timelinePlayOriginalBtn.onclick = () => playTimelineTrack('original');
            }
            if (timelinePlayTranslatedBtn) {
                timelinePlayTranslatedBtn.onclick = () => playTimelineTrack('translated');
            }
            if (timelinePlayBothBtn) {
                timelinePlayBothBtn.onclick = () => playTimelineTrack('both');
            }
            if (timelinePlayCheckedBtn) {
                timelinePlayCheckedBtn.onclick = () => playTimelineTrack('checked');
            }
            if (timelineDeleteCheckedBtn) {
                timelineDeleteCheckedBtn.onclick = () => {
                    deleteCheckedTracks().catch((error) => console.error('Failed to delete checked tracks:', error));
                };
            }
            if (timelinePauseBtn) {
                timelinePauseBtn.onclick = () => {
                    pauseTimelinePlayback();
                };
            }
            if (timelineStopBtn) {
                timelineStopBtn.onclick = () => {
                    stopComparisonTimeline({ clearHighlight: false });
                };
            }

            const segments = currentProject?.segments || [];

            const originalWaveformContainer = document.getElementById('timeline-original-waveform');
            if (originalUrl) {
                // ì›ë³¸ ì˜¤ë””ì˜¤ê°€ ìˆëŠ” ê²½ìš°
                if (originalWaveformContainer) {
                    originalWaveformContainer.innerHTML = ''; // ì´ì „ ë‚´ìš© ì œê±°
                    originalWaveformContainer.style.display = '';
                }

                const originalRegionsPlugin = window.WaveSurfer?.Regions?.create({ dragSelection: false });
                originalTimelineWaveform = WaveSurfer.create({
                    container: '#timeline-original-waveform',
                    height: 90,
                    waveColor: '#3ba4ff',
                    progressColor: '#1c6dff',
                    cursorColor: '#ffd166',
                    normalize: true,
                    responsive: true,
                    plugins: originalRegionsPlugin ? [originalRegionsPlugin] : [],
                });
                originalTimelineWaveform.on('ready', () => {
                    updateTimelineDuration(originalTimelineWaveform.getDuration(), timelineOriginalDurationElem);
                    const regions = originalTimelineWaveform.getActivePlugins()?.regions;
                    if (regions && segments.length) {
                        regions.clearRegions();
                        segments.forEach((seg, index) => {
                            regions.addRegion({
                                id: `orig-${index}`,
                                start: seg.start,
                                end: seg.end,
                                drag: false,
                                resize: false,
                                color: 'rgba(59, 164, 255, 0.18)',
                            });
                        });
                    }
                });
                originalTimelineWaveform.on('audioprocess', (time) => handleTimelineTimeUpdate('original', time));
                originalTimelineWaveform.on('seek', () => handleTimelineTimeUpdate('original', originalTimelineWaveform.getCurrentTime()));
                originalTimelineWaveform.on('finish', () => handleTimelineFinish('original'));
                originalTimelineWaveform.on('error', (err) => {
                    console.error('Original waveform load error:', err, 'URL:', originalUrl);
                });
                console.log('Loading original timeline:', originalUrl);
                originalTimelineWaveform.load(originalUrl);
                originalTimelineUrl = originalUrl;
            } else {
                // ì›ë³¸ ì˜¤ë””ì˜¤ê°€ ì—†ëŠ” ê²½ìš° ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
                if (originalWaveformContainer) {
                    originalWaveformContainer.innerHTML = `
                        <div style="
                            height: 90px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            background: #0d1520;
                            border-radius: 8px;
                            color: #9ca3af;
                            font-size: 14px;
                        ">
                            ì›ë³¸ ìŒì„± íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ì›ë³¸ ì˜ìƒì„ ë“±ë¡í•˜ë©´ í‘œì‹œë©ë‹ˆë‹¤.
                        </div>
                    `;
                }
                updateTimelineDuration(0, timelineOriginalDurationElem);
            }

            const translatedWaveformContainer = document.getElementById('timeline-translated-waveform');
            if (translatedUrl) {
                // ë²ˆì—­ ì˜¤ë””ì˜¤ê°€ ìˆëŠ” ê²½ìš°
                if (translatedWaveformContainer) {
                    translatedWaveformContainer.innerHTML = ''; // ì´ì „ ë‚´ìš© ì œê±°
                    translatedWaveformContainer.style.display = '';
                }

                const translatedRegionsPlugin = window.WaveSurfer?.Regions?.create({ dragSelection: false });
                translatedTimelineWaveform = WaveSurfer.create({
                    container: '#timeline-translated-waveform',
                    height: 90,
                    waveColor: '#ff9f1c',
                    progressColor: '#ff7c43',
                    cursorColor: '#ffd166',
                    normalize: true,
                    responsive: true,
                    plugins: translatedRegionsPlugin ? [translatedRegionsPlugin] : [],
                });
                translatedTimelineWaveform.on('ready', () => {
                    updateTimelineDuration(translatedTimelineWaveform.getDuration(), timelineTranslatedDurationElem);
                    const regions = translatedTimelineWaveform.getActivePlugins()?.regions;
                    if (regions && segments.length) {
                        regions.clearRegions();
                        segments.forEach((seg, index) => {
                            regions.addRegion({
                                id: `trans-${index}`,
                                start: seg.start,
                                end: seg.end,
                                drag: false,
                                resize: false,
                                color: 'rgba(255, 159, 28, 0.20)',
                            });
                        });
                    }
                    applyTranslatedMuteState();
                });
                translatedTimelineWaveform.on('audioprocess', (time) => handleTimelineTimeUpdate('translated', time));
                translatedTimelineWaveform.on('seek', () => handleTimelineTimeUpdate('translated', translatedTimelineWaveform.getCurrentTime()));
                translatedTimelineWaveform.on('finish', () => handleTimelineFinish('translated'));
                translatedTimelineWaveform.on('error', (err) => {
                    logWaveformError('Translated', err, translatedUrl);
                });
                console.log('Loading translated timeline:', translatedUrl);
                translatedTimelineWaveform.load(translatedUrl);
                translatedTimelineUrl = translatedUrl;
            } else {
                // ë²ˆì—­ ì˜¤ë””ì˜¤ê°€ ì—†ëŠ” ê²½ìš° ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
                if (translatedWaveformContainer) {
                    translatedWaveformContainer.innerHTML = `
                        <div style="
                            height: 90px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            background: #0d1520;
                            border-radius: 8px;
                            color: #9ca3af;
                            font-size: 14px;
                        ">
                            ë²ˆì—­ ìŒì„± íŠ¸ë™ì´ ì—†ìŠµë‹ˆë‹¤. "ì„ íƒ ìë§‰ ìŒì„± ìƒì„±" ë˜ëŠ” "ì „ì²´ ìŒì„± ìƒì„±"ì„ ì‹¤í–‰í•˜ì„¸ìš”.
                        </div>
                    `;
                }
                updateTimelineDuration(0, timelineTranslatedDurationElem);
                updateTranslatedMuteButton(false);
            }
        }

        function playSegmentAudio(segmentId, audioPath) {
            if (!segmentId || !audioPath) {
                return;
            }

            stopComparisonTimeline({ clearHighlight: highlightedSegmentId !== segmentId });
            stopAllAudio({ clearHighlight: highlightedSegmentId !== segmentId });
            stopSingleAudioPlayback({ clearHighlight: highlightedSegmentId !== segmentId });

            // ì„¸ê·¸ë¨¼íŠ¸ ì •ë³´ ì°¾ê¸°
            const segment = currentProject?.segments?.find(seg => seg.id === segmentId);
            if (!segment) {
                console.error('Segment not found:', segmentId);
                return;
            }

            const resolvedPath = toWebAudioPath(audioPath);
            const audio = new Audio(resolvedPath);
            singleSegmentAudio = audio;
            singleSegmentSegmentId = segmentId;

            applySegmentHighlight(segmentId, { scroll: true });

            const isTrimmedClip = /\/audio\/segment_/i.test(resolvedPath);
            const segmentDuration = (segment.end || 0) - (segment.start || 0);
            let playbackStartTime = segment.start || 0;
            let playbackStopTime = segment.end || 0;

            // ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘ ì‹œê°„ìœ¼ë¡œ ì´ë™í•˜ê³ , ë ì‹œê°„ì—ì„œ ë©ˆì¶”ê¸°
            audio.addEventListener('loadedmetadata', () => {
                if (isTrimmedClip) {
                    playbackStartTime = 0;
                    playbackStopTime = isFinite(audio.duration) && !isNaN(audio.duration)
                        ? audio.duration
                        : Math.max(segment.audio_duration || segment.audio_generated_duration || segmentDuration, segmentDuration);
                } else {
                    playbackStartTime = segment.start || 0;
                    const fallback = isFinite(audio.duration) && !isNaN(audio.duration) ? audio.duration : segment.end || playbackStartTime;
                    playbackStopTime = Math.min(segment.end || fallback, fallback);
                }

                audio.currentTime = playbackStartTime;
                console.log(`Starting playback at ${playbackStartTime}s, will stop at ${playbackStopTime}s (trimmed: ${isTrimmedClip})`);
            });

            // ì¬ìƒ ì¤‘ ì‹œê°„ ì—…ë°ì´íŠ¸ - íƒ€ì„ë¼ì¸ ë°” ì—…ë°ì´íŠ¸
            audio.addEventListener('timeupdate', () => {
                // ì„¸ê·¸ë¨¼íŠ¸ ëì— ë„ë‹¬í•˜ë©´ ë©ˆì¶”ê¸°
                const stopThreshold = Math.max(playbackStopTime - 0.05, playbackStartTime);
                if (audio.currentTime >= stopThreshold) {
                    audio.pause();
                    audio.currentTime = playbackStartTime;
                    if (highlightedSegmentId === segmentId) {
                        clearSegmentHighlight();
                    }
                    if (singleSegmentAudio === audio) {
                        singleSegmentAudio = null;
                        singleSegmentSegmentId = null;
                    }
                }

                // íƒ€ì„ë¼ì¸ WaveSurferê°€ ìˆìœ¼ë©´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì‹œê°ì  í”¼ë“œë°±)
                if (!isTrimmedClip && translatedTimelineWaveform && translatedTimelineWaveform.getDuration() > 0) {
                    const progress = audio.currentTime / translatedTimelineWaveform.getDuration();
                    translatedTimelineWaveform.seekTo(progress);
                }
            });

            audio.addEventListener('ended', () => {
                if (highlightedSegmentId === segmentId) {
                    clearSegmentHighlight();
                }
                if (singleSegmentAudio === audio) {
                    singleSegmentAudio = null;
                    singleSegmentSegmentId = null;
                }
            });

            audio.addEventListener('error', (event) => {
                console.error('Failed to play audio:', event?.error || event);
                alert('ìŒì„± ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ìŒì„±ì„ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                if (highlightedSegmentId === segmentId) {
                    clearSegmentHighlight();
                }
                if (singleSegmentAudio === audio) {
                    singleSegmentAudio = null;
                    singleSegmentSegmentId = null;
                }
            });

            const playPromise = audio.play();
            if (playPromise && typeof playPromise.catch === 'function') {
                playPromise.catch(err => {
                    console.error('Failed to play audio:', err);
                    alert('ìŒì„± ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    if (highlightedSegmentId === segmentId) {
                        clearSegmentHighlight();
                    }
                    if (singleSegmentAudio === audio) {
                        singleSegmentAudio = null;
                        singleSegmentSegmentId = null;
                    }
                });
            }
        }

        function buildTextRow({ segmentId, label, type, value, rowClass, extraButtons = '', showLabel = true, speaker = null }) {
            const safeValue = escapeHtml(value || '');
            const labelAttr = showLabel ? '' : ' class="hidden-label"';
            const extraRowClass = showLabel ? '' : ' no-label';
            const speakerBadge = speaker ? `<span class="speaker-badge">${escapeHtml(speaker)}</span>` : '';
            return `
                <div class="text-row ${rowClass}${extraRowClass}">
                    <label${labelAttr}>${speakerBadge ? speakerBadge + ' ' : ''}${label}</label>
                    <div class="text-content" data-type="${type}" data-segment-id="${segmentId}">
                        <span class="text-display">${safeValue}</span>
                        <textarea class="text-edit" style="display: none;" rows="2">${safeValue}</textarea>
                        <div class="text-buttons">
                            <button class="btn-edit-text" data-type="${type}" data-segment-id="${segmentId}" title="${label} ìˆ˜ì •">ìˆ˜ì •</button>
                            <button class="btn-copy-text" data-type="${type}" data-segment-id="${segmentId}" title="${label} ë³µì‚¬">ë³µì‚¬</button>
                            ${extraButtons}
                            <button class="btn-delete-text" data-type="${type}" data-segment-id="${segmentId}" title="${label} ì‚­ì œ">ì‚­ì œ</button>
                        </div>
                        <div class="last-modified" style="font-size: 0.8em; color: #888; margin-top: 4px;"></div>
                    </div>
                </div>
            `;
        }

        function buildAudioRow({ segmentId, audioPath, showLabel = true }) {
            const labelAttr = showLabel ? '' : ' class="hidden-label"';
            const extraRowClass = showLabel ? '' : ' no-label';
            const hasAudio = audioPath && audioPath.trim() !== '';
            const audioFileName = hasAudio ? extractFileName(audioPath) : 'ìŒì„± íŒŒì¼ ì—†ìŒ';

            return `
                <div class="text-row audio-row${extraRowClass}">
                    <label${labelAttr}>ì¼ë³¸ì–´ ìŒì„± íŒŒì¼</label>
                    <div class="audio-content" data-segment-id="${segmentId}">
                        <span class="audio-display">${escapeHtml(audioFileName)}</span>
                        <div class="audio-buttons">
                            ${hasAudio ? `
                                <button class="btn-play-audio" data-segment-id="${segmentId}" data-audio-path="${escapeHtml(audioPath)}" title="ìŒì„± ë“£ê¸°">â–¶ï¸ ë“£ê¸°</button>
                            ` : ''}
                            <button class="btn-generate-audio" data-segment-id="${segmentId}" title="ìŒì„± ìƒì„±">ğŸ”Š ìƒì„±</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function extractFileName(path) {
            if (!path) {
                return '';
            }
            const normalized = String(path).replace(/\\/g, '/');
            const parts = normalized.split('/').filter(Boolean);
            return parts.length ? parts[parts.length - 1] : normalized;
        }


        function formatTimestamp(seconds) {
            if (typeof seconds !== 'number' || Number.isNaN(seconds)) {
                return '00:00.00';
            }
            const totalSeconds = Math.max(seconds, 0);
            const minutes = Math.floor(totalSeconds / 60);
            const remainder = totalSeconds - minutes * 60;
            const secondsStr = remainder.toFixed(2).padStart(5, '0');
            const minutesStr = String(minutes).padStart(2, '0');
            return `${minutesStr}:${secondsStr}`;
        }

        function formatDuration(seconds) {
            if (typeof seconds !== 'number' || Number.isNaN(seconds)) {
                return '00:00';
            }
            const totalSeconds = Math.max(seconds, 0);
            const minutes = Math.floor(totalSeconds / 60);
            const secs = Math.floor(totalSeconds % 60);
            const minutesStr = String(minutes).padStart(2, '0');
            const secondsStr = String(secs).padStart(2, '0');
            return `${minutesStr}:${secondsStr}`;
        }

        function formatDurationDelta(deltaSeconds) {
            if (typeof deltaSeconds !== 'number' || Number.isNaN(deltaSeconds)) {
                return '';
            }

            const rounded = Math.round(deltaSeconds * 100) / 100;
            const absValue = Math.abs(rounded);

            let valueStr = absValue.toFixed(2);
            valueStr = valueStr.replace(/\.00$/, '');
            valueStr = valueStr.replace(/(\.\d)0$/, '$1');

            if (!valueStr) {
                valueStr = '0.0';
            } else if (!valueStr.includes('.')) {
                valueStr = `${valueStr}.0`;
            }

            const sign = rounded > 0 ? '+' : rounded < 0 ? '-' : 'Â±';
            return `${sign}${valueStr}ì´ˆ`;
        }


        function buildSegmentTime(seg) {
            const startTime = formatTimestamp(seg.start || 0);
            const endTime = formatTimestamp(seg.end || 0);
            const targetDuration = Math.max((seg.end || 0) - (seg.start || 0), 0);
            const duration = targetDuration.toFixed(1);

            const generatedDuration = typeof seg.audio_generated_duration === 'number'
                ? seg.audio_generated_duration
                : (typeof seg.audio_duration === 'number' ? seg.audio_duration : null);

            let deltaHtml = '';
            if (typeof generatedDuration === 'number' && Number.isFinite(generatedDuration)) {
                const deltaSeconds = generatedDuration - targetDuration;
                const absDelta = Math.abs(deltaSeconds);
                const deltaClass = absDelta < 0.01
                    ? 'neutral'
                    : deltaSeconds > 0
                        ? 'positive'
                        : 'negative';
                const formattedDelta = formatDurationDelta(deltaSeconds);
                if (formattedDelta) {
                    deltaHtml = `<span class="time-audio-diff ${deltaClass}" title="ìƒì„± ìŒì„±ê³¼ ìë§‰ ê¸¸ì´ ì°¨ì´">${formattedDelta}</span>`;
                }
            }

            return `
                <div class="time-display" data-segment-id="${seg.id}" title="í´ë¦­í•˜ì—¬ ì‹œê°„ ìˆ˜ì •">
                    <span class="start-time">${startTime}</span>
                    <span class="time-separator">â†’</span>
                    <span class="end-time">${endTime}</span>
                    <span class="time-duration">(${duration}ì´ˆ)</span>
                    ${deltaHtml}
                </div>
                <div class="time-edit" data-segment-id="${seg.id}" style="display: none;">
                    <input type="number" class="start-input" step="0.01" value="${(seg.start || 0).toFixed(2)}" min="0">
                    <span class="time-separator">â†’</span>
                    <input type="number" class="end-input" step="0.01" value="${(seg.end || 0).toFixed(2)}" min="0">
                    <div class="time-edit-buttons">
                        <button type="button" class="btn-save-time" data-segment-id="${seg.id}">ì €ì¥</button>
                        <button type="button" class="btn-cancel-time" data-segment-id="${seg.id}">ì·¨ì†Œ</button>
                    </div>
                </div>
            `;
        }


        function buildSegmentCheckbox(seg) {
            return `<input type="checkbox" class="segment-select" data-segment-id="${seg.id}" aria-label="ì„¸ê·¸ë¨¼íŠ¸ ì„ íƒ">`;
        }


        function buildCardSegments(project) {
            if (!project.segments || !project.segments.length) {
                return '<p class="empty-state">ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë²ˆì—­ì„ ì‹¤í–‰í•œ ë’¤ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.</p>';
            }

            return project.segments
                .map((seg, index) => {
                    const sourceRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.source,
                        type: 'source',
                        value: seg.source_text || '',
                        rowClass: 'korean original',
                        speaker: seg.speaker_name || null,
                        showLabel: true
                    });
                    const reinterpretRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.commentary_korean,
                        type: 'commentary_korean',
                        value: seg.commentary_korean || seg.source_text || '',
                        rowClass: 'korean reinterpretation',
                        speaker: seg.speaker_name || null,
                        showLabel: true
                    });
                    const japaneseRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.translated,
                        type: 'translated',
                        value: seg.translated_text || '',
                        rowClass: 'japanese',
                        extraButtons: `<button class="btn-translate-reverse" data-segment-id="${seg.id}" title="ì¼ë³¸ì–´â†’í•œêµ­ì–´ ì—­ë²ˆì—­">ì—­ë²ˆì—­</button>`,
                        showLabel: true
                    });
                    // Debug: ìŒì„± íŒŒì¼ ê²½ë¡œ í™•ì¸ ë° ë³€í™˜
                    let audioPath = seg.audio_path || '';
                    if (audioPath) {
                        console.log(`Segment ${seg.id} original audio_path:`, audioPath);

                        // ì ˆëŒ€ ê²½ë¡œë¥¼ ì›¹ URLë¡œ ë³€í™˜
                        if (audioPath.includes('/ai_shorts_maker/outputs/')) {
                            const parts = audioPath.split('/ai_shorts_maker/outputs/');
                            if (parts.length > 1) {
                                audioPath = '/outputs/' + parts[1];
                                console.log(`Converted to:`, audioPath);
                            }
                        }
                    }
                    const audioRow = buildAudioRow({
                        segmentId: seg.id,
                        audioPath: audioPath,
                        showLabel: true
                    });
                    const reverseRow = buildTextRow({
                        segmentId: seg.id,
                        label: TEXT_TYPE_LABELS.reverse_translated,
                        type: 'reverse_translated',
                        value: seg.reverse_translated_text || '',
                        rowClass: 'korean reverse',
                        showLabel: true
                    });

                    return `
                <div class="segment-item" data-segment-id="${seg.id}">
                    <div class="segment-header">
                        <div class="segment-select-cell">
                            ${buildSegmentCheckbox(seg)}
                            <span class="segment-index">${index + 1}</span>
                        </div>
                        <div class="segment-time" data-segment-id="${seg.id}">
                            ${buildSegmentTime(seg)}
                        </div>
                        <div class="segment-actions">
                            <button class="btn-move-up" data-segment-id="${seg.id}" title="ìœ„ë¡œ ì´ë™">â¬†ï¸</button>
                            <button class="btn-move-down" data-segment-id="${seg.id}" title="ì•„ë˜ë¡œ ì´ë™">â¬‡ï¸</button>
                            <button class="btn-edit-segment" data-segment-id="${seg.id}" title="ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜ì •">âœï¸</button>
                            <button class="btn-delete-segment" data-segment-id="${seg.id}" title="ì„¸ê·¸ë¨¼íŠ¸ ì‚­ì œ">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div class="segment-content">
                        <div class="text-pair translation-stack">
                            ${sourceRow}
                            ${reinterpretRow}
                            ${japaneseRow}
                            ${audioRow}
                            ${reverseRow}
                        </div>
                    </div>
                </div>
            `;
                })
                .join('');
        }


        function buildTimelineRow(seg, index) {
            const sourceCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.source,
                type: 'source',
                value: seg.source_text || '',
                rowClass: 'korean original',
                speaker: seg.speaker_name || null,
                showLabel: false
            });
            const reinterpretCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.commentary_korean,
                type: 'commentary_korean',
                value: seg.commentary_korean || seg.source_text || '',
                rowClass: 'korean reinterpretation',
                speaker: seg.speaker_name || null,
                showLabel: false
            });
            const japaneseCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.translated,
                type: 'translated',
                value: seg.translated_text || '',
                rowClass: 'japanese',
                extraButtons: `<button class="btn-translate-reverse" data-segment-id="${seg.id}" title="ì¼ë³¸ì–´â†’í•œêµ­ì–´ ì—­ë²ˆì—­">ì—­ë²ˆì—­</button>`,
                showLabel: false
            });
            const reverseCell = buildTextRow({
                segmentId: seg.id,
                label: TEXT_TYPE_LABELS.reverse_translated,
                type: 'reverse_translated',
                value: seg.reverse_translated_text || '',
                rowClass: 'korean reverse',
                showLabel: false
            });

            return `
                <div class="timeline-row segment-item" data-segment-id="${seg.id}">
                    <div class="timeline-col timeline-index">
                        ${buildSegmentCheckbox(seg)}
                        <span class="segment-index">${index + 1}</span>
                    </div>
                    <div class="timeline-col timeline-time">
                        <div class="segment-time" data-segment-id="${seg.id}">
                            ${buildSegmentTime(seg)}
                            <div class="segment-actions timeline-actions">
                                <button class="btn-move-up" data-segment-id="${seg.id}" title="ìœ„ë¡œ ì´ë™">â¬†ï¸</button>
                                <button class="btn-move-down" data-segment-id="${seg.id}" title="ì•„ë˜ë¡œ ì´ë™">â¬‡ï¸</button>
                                <button class="btn-edit-segment" data-segment-id="${seg.id}" title="ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜ì •">âœï¸</button>
                                <button class="btn-delete-segment" data-segment-id="${seg.id}" title="ì„¸ê·¸ë¨¼íŠ¸ ì‚­ì œ">ğŸ—‘ï¸</button>
                            </div>
                        </div>
                    </div>
                    <div class="timeline-col timeline-text">${sourceCell}</div>
                    <div class="timeline-col timeline-text">${reinterpretCell}</div>
                    <div class="timeline-col timeline-text">${japaneseCell}</div>
                    <div class="timeline-col timeline-text">${reverseCell}</div>
                </div>
            `;
        }


        function buildTimelineSegments(project) {
            if (!project.segments || !project.segments.length) {
                return '<p class="empty-state">ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë²ˆì—­ì„ ì‹¤í–‰í•œ ë’¤ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.</p>';
            }

            const header = `
                <div class="timeline-row timeline-header">
                    <div class="timeline-col timeline-index">#</div>
                    <div class="timeline-col timeline-time">íƒ€ì„ìŠ¤íƒ¬í”„</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.source}</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.commentary_korean}</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.translated}</div>
                    <div class="timeline-col timeline-text">${TEXT_TYPE_LABELS.reverse_translated}</div>
                </div>
            `;

            const rows = project.segments
                .map((seg, index) => buildTimelineRow(seg, index))
                .join('');

            return `<div class="timeline-scroll">${header}${rows}</div>`;
        }


        function renderSegments(project) {
            if (!project || !project.segments) {
                segmentsTable.innerHTML = '<p class="empty-state">ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>';
                return;
            }

            if (isTimelineView) {
                segmentsTable.classList.add('timeline-active');
                segmentsTable.innerHTML = buildTimelineSegments(project);
            } else {
                segmentsTable.classList.remove('timeline-active');
                segmentsTable.innerHTML = buildCardSegments(project);
            }

            attachSegmentEventListeners();
            attachTimeEditListeners();
            attachSelectionCheckboxListeners();
            attachTrackProcessingEventListeners();
            updateSelectionUI();
            reapplyHighlight();
        }

        function openSourceSelectorModal() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            selectedSourceIndex = null;
            selectedSavedResultId = null;
            sourceSelectorApplyBtn.disabled = true;
            sourceSelectorModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
            switchSourceSelectorMode('downloads');
        }

        function closeSourceSelectorModal() {
            sourceSelectorModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
            selectedSourceIndex = null;
            selectedSavedResultId = null;
            sourceSelectorApplyBtn.disabled = true;
        }

        function updateSourceApplyState() {
            if (sourceSelectorMode === 'downloads') {
                sourceSelectorApplyBtn.disabled = selectedSourceIndex === null;
            } else if (sourceSelectorMode === 'projects') {
                sourceSelectorApplyBtn.disabled = !selectedProjectId;
            } else {
                sourceSelectorApplyBtn.disabled = !selectedSavedResultId || !savedResultDetailCache[selectedSavedResultId];
            }
        }

        function loadDownloadSources() {
            const cacheBuster = Date.now();
            sourceSelectorList.innerHTML = '<p class="empty-state">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';

            fetch(`/api/translator/downloads?_cb=${cacheBuster}`)
                .then(res => res.ok ? res.json() : Promise.reject(new Error(`HTTP ${res.status}`)))
                .then(items => {
                    availableSourceOptions = Array.isArray(items) ? items : [];
                    renderDownloadOptions();
                })
                .catch(err => {
                    console.error('Failed to load source options:', err);
                    sourceSelectorList.innerHTML = '<p class="empty-state error">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>';
                });
        }

        function renderDownloadOptions() {
            if (!availableSourceOptions.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë‹¤ìš´ë¡œë“œ ë„êµ¬ì—ì„œ íŒŒì¼ì„ ë°›ì•„ì£¼ì„¸ìš”.</p>';
                return;
            }

            const html = availableSourceOptions.map((item, index) => {
                const baseName = item.base_name || extractFileName(item.video_path) || `ì˜ìƒ ${index + 1}`;
                const subtitleName = item.subtitle_path ? extractFileName(item.subtitle_path) : 'ìë§‰ ì—†ìŒ';
                const videoName = extractFileName(item.video_path);
                return `
                    <label class="source-option">
                        <input type="radio" name="source-selection" value="${index}">
                        <div class="source-option-body">
                            <div class="option-title">${escapeHtml(baseName)}</div>
                            <div class="option-meta">
                                <span class="option-video">ğŸ¬ ${escapeHtml(videoName || 'ì•Œ ìˆ˜ ì—†ìŒ')}</span>
                                <span class="option-subtitle">ğŸ“ ${escapeHtml(subtitleName)}</span>
                            </div>
                        </div>
                    </label>
                `;
            }).join('');

            sourceSelectorList.innerHTML = html;
            sourceSelectorList.querySelectorAll('input[name="source-selection"]').forEach(input => {
                input.addEventListener('change', (event) => {
                    selectedSourceIndex = parseInt(event.target.value, 10);
                    selectedSavedResultId = null;
                    updateSourceApplyState();
                });
            });
            updateSourceApplyState();
        }

        function loadTranslatorProjects() {
            sourceSelectorList.innerHTML = '<p class="empty-state">í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';
            fetch('/api/translator/projects')
                .then(res => res.ok ? res.json() : Promise.reject(new Error(`HTTP ${res.status}`)))
                .then(projects => {
                    translatorProjects = Array.isArray(projects) ? projects : [];
                    renderTranslatorProjects();
                })
                .catch(err => {
                    console.error('Failed to load translator projects:', err);
                    sourceSelectorList.innerHTML = '<p class="empty-state error">í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>';
                });
        }

        function renderTranslatorProjects() {
            if (!translatorProjects.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">ì €ì¥ëœ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            // í˜„ì¬ í”„ë¡œì íŠ¸ëŠ” ì œì™¸
            const otherProjects = translatorProjects.filter(p => p.id !== (currentProject?.id));

            if (!otherProjects.length) {
                sourceSelectorList.innerHTML = '<p class="empty-state">ë‹¤ë¥¸ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            console.log('ğŸ“‹ Rendering translator projects:', otherProjects.length);

            const html = otherProjects.map((project, index) => {
                console.log(`Project ${index}:`, {
                    id: project.id,
                    base_name: project.base_name,
                    created_at: project.created_at,
                    segments: project.segments?.length
                });

                // í”„ë¡œì íŠ¸ ì´ë¦„ í‘œì‹œ (base_name ë˜ëŠ” idì—ì„œ ì¶”ì¶œ)
                let displayName = project.base_name || project.id || 'ì´ë¦„ ì—†ìŒ';

                // backup_ ì ‘ë‘ì‚¬ ì œê±°
                if (displayName.startsWith('backup_')) {
                    displayName = displayName.substring(7); // 'backup_' ì œê±°
                }

                // íƒ€ì„ìŠ¤íƒ¬í”„ íŒ¨í„´ ì œê±° (_20250930_194830 í˜•íƒœ)
                displayName = displayName.replace(/_\d{8}_\d{6}$/, '');

                // ì´ë¦„ì´ ë„ˆë¬´ ê¸¸ë©´ ìë¥´ê¸° (50ì ì´ìƒ)
                if (displayName.length > 50) {
                    displayName = displayName.substring(0, 47) + '...';
                }

                const createdDate = project.created_at ? new Date(project.created_at).toLocaleString('ko-KR') : 'ì‹œê°„ ì •ë³´ ì—†ìŒ';
                const updatedDate = project.updated_at ? new Date(project.updated_at).toLocaleString('ko-KR') : null;
                const segmentCount = project.segments?.length || 0;
                const statusText = project.status || 'draft';

                return `
                    <label class="source-option">
                        <input type="radio" name="project-selection" value="${project.id}">
                        <div class="source-option-body">
                            <div class="option-title">ğŸ“ ${escapeHtml(displayName)}</div>
                            <div class="option-meta">
                                <span>ğŸ“Š ì„¸ê·¸ë¨¼íŠ¸: ${segmentCount}ê°œ</span>
                                <span>ğŸ“Œ ìƒíƒœ: ${statusText}</span>
                                <span>ğŸ•’ ìƒì„±: ${escapeHtml(createdDate)}</span>
                                ${updatedDate ? `<span>âœï¸ ìˆ˜ì •: ${escapeHtml(updatedDate)}</span>` : ''}
                            </div>
                        </div>
                    </label>
                `;
            }).join('');

            sourceSelectorList.innerHTML = html;
            sourceSelectorList.querySelectorAll('input[name="project-selection"]').forEach(input => {
                input.addEventListener('change', (event) => {
                    selectedProjectId = event.target.value;
                    selectedSourceIndex = null;
                    selectedSavedResultId = null;
                    updateSourceApplyState();
                });
            });
            updateSourceApplyState();
        }

        function loadSavedResultOptions() {
            sourceSelectorList.innerHTML = '<p class="empty-state">ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';
            fetch('/api/translator/saved-results')
                .then(res => res.ok ? res.json() : Promise.reject(new Error(`HTTP ${res.status}`)))
                .then(data => {
                    const results = Array.isArray(data?.results) ? data.results : [];
                    savedResultOptions = results;
                    renderSavedResultOptions();
                })
                .catch(err => {
                    console.error('Failed to load saved results:', err);
                    sourceSelectorList.innerHTML = '<p class="empty-state error">ì¬í•´ì„ ì €ì¥ë³¸ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>';
                });
        }

        function attachSubtitleUploadListener() {
            const uploadBtn = document.getElementById('upload-subtitle-file-btn');
            const uploadInput = document.getElementById('upload-subtitle-file-input');

            if (uploadBtn && uploadInput) {
                uploadBtn.onclick = () => {
                    uploadInput.click();
                };

                uploadInput.onchange = async (event) => {
                    const file = event.target.files?.[0];
                    if (!file) return;

                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    try {
                        // í”„ë¡œì íŠ¸ ID ê²€ì¦
                        const urlParams = new URLSearchParams(window.location.search);
                        const expectedProjectId = urlParams.get('id') || urlParams.get('project');

                        if (expectedProjectId && currentProject.id !== expectedProjectId) {
                            console.error(`âš ï¸ í”„ë¡œì íŠ¸ ID ë¶ˆì¼ì¹˜ ê°ì§€!`);
                            console.error(`   URL: ${expectedProjectId}`);
                            console.error(`   currentProject: ${currentProject.id}`);
                            alert('í”„ë¡œì íŠ¸ ì •ë³´ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\ní˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.');
                            window.location.reload();
                            return;
                        }

                        uploadBtn.disabled = true;
                        uploadBtn.textContent = 'ğŸ“¤ ì—…ë¡œë“œ ì¤‘...';

                        // ì„ íƒëœ ëŒ€ìƒ í™•ì¸
                        const targetRadio = document.querySelector('input[name="subtitle-target"]:checked');
                        const targetField = targetRadio ? targetRadio.value : 'source_text';

                        // íŒŒì¼ ì½ê¸°
                        const text = await file.text();

                        // SRT íŒŒì¼ì—ì„œ í™”ì ì •ë³´ ì¶”ì¶œ
                        const speakers = extractSpeakersFromSRT(text);
                        console.log('ğŸ¤ ì¶”ì¶œëœ í™”ì:', speakers);

                        // í™”ìê°€ ìˆìœ¼ë©´ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
                        let selectedSpeakers = null;
                        if (speakers.length > 0) {
                            selectedSpeakers = await showSpeakerSelectionDialog(speakers, text);
                            if (selectedSpeakers === null) {
                                // ì‚¬ìš©ìê°€ ì·¨ì†Œí•œ ê²½ìš°
                                uploadBtn.disabled = false;
                                uploadBtn.textContent = 'ğŸ“‹ ìë§‰ íŒŒì¼ ì—…ë¡œë“œí•˜ì—¬ ì¶”ê°€';
                                uploadInput.value = '';
                                return;
                            }
                        }

                        // ìë§‰ íŒŒì¼ì„ í”„ë¡œì íŠ¸ì— ì¶”ê°€
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/add-subtitle-text`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                subtitle_text: text,
                                subtitle_format: file.name.endsWith('.vtt') ? 'vtt' : 'srt',
                                target_field: targetField,
                                selected_speakers: selectedSpeakers  // ì„ íƒëœ í™”ì ì „ì†¡
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const result = await response.json();
                        const targetName = targetField === 'source_text' ? 'í˜„ì¬ ìë§‰(í•œêµ­ì–´)' : 'ì¬í•´ì„ìë§‰ (í•œêµ­ì–´)';
                        const speakerInfo = selectedSpeakers && selectedSpeakers.length > 0 ? ` (í™”ì: ${selectedSpeakers.join(', ')})` : '';
                        const addedCount = result.added_count || 0;
                        const replacedCount = result.replaced_count || 0;
                        const removedCount = result.removed_count || 0;
                        const lines = [`${targetName}ì— ìë§‰ì´ ì„±ê³µì ìœ¼ë¡œ ë°˜ì˜ë˜ì—ˆìŠµë‹ˆë‹¤!${speakerInfo}`];
                        lines.push(`${addedCount}ê°œì˜ ìë§‰ êµ¬ê°„ì´ ìƒˆë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        if (replacedCount > 0) {
                            lines.push(`${replacedCount}ê°œì˜ ê¸°ì¡´ ìë§‰ì´ ë™ì¼í•œ ì‹œê°„ì— ë®ì–´ì“°ê¸°ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        }
                        if (removedCount > 0) {
                            lines.push(`${removedCount}ê°œì˜ ì¤‘ë³µ ìë§‰ì´ ì •ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        }
                        alert(lines.join('\n'));

                        // ëª¨ë‹¬ ë‹«ê³  í”„ë¡œì íŠ¸ ìƒˆë¡œê³ ì¹¨
                        closeSourceSelectorModal();
                        await loadProject(currentProject.id);

                    } catch (error) {
                        console.error('ìë§‰ ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
                        alert('ìë§‰ íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
                    } finally {
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = 'ğŸ“‹ ìë§‰ íŒŒì¼ ì—…ë¡œë“œí•˜ì—¬ ì¶”ê°€';
                        uploadInput.value = '';
                    }
                };
            }
        }

        // SRT íŒŒì¼ì—ì„œ í™”ì ì •ë³´ ì¶”ì¶œ
        function extractSpeakersFromSRT(srtText) {
            const speakers = new Set();
            const lines = srtText.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // [í™”ì1], (í™”ì1), í™”ì1: ë“±ì˜ íŒ¨í„´ ê²€ìƒ‰
                const speakerMatch = line.match(/^[\[\(]?(í™”ì\d+|SPEAKER_\d+|Speaker \d+)[\]\)]?:?/i);
                if (speakerMatch) {
                    speakers.add(speakerMatch[1]);
                }
            }

            return Array.from(speakers);
        }

        // í™”ì ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
        async function showSpeakerSelectionDialog(speakers, srtText) {
            return new Promise((resolve) => {
                // ê° í™”ìì˜ ìë§‰ ê°œìˆ˜ ê³„ì‚°
                const speakerCounts = {};
                speakers.forEach(speaker => {
                    const regex = new RegExp(`^[\\[\\(]?${speaker}[\\]\\)]?:?`, 'gmi');
                    const matches = srtText.match(regex);
                    speakerCounts[speaker] = matches ? matches.length : 0;
                });

                // ë‹¤ì´ì–¼ë¡œê·¸ HTML ìƒì„±
                const dialogHTML = `
                    <div id="speaker-selection-dialog" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background-color: rgba(0, 0, 0, 0.7);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                    ">
                        <div style="
                            background: white;
                            padding: 30px;
                            border-radius: 12px;
                            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                            max-width: 500px;
                            width: 90%;
                        ">
                            <h3 style="margin-top: 0; margin-bottom: 20px; color: #000;">ğŸ¤ í™”ì ì„ íƒ</h3>
                            <p style="margin-bottom: 20px; color: #000;">ë¶ˆëŸ¬ì˜¬ ìë§‰ì˜ í™”ìë¥¼ ì„ íƒí•˜ì„¸ìš” (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥):</p>
                            <div id="speaker-options" style="margin-bottom: 20px;">
                                ${speakers.map(speaker => {
                                    const count = speakerCounts[speaker] || 0;
                                    return `
                                        <label style="display: block; margin-bottom: 12px; cursor: pointer; padding: 10px; border: 2px solid #ddd; border-radius: 6px; transition: all 0.2s; color: #000 !important; background-color: white;">
                                            <input type="checkbox" name="speaker" value="${speaker}" style="margin-right: 8px;">
                                            <strong style="color: #000 !important; font-size: 16px;">${speaker}</strong> <span style="color: #000 !important; font-size: 14px;">(${count}ê°œ)</span>
                                        </label>
                                    `;
                                }).join('')}
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button id="speaker-cancel-btn" style="
                                    padding: 10px 20px;
                                    background-color: #ccc;
                                    color: #000;
                                    border: none;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: bold;
                                ">ì·¨ì†Œ</button>
                                <button id="speaker-ok-btn" style="
                                    padding: 10px 20px;
                                    background-color: #4CAF50;
                                    color: white;
                                    border: none;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: bold;
                                ">í™•ì¸</button>
                            </div>
                        </div>
                    </div>
                `;

                // ë‹¤ì´ì–¼ë¡œê·¸ë¥¼ bodyì— ì¶”ê°€
                document.body.insertAdjacentHTML('beforeend', dialogHTML);

                const dialog = document.getElementById('speaker-selection-dialog');
                const okBtn = document.getElementById('speaker-ok-btn');
                const cancelBtn = document.getElementById('speaker-cancel-btn');

                // ì²´í¬ë°•ìŠ¤ hover íš¨ê³¼
                const labels = dialog.querySelectorAll('label');
                labels.forEach(label => {
                    // ëª¨ë“  í…ìŠ¤íŠ¸ ìš”ì†Œì— ê²€ì •ìƒ‰ ê°•ì œ ì ìš©
                    const strong = label.querySelector('strong');
                    const span = label.querySelector('span');
                    if (strong) strong.style.color = '#000';
                    if (span) span.style.color = '#000';

                    label.addEventListener('mouseenter', () => {
                        label.style.backgroundColor = '#f0f0f0';
                        label.style.borderColor = '#4CAF50';
                        if (strong) strong.style.color = '#000';
                        if (span) span.style.color = '#000';
                    });
                    label.addEventListener('mouseleave', () => {
                        label.style.backgroundColor = 'white';
                        if (strong) strong.style.color = '#000';
                        if (span) span.style.color = '#000';
                        if (!label.querySelector('input').checked) {
                            label.style.borderColor = '#ddd';
                        }
                    });
                    label.querySelector('input').addEventListener('change', () => {
                        if (label.querySelector('input').checked) {
                            label.style.borderColor = '#4CAF50';
                            label.style.backgroundColor = '#e8f5e9';
                        } else {
                            label.style.borderColor = '#ddd';
                            label.style.backgroundColor = 'white';
                        }
                        if (strong) strong.style.color = '#000';
                        if (span) span.style.color = '#000';
                    });
                });

                // í™•ì¸ ë²„íŠ¼
                okBtn.addEventListener('click', () => {
                    const checkboxes = dialog.querySelectorAll('input[name="speaker"]:checked');
                    const selectedSpeakers = Array.from(checkboxes).map(cb => cb.value);

                    if (selectedSpeakers.length === 0) {
                        alert('ìµœì†Œ 1ê°œ ì´ìƒì˜ í™”ìë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                        return;
                    }

                    dialog.remove();
                    resolve(selectedSpeakers);
                });

                // ì·¨ì†Œ ë²„íŠ¼
                cancelBtn.addEventListener('click', () => {
                    dialog.remove();
                    resolve(null);
                });

                // ESC í‚¤ë¡œ ë‹«ê¸°
                const handleKeyPress = (e) => {
                    if (e.key === 'Escape') {
                        dialog.remove();
                        resolve(null);
                        document.removeEventListener('keydown', handleKeyPress);
                    }
                };
                document.addEventListener('keydown', handleKeyPress);
            });
        }

        function renderSavedResultOptions() {
            let headerHtml = `
                <div style="margin-bottom: 15px; padding: 10px; background: #f0f4f8; border-radius: 5px;">
                    <div style="margin-bottom: 10px;">
                        <label style="font-weight: bold; display: block; margin-bottom: 8px;">ì¶”ê°€í•  ëŒ€ìƒ ì„ íƒ:</label>
                        <label style="display: inline-block; margin-right: 20px; cursor: pointer;">
                            <input type="radio" name="subtitle-target" value="source_text" checked>
                            í˜„ì¬ ìë§‰(í•œêµ­ì–´)
                        </label>
                        <label style="display: inline-block; cursor: pointer;">
                            <input type="radio" name="subtitle-target" value="commentary_korean">
                            ì¬í•´ì„ìë§‰ (í•œêµ­ì–´)
                        </label>
                    </div>
                    <button type="button" id="upload-subtitle-file-btn" class="btn-primary" style="width: 100%;">
                        ğŸ“‹ ìë§‰ íŒŒì¼ ì—…ë¡œë“œí•˜ì—¬ ì¶”ê°€
                    </button>
                    <input type="file" id="upload-subtitle-file-input" accept=".srt,.vtt" style="display: none;">
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666;">
                        .srt ë˜ëŠ” .vtt ìë§‰ íŒŒì¼ì„ ì„ íƒí•˜ì—¬ í”„ë¡œì íŠ¸ì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                    </p>
                </div>
            `;

            if (!savedResultOptions.length) {
                sourceSelectorList.innerHTML = headerHtml + '<p class="empty-state">ì €ì¥ëœ ì¬í•´ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';

                // ìë§‰ ì—…ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                attachSubtitleUploadListener();
                return;
            }

            const html = savedResultOptions.map(item => {
                const name = item.name || 'ì´ë¦„ ì—†ëŠ” ì €ì¥';
                const savedAt = item.saved_at ? new Date(item.saved_at).toLocaleString('ko-KR') : 'ì‹œê°„ ì •ë³´ ì—†ìŒ';
                return `
                    <label class="source-option">
                        <input type="radio" name="saved-result-selection" value="${item.id}">
                        <div class="source-option-body">
                            <div class="option-title">${escapeHtml(name)}</div>
                            <div class="option-meta">
                                <span>ğŸ—‚ ID: ${escapeHtml(item.id)}</span>
                                <span>ğŸ•’ ${escapeHtml(savedAt)}</span>
                            </div>
                        </div>
                    </label>
                `;
            }).join('');

            sourceSelectorList.innerHTML = headerHtml + html;

            // ìë§‰ ì—…ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            attachSubtitleUploadListener();

            sourceSelectorList.querySelectorAll('input[name="saved-result-selection"]').forEach(input => {
                input.addEventListener('change', async (event) => {
                    selectedSavedResultId = event.target.value;
                    selectedSourceIndex = null;
                    updateSourceApplyState();

                    if (selectedSavedResultId && !savedResultDetailCache[selectedSavedResultId]) {
                        try {
                            sourceSelectorApplyBtn.disabled = true;
                            const res = await fetch(`/api/translator/saved-results/${encodeURIComponent(selectedSavedResultId)}`);
                            if (!res.ok) {
                                throw new Error(`HTTP ${res.status}`);
                            }
                            const detail = await res.json();
                            savedResultDetailCache[selectedSavedResultId] = detail?.result;
                        } catch (error) {
                            console.error('Failed to fetch saved result detail:', error);
                            alert('ì¬í•´ì„ ì €ì¥ë³¸ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
                            selectedSavedResultId = null;
                        }
                    }
                    updateSourceApplyState();
                });
            });
            updateSourceApplyState();
        }

        function buildSelectionControls() {
            const container = document.createElement('div');
            container.className = 'selection-toolbar';
            container.innerHTML = `
                <div class="selection-summary">ì„ íƒ: <span id="selected-count">0</span>ê°œ</div>
                <div class="selection-buttons">
                    <button type="button" class="btn-secondary btn-sm" id="select-all-btn">ì „ì²´ ì²´í¬</button>
                    <button type="button" class="btn-secondary btn-sm" id="clear-selection-btn">ì „ì²´ í•´ì œ</button>
                    <button type="button" class="btn-secondary btn-sm" id="toggle-selection-btn">ì²´í¬ ë°˜ì „</button>
                    <button type="button" class="btn-secondary btn-sm" id="select-speaker1-btn">í™”ì1</button>
                    <button type="button" class="btn-secondary btn-sm" id="select-speaker2-btn">í™”ì2</button>
                    <button type="button" class="btn-secondary btn-sm" id="select-speaker3-btn">í™”ì3</button>
                </div>
                <div class="bulk-actions">
                    <label for="bulk-target-lang">ë²ˆì—­ ëŒ€ìƒ:</label>
                    <select id="bulk-target-lang" class="form-control form-control-sm">
                        <option value="ja">ì¼ë³¸ì–´</option>
                        <option value="ko">í•œêµ­ì–´</option>
                        <option value="en">ì˜ì–´</option>
                    </select>
                    <button type="button" class="btn-primary btn-sm" id="bulk-translate-btn">ì„ íƒ ìë§‰ ë²ˆì—­</button>
                    <button type="button" class="btn-secondary btn-sm" id="bulk-reverse-btn">ì„ íƒ ì—­ë²ˆì—­ (í•œêµ­ì–´)</button>
                    <button type="button" class="btn-success btn-sm" id="save-selected-btn">ì²´í¬ìë§‰ ë‹¤ë¥¸ì´ë¦„ ì €ì¥</button>
                    <button type="button" class="btn-danger btn-sm" id="delete-unselected-btn">ë¯¸ì„ íƒ í™”ì ì „ì²´ ì‚­ì œ</button>
                </div>
                <div class="audio-actions" style="margin-top: 10px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                    <label for="voice-select" style="margin: 0; font-weight: bold; color: #000000;">ìŒì„±:</label>
                    <select id="voice-select" class="form-control form-control-sm" style="width: auto; min-width: 90px; color: #000000;">
                        <option value="nova">nova</option>
                        <option value="alloy">alloy</option>
                        <option value="echo">echo</option>
                        <option value="fable">fable</option>
                        <option value="onyx">onyx</option>
                        <option value="shimmer">shimmer</option>
                    </select>
                    <label for="audio-format-select" style="margin: 0; font-weight: bold; color: #000000;">í¬ë§·:</label>
                    <select id="audio-format-select" class="form-control form-control-sm" style="width: auto; min-width: 75px; color: #000000;">
                        <option value="wav" selected>WAV</option>
                        <option value="mp3">MP3</option>
                    </select>
                    <button type="button" class="btn-primary btn-sm" id="generate-selected-audio-btn">ğŸ”Š ì„ íƒ ìë§‰ ìŒì„± ìƒì„±</button>
                    <button type="button" class="btn-success btn-sm" id="save-selected-audio-btn">ğŸ’¾ ì„ íƒ ìŒì„± ì €ì¥</button>
                    <button type="button" class="btn-primary btn-sm" id="generate-all-audio-btn">ğŸ”Š ì „ì²´ ìŒì„± ìƒì„±</button>
                    <button type="button" class="btn-info btn-sm" id="load-generated-tracks-btn">ğŸ“¥ ìƒì„±í•œ ê²ƒ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                    <button type="button" class="btn-sm" id="play-all-audio-btn" style="background-color: #e0e0e0; color: #000; border: 1px solid #ccc;">â–¶ï¸ ì „ì²´ ë“£ê¸°</button>
                    <button type="button" class="btn-danger btn-sm" id="stop-all-audio-btn" title="ì „ì²´ ìŒì„± ë©ˆì¶”ê¸°" disabled>â¹ï¸ ë©ˆì¶”ê¸°</button>
                    <button type="button" class="btn-success btn-sm" id="save-all-audio-btn">ğŸ’¾ ì „ì²´ ìŒì„± ì €ì¥</button>
                </div>
                <div id="audio-progress" style="display: none; margin-top: 12px; padding: 12px; background: #1a2332; border-radius: 8px; border: 1px solid #2a3f5f;">
                    <div style="margin-bottom: 8px; color: #f0f4f8;" id="audio-progress-message">ì§„í–‰ ì¤‘...</div>
                    <div style="background: #0d1520; height: 24px; border-radius: 12px; overflow: hidden; position: relative;">
                        <div id="audio-progress-bar" style="background: linear-gradient(90deg, #4bd4ff, #0084ff); height: 100%; width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center;">
                            <span id="audio-progress-percent" style="color: #fff; font-weight: bold; font-size: 12px;"></span>
                        </div>
                    </div>
                </div>
                <div class="comparison-timeline-panel" id="comparison-timeline-panel">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h3 class="timeline-title">íƒ€ì„ íŠ¸ë™ ë¹„êµ</h3>
                        <div style="display: flex; gap: 6px; flex-wrap: wrap; justify-content: flex-end;">
                            <button type="button" class="btn-xs" id="btn-save-tracks" title="í˜„ì¬ íŠ¸ë™ ìƒíƒœ ì €ì¥">ğŸ’¾ íŠ¸ë™ ì €ì¥</button>
                            <button type="button" class="btn-xs" id="btn-load-tracks" title="ì €ì¥ëœ íŠ¸ë™ ë¶ˆëŸ¬ì˜¤ê¸°">ğŸ“‚ íŠ¸ë™ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                            <button type="button" class="btn-xs" id="btn-load-bgm-v2" title="ë°°ê²½ìŒì•… V2 ë¶ˆëŸ¬ì˜¤ê¸°">ğŸµ ë°°ê²½ìŒì•… V2 ë¶ˆëŸ¬ì˜¤ê¸°</button>
                        </div>
                    </div>
                    <div id="timeline-status" class="timeline-status">ì›ë³¸ ë° ë²ˆì—­ ìŒì„±ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤...</div>

                    <!-- ì›ë³¸ ìŒì„± íŠ¸ë™ -->
                    <div class="timeline-track" id="timeline-track-original">
                        <div class="timeline-track-header">
                            <input type="checkbox" id="track-checkbox-original" class="track-checkbox" />
                            <span class="track-label">ğŸ¬ ì›ë³¸ ìŒì„±</span>
                            <span class="track-duration" id="timeline-original-duration"></span>
                            <button type="button" class="btn-xs" id="btn-separate-vocal" title="vocalê³¼ ë°°ê²½ìŒì•… ë¶„ë¦¬">ğŸµ ë¶„ë¦¬</button>
                            <button type="button" class="btn-xs" id="btn-extract-dialogue" title="ë³´ì»¬ íŠ¸ë™ìœ¼ë¡œ ëŒ€ì‚¬ë§Œ ì¶”ì¶œ">ğŸ—£ï¸ ëŒ€ì‚¬ì¶”ì¶œ</button>
                            <button type="button" class="btn-xs" id="btn-extract-dialogue-muted" title="ë²ˆì—­/í•´ì„¤ ìŒì„±ì´ ìˆëŠ” êµ¬ê°„ì„ ë¬´ìŒìœ¼ë¡œ ì œê±°">ğŸ—£ï¸ ë²ˆì—­ ì œì™¸</button>
                        </div>
                        <div id="timeline-original-waveform" class="waveform"></div>
                    </div>

                    <!-- ë°°ê²½ìŒì•… íŠ¸ë™ (vocal ë¶„ë¦¬ í›„) -->
                    <div class="timeline-track" id="timeline-track-bgm" style="display: none;">
                        <div class="timeline-track-header" style="gap: 8px; flex-wrap: wrap; align-items: center;">
                            <div style="display: inline-flex; align-items: center; gap: 6px;">
                                <input type="checkbox" id="track-checkbox-bgm" class="track-checkbox" />
                                <span class="track-label">ğŸµ ë°°ê²½ìŒì•…</span>
                                <span class="track-duration" id="timeline-bgm-duration"></span>
                            </div>
                            <div class="bgm-controls">
                                <label for="bgm-volume-range" class="bgm-volume-label">
                                    ì „ì²´ ë³¼ë¥¨
                                    <input type="range" id="bgm-volume-range" min="0" max="200" value="100" step="5">
                                    <span id="bgm-volume-value">100%</span>
                                </label>
                                <button type="button" class="btn-xs" id="btn-bgm-apply-volume" title="í˜„ì¬ ë³¼ë¥¨ìœ¼ë¡œ ë°°ê²½ìŒì•… ì ìš©" disabled>ğŸšï¸ ì ìš©</button>
                                <button type="button" class="btn-xs" id="btn-bgm-trim-mode" title="ë“œë˜ê·¸ë¡œ ìë¥¼ êµ¬ê°„ ì„ íƒ" disabled>âœ‚ï¸ ìë¥´ê¸°</button>
                                <button type="button" class="btn-xs" id="btn-bgm-trim-delete" title="ì„ íƒ êµ¬ê°„ ì‚­ì œ" disabled>ğŸ—‘ï¸ ë²„ë¦¬ê¸°</button>
                                <button type="button" class="btn-xs" id="btn-bgm-load" title="ë°°ê²½ìŒì•… ë¶ˆëŸ¬ì˜¤ê¸°" disabled>ğŸµ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                            </div>
                        </div>
                        <div id="timeline-bgm-waveform" class="waveform"></div>
                    </div>

                    <!-- ë°°ê²½ìŒì•… V2 ë¹„êµ íŠ¸ë™ -->
                    <div class="timeline-track" id="timeline-track-bgm-v2" style="display: none;">
                        <div class="timeline-track-header" style="gap: 8px; flex-wrap: wrap; align-items: center;">
                            <div style="display: inline-flex; align-items: center; gap: 6px;">
                                <input type="checkbox" id="track-checkbox-bgm-v2" class="track-checkbox" />
                                <span class="track-label">ğŸµ ë°°ê²½ìŒì•… V2</span>
                                <span class="track-duration" id="timeline-bgm-v2-duration"></span>
                            </div>
                            <div class="bgm-controls" style="gap: 12px; align-items: center; flex-wrap: wrap;">
                                <label for="bgm-v2-volume-range" class="bgm-volume-label">
                                    V2 ë³¼ë¥¨
                                    <input type="range" id="bgm-v2-volume-range" min="0" max="200" value="100" step="5">
                                    <span id="bgm-v2-volume-value">100%</span>
                                </label>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-apply-volume" title="í˜„ì¬ ë³¼ë¥¨ìœ¼ë¡œ ë°°ê²½ìŒì•… V2 ì ìš©" disabled>ğŸšï¸ ì ìš©</button>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-trim-mode" title="ë“œë˜ê·¸ë¡œ ìë¥¼ êµ¬ê°„ ì„ íƒ" disabled>âœ‚ï¸ ìë¥´ê¸°</button>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-trim-delete" title="ì„ íƒ ì´í›„ êµ¬ê°„ ì‚­ì œ" disabled>ğŸ—‘ï¸ ë²„ë¦¬ê¸°</button>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-save-copy" title="í˜„ì¬ ë°°ê²½ìŒì•… V2ë¥¼ ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥" disabled>ğŸ’¾ ë‹¤ë¥¸ì´ë¦„</button>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-duck-toggle" title="ì›ë³¸/ë²ˆì—­ ìŒì„±ì´ ì¬ìƒë  ë•Œ ìë™ìœ¼ë¡œ ê°ì‡ " disabled>ğŸ§ ìë™ê°ì‡  OFF</button>
                                <span class="bgm-volume-label" id="bgm-v2-volume-label">
                                    í‘œì‹œ <span id="bgm-v2-volume-percent">--</span> (<span id="bgm-v2-playback-time">0.00ì´ˆ</span>)
                                </span>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-jump-end" title="ê¸°ì¤€ ê¸¸ì´ ìœ„ì¹˜ë¡œ ì´ë™" disabled>â© ê¸°ì¤€</button>
                                <button type="button" class="btn-xs" id="btn-bgm-v2-clear" title="ë°°ê²½ìŒì•… V2 ì œê±°" disabled>âŒ ì œê±°</button>
                            </div>
                        </div>
                        <div id="timeline-bgm-v2-waveform" class="waveform"></div>
                    </div>

                    <!-- ì›ë³¸ ëŒ€ì‚¬ë¶„ë¦¬ ìŒì„± íŠ¸ë™ (ëŒ€ì‚¬ì¶”ì¶œ í›„) -->
                    <div class="timeline-track" id="timeline-track-dialogue" style="display: none;">
                        <div class="timeline-track-header">
                            <input type="checkbox" id="track-checkbox-dialogue" class="track-checkbox" />
                            <span class="track-label">ğŸ—£ï¸ ì›ë³¸ ëŒ€ì‚¬ (ë³´ì»¬)</span>
                            <span class="track-duration" id="timeline-dialogue-duration"></span>
                        </div>
                        <div id="timeline-dialogue-waveform" class="waveform"></div>
                    </div>

                    <!-- ë²ˆì—­ ì œì™¸ ëŒ€ì‚¬ íŠ¸ë™ -->
                    <div class="timeline-track" id="timeline-track-dialogue-muted" style="display: none;">
                        <div class="timeline-track-header">
                            <input type="checkbox" id="track-checkbox-dialogue-muted" class="track-checkbox" />
                            <span class="track-label">ğŸ—£ï¸ ì›ë³¸ ëŒ€ì‚¬ (ë²ˆì—­ ì œì™¸)</span>
                            <span class="track-duration" id="timeline-dialogue-muted-duration"></span>
                        </div>
                        <div id="timeline-dialogue-muted-waveform" class="waveform"></div>
                    </div>

                    <!-- ë²ˆì—­ ìŒì„± íŠ¸ë™ -->
                    <div class="timeline-track" id="timeline-track-translated">
                        <div class="timeline-track-header">
                            <input type="checkbox" id="track-checkbox-translated" class="track-checkbox" />
                            <span class="track-label">ğŸ—£ï¸ ë²ˆì—­ ìŒì„±</span>
                            <span class="track-duration" id="timeline-translated-duration"></span>
                            <button type="button" class="btn-xs" id="btn-translated-mute" title="ë²ˆì—­ ìŒì„± íŠ¸ë™ì„ ë¬´ìŒ ì²˜ë¦¬í•˜ê±°ë‚˜ ë³µì›">ğŸ”‡ ë²ˆì—­êµ¬ê°„ ë¬´ìŒ</button>
                            <button type="button" class="btn-xs" id="btn-translated-trim" title="ë²ˆì—­ ìŒì„±ì´ ì›ë³¸ë³´ë‹¤ ê¸¸ë©´ ì˜ë¼ëƒ…ë‹ˆë‹¤">âœ‚ï¸ ì›ë³¸ìŒì„±ë³´ë‹¤ ê¸´ ê²ƒ ìë¥´ê¸°</button>
                        </div>
                        <div id="timeline-translated-waveform" class="waveform"></div>
                    </div>

                    <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
                    <div class="timeline-control-row">
                        <button type="button" class="btn-sm" id="timeline-play-original-btn">â–¶ï¸ ì›ë³¸ ì¬ìƒ</button>
                        <button type="button" class="btn-sm" id="timeline-play-translated-btn">â–¶ï¸ ë²ˆì—­ ì¬ìƒ</button>
                        <button type="button" class="btn-success btn-sm" id="timeline-play-both-btn">â–¶ï¸ ë™ì‹œì¬ìƒ</button>
                        <button type="button" class="btn-success btn-sm" id="timeline-play-checked-btn">âœ… ì²´í¬ë§Œ ì¬ìƒ</button>
                        <button type="button" class="btn-danger btn-sm" id="timeline-delete-checked-btn">ğŸ—‘ï¸ ì²´í¬ íŠ¸ë™ ì‚­ì œ</button>
                        <button type="button" class="btn-sm" id="timeline-pause-btn">â¸ï¸ ì¼ì‹œì •ì§€</button>
                        <button type="button" class="btn-danger btn-sm" id="timeline-stop-btn">â¹ï¸ ë©ˆì¶”ê¸°</button>
                        <button type="button" class="btn-primary btn-sm" id="timeline-merge-checked-btn">ğŸ”€ ì²´í¬í•œ íŠ¸ë™ í•©ì¹˜ê¸°</button>
                    </div>
                </div>
            `;

            selectionCountElem = container.querySelector('#selected-count');
            bulkTargetLangSelect = container.querySelector('#bulk-target-lang');
            bulkTranslateBtn = container.querySelector('#bulk-translate-btn');
            bulkReverseBtn = container.querySelector('#bulk-reverse-btn');
            voiceSelectElem = container.querySelector('#voice-select');
            audioFormatSelectElem = container.querySelector('#audio-format-select');
            stopAllAudioBtn = container.querySelector('#stop-all-audio-btn');

            if (voiceSelectElem) {
                try {
                    const savedVoice = localStorage.getItem('translatorVoiceChoice');
                    if (savedVoice && Array.from(voiceSelectElem.options).some(opt => opt.value === savedVoice)) {
                        voiceSelectElem.value = savedVoice;
                    }
                } catch (error) {
                    console.warn('ìŒì„± ì„ íƒ ì €ì¥ì„ ìœ„í•œ localStorage ì ‘ê·¼ ì‹¤íŒ¨:', error);
                }
                voiceSelectElem.addEventListener('change', () => {
                    try {
                        localStorage.setItem('translatorVoiceChoice', voiceSelectElem.value);
                    } catch (error) {
                        console.warn('ìŒì„± ì„ íƒ ì €ì¥ ì‹¤íŒ¨:', error);
                    }
                });
            }

            if (audioFormatSelectElem) {
                try {
                    const savedFormat = localStorage.getItem('translatorAudioFormat');
                    if (savedFormat && Array.from(audioFormatSelectElem.options).some(opt => opt.value === savedFormat)) {
                        audioFormatSelectElem.value = savedFormat;
                    }
                } catch (error) {
                    console.warn('ì˜¤ë””ì˜¤ í¬ë§· ì„ íƒ ì €ì¥ì„ ìœ„í•œ localStorage ì ‘ê·¼ ì‹¤íŒ¨:', error);
                }
                audioFormatSelectElem.addEventListener('change', () => {
                    try {
                        localStorage.setItem('translatorAudioFormat', audioFormatSelectElem.value);
                    } catch (error) {
                        console.warn('ì˜¤ë””ì˜¤ í¬ë§· ì„ íƒ ì €ì¥ ì‹¤íŒ¨:', error);
                    }
                });
            }

            const selectAllBtn = container.querySelector('#select-all-btn');
            const clearSelectionBtn = container.querySelector('#clear-selection-btn');
            const toggleSelectionBtn = container.querySelector('#toggle-selection-btn');
            const selectSpeaker1Btn = container.querySelector('#select-speaker1-btn');
            const selectSpeaker2Btn = container.querySelector('#select-speaker2-btn');
            const selectSpeaker3Btn = container.querySelector('#select-speaker3-btn');

            selectAllBtn.addEventListener('click', selectAllSegments);
            clearSelectionBtn.addEventListener('click', clearSelectedSegments);
            toggleSelectionBtn.addEventListener('click', toggleAllSegments);
            selectSpeaker1Btn.addEventListener('click', () => selectSegmentsBySpeakers(['í™”ì1']));
            selectSpeaker2Btn.addEventListener('click', () => selectSegmentsBySpeakers(['í™”ì2']));
            selectSpeaker3Btn.addEventListener('click', () => selectSegmentsBySpeakers(['í™”ì3']));

            const saveSelectedBtn = container.querySelector('#save-selected-btn');
            const deleteUnselectedBtn = container.querySelector('#delete-unselected-btn');
            const generateSelectedAudioBtn = container.querySelector('#generate-selected-audio-btn');
            const saveSelectedAudioBtn = container.querySelector('#save-selected-audio-btn');
            const generateAllAudioBtn = container.querySelector('#generate-all-audio-btn');
            const loadGeneratedTracksBtn = container.querySelector('#load-generated-tracks-btn');
            const inlineBgmBtn = container.querySelector('#btn-bgm-load');
            const loadBgmV2Btn = container.querySelector('#btn-load-bgm-v2');
            const clearBgmV2Btn = container.querySelector('#btn-bgm-v2-clear');
            const playAllAudioBtn = container.querySelector('#play-all-audio-btn');
            const saveAllAudioBtn = container.querySelector('#save-all-audio-btn');

            if (bulkTranslateBtn) {
                bulkTranslateBtn.addEventListener('click', bulkTranslateSelectedSegments);
            }
            if (bulkReverseBtn) {
                bulkReverseBtn.addEventListener('click', bulkReverseSelectedSegments);
            }
            if (saveSelectedBtn) {
                saveSelectedBtn.addEventListener('click', saveSelectedSegmentsAs);
            }
            if (deleteUnselectedBtn) {
                deleteUnselectedBtn.addEventListener('click', deleteUnselectedSegments);
            }
            if (generateSelectedAudioBtn) {
                generateSelectedAudioBtn.addEventListener('click', generateSelectedAudio);
            }
            if (saveSelectedAudioBtn) {
                saveSelectedAudioBtn.addEventListener('click', saveSelectedAudioAs);
            }
            if (generateAllAudioBtn) {
                generateAllAudioBtn.addEventListener('click', generateAllAudio);
            }
            if (loadGeneratedTracksBtn) {
                loadGeneratedTracksBtn.addEventListener('click', loadGeneratedTracks);
            }
            if (inlineBgmBtn && !inlineBgmBtn.dataset.boundLoad) {
                inlineBgmBtn.addEventListener('click', () => loadBgmFromCandidates({ target: 'bgm' }));
                inlineBgmBtn.dataset.boundLoad = '1';
            }
            if (loadBgmV2Btn && !loadBgmV2Btn.dataset.boundLoad) {
                loadBgmV2Btn.addEventListener('click', () => loadBgmFromCandidates({ target: 'v2' }));
                loadBgmV2Btn.dataset.boundLoad = '1';
            }
            if (clearBgmV2Btn) {
                clearBgmV2Btn.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    if (!currentProject.extra) {
                        currentProject.extra = {};
                    }

                    if (!currentProject.extra.bgm_v2_path && !currentProject.extra.bgm_custom_v2_path) {
                        alert('ì œê±°í•  ë°°ê²½ìŒì•… V2ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }

                    const originalLabel = clearBgmV2Btn.textContent;
                    try {
                        clearBgmV2Btn.disabled = true;
                        clearBgmV2Btn.textContent = 'ì œê±° ì¤‘...';

                        const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/v2`, {
                            method: 'DELETE',
                        });

                        if (!response.ok) {
                            const text = await response.text();
                            throw new Error(text || `HTTP ${response.status}`);
                        }

                        delete currentProject.extra.bgm_v2_path;
                        delete currentProject.extra.bgm_custom_v2_path;
                        delete currentProject.extra.bgm_v2_volume_percent;
                        delete currentProject.extra.bgm_v2_cache_token;

                        setBgmV2Track('', { force: true });
                        await updateComparisonTimeline();

                        alert('ë°°ê²½ìŒì•… V2ë¥¼ ì œê±°í–ˆìŠµë‹ˆë‹¤.');
                    } catch (err) {
                        console.error('Failed to clear BGM V2:', err);
                        alert('ë°°ê²½ìŒì•… V2ë¥¼ ì œê±°í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    } finally {
                        const hasV2Track = Boolean(currentProject?.extra?.bgm_v2_path || currentProject?.extra?.bgm_custom_v2_path);
                        clearBgmV2Btn.disabled = !hasV2Track;
                        clearBgmV2Btn.textContent = originalLabel || 'âŒ ì œê±°';
                    }
                });
            }
            if (playAllAudioBtn) {
                playAllAudioBtn.addEventListener('click', playAllAudio);
            }
            if (stopAllAudioBtn) {
                stopAllAudioBtn.addEventListener('click', () => {
                    stopAllAudio({ clearHighlight: true });
                    stopSingleAudioPlayback({ clearHighlight: true });
                });
                stopAllAudioBtn.disabled = !allAudioPlayer;
            }
            if (saveAllAudioBtn) {
                saveAllAudioBtn.addEventListener('click', saveAllAudio);
            }

            return container;
        }

        function selectAllSegments() {
            if (!currentProject) {
                return;
            }
            currentProject.segments.forEach(seg => selectedSegmentIds.add(seg.id));
            updateSelectionUI();
        }

        function clearSelectedSegments() {
            selectedSegmentIds.clear();
            updateSelectionUI();
        }

        function toggleAllSegments() {
            if (!currentProject) {
                return;
            }
            // ê° ì„¸ê·¸ë¨¼íŠ¸ì˜ ì„ íƒ ìƒíƒœë¥¼ ë°˜ì „
            currentProject.segments.forEach(seg => {
                if (selectedSegmentIds.has(seg.id)) {
                    selectedSegmentIds.delete(seg.id);
                } else {
                    selectedSegmentIds.add(seg.id);
                }
            });
            updateSelectionUI();
        }

        function selectSegmentsBySpeakers(speakers, { replace = true } = {}) {
            if (!currentProject) {
                return;
            }
            const normalized = speakers.map(s => s.trim()).filter(Boolean);
            if (!normalized.length) {
                return;
            }
            if (replace) {
                selectedSegmentIds.clear();
            }
            currentProject.segments.forEach(seg => {
                if (seg.speaker_name && normalized.includes(seg.speaker_name)) {
                    selectedSegmentIds.add(seg.id);
                }
            });
            updateSelectionUI();
        }

        function getSelectedSegmentIds() {
            if (selectedSegmentIds.size) {
                return Array.from(selectedSegmentIds);
            }
            if (!currentProject) {
                return [];
            }
            return currentProject.segments.map(seg => seg.id);
        }

        function bulkTranslateSelectedSegments() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const segmentIds = selectedSegmentIds.size
                ? Array.from(selectedSegmentIds)
                : [];

            if (!segmentIds.length && !confirm('ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì „ì²´ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë²ˆì—­í• ê¹Œìš”?')) {
                return;
            }

            const targetLang = bulkTargetLangSelect?.value || document.getElementById('target-lang')?.value || currentProject.target_lang || 'ja';
            const translationMode = document.getElementById('translation-mode')?.value || currentProject.translation_mode || 'reinterpret';
            const toneHintValue = document.getElementById('tone-hint')?.value || currentProject.tone_hint || null;

            if (bulkTranslateBtn) {
                const originalText = bulkTranslateBtn.textContent;
                bulkTranslateBtn.disabled = true;
                bulkTranslateBtn.textContent = 'ë²ˆì—­ ì¤‘... 0%';
                bulkTranslateBtn.dataset.originalText = originalText;
            }

            // ì§„í–‰ë¥  í´ë§ ì‹œì‘
            let progressInterval = setInterval(() => {
                fetch(`/api/translator/projects/${currentProject.id}`)
                    .then(res => res.json())
                    .then(project => {
                        const progress = project.extra?.translation_progress;
                        if (progress && bulkTranslateBtn) {
                            bulkTranslateBtn.textContent = `ë²ˆì—­ ì¤‘... ${progress.percentage}% (${progress.completed}/${progress.total})`;
                        }
                    })
                    .catch(err => {
                        console.error('Failed to fetch progress:', err);
                    });
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì§„í–‰ë¥  í™•ì¸

            fetch(`/api/translator/projects/${currentProject.id}/translate-segments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    segment_ids: segmentIds,
                    target_lang: targetLang,
                    translation_mode: translationMode,
                    tone_hint: toneHintValue,
                })
            })
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    clearInterval(progressInterval);
                    renderProject(project);
                })
                .catch(err => {
                    clearInterval(progressInterval);
                    console.error('Failed to translate segments:', err);
                    alert('ì„ íƒëœ ìë§‰ì„ ë²ˆì—­í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                })
                .finally(() => {
                    clearInterval(progressInterval);
                    if (bulkTranslateBtn) {
                        bulkTranslateBtn.disabled = false;
                        bulkTranslateBtn.textContent = bulkTranslateBtn.dataset.originalText || 'ì„ íƒ ìë§‰ ë²ˆì—­';
                    }
                });
        }

        function bulkReverseSelectedSegments() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const segmentIds = selectedSegmentIds.size
                ? Array.from(selectedSegmentIds)
                : [];

            if (!segmentIds.length && !confirm('ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì „ì²´ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì—­ë²ˆì—­í• ê¹Œìš”?')) {
                return;
            }

            if (bulkReverseBtn) {
                const originalText = bulkReverseBtn.textContent;
                bulkReverseBtn.disabled = true;
                bulkReverseBtn.textContent = 'ì—­ë²ˆì—­ ì¤‘... 0%';
                bulkReverseBtn.dataset.originalText = originalText;
            }

            // ì§„í–‰ë¥  í´ë§ ì‹œì‘
            let progressInterval = setInterval(() => {
                fetch(`/api/translator/projects/${currentProject.id}`)
                    .then(res => res.json())
                    .then(project => {
                        const progress = project.extra?.translation_progress;
                        if (progress && bulkReverseBtn) {
                            bulkReverseBtn.textContent = `ì—­ë²ˆì—­ ì¤‘... ${progress.percentage}% (${progress.completed}/${progress.total})`;
                        }
                    })
                    .catch(err => {
                        console.error('Failed to fetch progress:', err);
                    });
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì§„í–‰ë¥  í™•ì¸

            fetch(`/api/translator/projects/${currentProject.id}/reverse-translate-segments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    segment_ids: segmentIds,
                })
            })
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    clearInterval(progressInterval);
                    renderProject(project);
                })
                .catch(err => {
                    clearInterval(progressInterval);
                    console.error('Failed to reverse translate segments:', err);
                    alert('ì„ íƒëœ ìë§‰ì„ ì—­ë²ˆì—­í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                })
                .finally(() => {
                    clearInterval(progressInterval);
                    if (bulkReverseBtn) {
                        bulkReverseBtn.disabled = false;
                        bulkReverseBtn.textContent = bulkReverseBtn.dataset.originalText || 'ì„ íƒ ì—­ë²ˆì—­ (í•œêµ­ì–´)';
                    }
                });
        }

        // ì§„í–‰ë¥  í‘œì‹œ UI ìš”ì†Œ
        let progressIntervalId = null;

        function showProgressBar() {
            const progressDiv = document.getElementById('audio-progress');
            if (progressDiv) {
                progressDiv.style.display = 'block';
            }
        }

        function hideProgressBar() {
            const progressDiv = document.getElementById('audio-progress');
            if (progressDiv) {
                progressDiv.style.display = 'none';
            }
            if (progressIntervalId) {
                clearInterval(progressIntervalId);
                progressIntervalId = null;
            }
        }

        function updateProgressUI(progress) {
            const messageElem = document.getElementById('audio-progress-message');
            const barElem = document.getElementById('audio-progress-bar');
            const percentElem = document.getElementById('audio-progress-percent');

            if (!messageElem || !barElem || !percentElem) return;

            const percentage = progress.total > 0 ? Math.round((progress.current / progress.total) * 100) : 0;
            messageElem.textContent = progress.message;
            barElem.style.width = percentage + '%';
            percentElem.textContent = percentage + '%';
        }

        async function pollProgress(taskId) {
            try {
                const response = await fetch(`/api/translator/audio-progress/${taskId}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        // Task not found, might be completed or not started yet
                        return null;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                return await response.json();
            } catch (err) {
                console.error('Failed to poll progress:', err);
                return null;
            }
        }

        async function startProgressPolling(taskId) {
            showProgressBar();

            return new Promise((resolve, reject) => {
                progressIntervalId = setInterval(async () => {
                    const progress = await pollProgress(taskId);

                    if (!progress) {
                        // Progress not found yet, keep polling
                        return;
                    }

                    updateProgressUI(progress);

                if (progress.status === 'completed') {
                    hideProgressBar();
                    resolve(progress);
                } else if (progress.status === 'error') {
                    hideProgressBar();
                    const errorMessage = progress.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                    reject(new Error(errorMessage));
                }
            }, 500); // 0.5ì´ˆë§ˆë‹¤ í´ë§
        });
    }

        async function generateSelectedAudio() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const segmentIds = selectedSegmentIds.size
                ? Array.from(selectedSegmentIds)
                : [];

            if (!segmentIds.length) {
                alert('ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const segmentsToGenerate = currentProject.segments.filter(seg =>
                segmentIds.includes(seg.id) && typeof seg.translated_text === 'string' && seg.translated_text.trim().length > 0
            );

            const skippedCount = segmentIds.length - segmentsToGenerate.length;
            if (segmentsToGenerate.length === 0) {
                alert('ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ì— ë²ˆì—­ëœ ìë§‰ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € "ì„ íƒ ìë§‰ ë²ˆì—­"ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.');
                return;
            }

            const voice = getSelectedVoice();
            const audioFormat = getSelectedAudioFormat();

            if (!confirm(`ì„ íƒëœ ${segmentIds.length}ê°œ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ${voice} / ${audioFormat.toUpperCase()}ë¡œ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ìë§‰ ì‹œê°„ì— ë§ì¶° ë¬´ìŒì´ í¬í•¨ë©ë‹ˆë‹¤)`)) {
                return;
            }

            const taskId = `${currentProject.id}_selected_${segmentIds.length}`;

            try {
                // ë¹„ë™ê¸°ë¡œ ìŒì„± ìƒì„± ì‹œì‘
                const fetchPromise = fetch(`/api/translator/projects/${currentProject.id}/generate-selected-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        segment_ids: segmentsToGenerate.map(seg => seg.id),
                        voice: voice,
                        audio_format: audioFormat,
                        task_id: taskId
                    })
                });

                // ì§„í–‰ë¥  í´ë§ ì‹œì‘
                const progressPromise = startProgressPolling(taskId);

                // ë‘˜ ë‹¤ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
                const [response] = await Promise.all([fetchPromise, progressPromise]);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();

                // í”„ë¡œì íŠ¸ë¥¼ ë‹¤ì‹œ ë¡œë“œí•˜ì—¬ ì—…ë°ì´íŠ¸ëœ audio_pathë¥¼ UIì— ë°˜ì˜
                const projectResponse = await fetch(`/api/translator/projects/${currentProject.id}`);
                if (projectResponse.ok) {
                    const updatedProject = await projectResponse.json();
                    if (skippedCount > 0) {
                        // ë²ˆì—­ ì—†ìŒìœ¼ë¡œ ê±´ë„ˆë›´ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ íƒ ì§‘í•©ì—ì„œ ì œê±°
                        const validIds = new Set(segmentsToGenerate.map(seg => seg.id));
                        selectedSegmentIds.clear();
                        segmentsToGenerate.forEach(seg => selectedSegmentIds.add(seg.id));
                        updateSelectionUI();
                    }
                    currentProject = updatedProject;
                    renderProject(updatedProject);
                }

                // ìƒì„±ëœ ì˜¤ë””ì˜¤ íŒŒì¼ì„ íƒ€ì„ë¼ì¸ì— ìë™ ë¡œë“œ
                if (result.audio_path) {
                    console.log('Auto-loading generated audio to timeline:', result.audio_path);
                    await loadTrackToTimeline(result.audio_path);
                }

                let summaryMessage = `ì„ íƒëœ ìë§‰ ìŒì„± ìƒì„± ì™„ë£Œ!\níŒŒì¼ ê²½ë¡œ: ${result.audio_path}\n\níƒ€ì„ë¼ì¸ì— ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.`;
                if (skippedCount > 0) {
                    summaryMessage += `\n\nì°¸ê³ : ì„ íƒëœ ${segmentIds.length}ê°œ ì¤‘ ë²ˆì—­ì´ ì—†ëŠ” ${skippedCount}ê°œ ì„¸ê·¸ë¨¼íŠ¸ëŠ” ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤.`;
                }
                alert(summaryMessage);
            } catch (err) {
                hideProgressBar();
                console.error('Failed to generate selected audio:', err);
                alert('ì„ íƒëœ ìë§‰ ìŒì„± ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
            }
        }

        async function generateAllAudio() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const voice = getSelectedVoice();
            const audioFormat = getSelectedAudioFormat();

            if (!confirm(`ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ${voice} / ${audioFormat.toUpperCase()}ë¡œ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                return;
            }

            const taskId = `${currentProject.id}_all_${currentProject.segments.length}`;

            try {
                // ë¹„ë™ê¸°ë¡œ ìŒì„± ìƒì„± ì‹œì‘
                const fetchPromise = fetch(`/api/translator/projects/${currentProject.id}/generate-all-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        voice: voice,
                        audio_format: audioFormat,
                        task_id: taskId
                    })
                });

                // ì§„í–‰ë¥  í´ë§ ì‹œì‘
                const progressPromise = startProgressPolling(taskId);

                // ë‘˜ ë‹¤ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
                const [response] = await Promise.all([fetchPromise, progressPromise]);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const project = await response.json();
                currentProject = project;
                renderProject(project);

                // ìƒì„±ëœ ì˜¤ë””ì˜¤ë¥¼ íƒ€ì„ë¼ì¸ì— ìë™ ë¡œë“œ
                // ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ê°€ ê°™ì€ audio_pathë¥¼ ê°€ì§€ë¯€ë¡œ ì²« ë²ˆì§¸ ì„¸ê·¸ë¨¼íŠ¸ì˜ path ì‚¬ìš©
                if (project.segments && project.segments.length > 0 && project.segments[0].audio_path) {
                    const audioPath = project.segments[0].audio_path;
                    console.log('Auto-loading generated audio to timeline:', audioPath);
                    await loadTrackToTimeline(audioPath);
                }

                alert('ì „ì²´ ìŒì„± ìƒì„± ì™„ë£Œ!\n\níƒ€ì„ë¼ì¸ì— ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
            } catch (err) {
                hideProgressBar();
                console.error('Failed to generate all audio:', err);
                alert('ì „ì²´ ìŒì„± ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
            }
        }

        async function loadGeneratedTracks() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/load-generated-tracks`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                const tracks = data.tracks || [];

                if (tracks.length === 0) {
                    alert('ìƒì„±ëœ ìŒì„± íŠ¸ë™ì´ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                // ê°€ì¥ ìµœê·¼ íŠ¸ë™ ì„ íƒ (created_at ê¸°ì¤€)
                tracks.sort((a, b) => b.created_at - a.created_at);

                // íŠ¸ë™ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
                const selectedTrack = await showTrackSelectionDialog(tracks);

                if (!selectedTrack) {
                    return; // ì‚¬ìš©ìê°€ ì·¨ì†Œí•¨
                }

                // íƒ€ì„ë¼ì¸ì— íŠ¸ë™ ë¶ˆëŸ¬ì˜¤ê¸°
                await loadTrackToTimeline(selectedTrack.path);

                // íƒ€ì„ë¼ì¸ ê°•ì œ ìƒˆë¡œê³ ì¹¨
                console.log('Force refreshing timeline after track load...');
                setTimeout(async () => {
                    await updateComparisonTimeline();
                }, 500);

                alert('ìŒì„± íŠ¸ë™ì„ íƒ€ì„ë¼ì¸ì— ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!');

            } catch (err) {
                console.error('Failed to load generated tracks:', err);
                alert('ìŒì„± íŠ¸ë™ ë¶ˆëŸ¬ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
            }
        }

        async function loadBgmFromCandidates(options = {}) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const target = options.target === 'bgm' ? 'bgm' : 'v2';
            const loadBtnId = target === 'v2' ? 'btn-load-bgm-v2' : 'btn-bgm-load';
            const defaultLabel = target === 'v2' ? 'ğŸµ ë°°ê²½ìŒì•… V2 ë¶ˆëŸ¬ì˜¤ê¸°' : 'ğŸµ ë°°ê²½ìŒì•… ë¶ˆëŸ¬ì˜¤ê¸°';
            const loadBtn = document.getElementById(loadBtnId);
            const originalLabel = loadBtn ? loadBtn.textContent : '';

            try {
                if (loadBtn) {
                    loadBtn.disabled = true;
                    loadBtn.textContent = 'ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
                }

                const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/candidates`);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const candidates = Array.isArray(data.candidates) ? data.candidates : [];
                if (candidates.length === 0) {
                    alert('ë¶ˆëŸ¬ì˜¬ ë°°ê²½ìŒì•… í›„ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¶„ë¦¬ ë˜ëŠ” ì»¤ìŠ¤í…€ ìŒì›ì„ ì¤€ë¹„í•˜ì„¸ìš”.');
                    return;
                }

                const findDefaultIndex = () => {
                    if (target === 'v2') {
                        const v2Index = candidates.findIndex((item) => String(item.kind || '').includes('custom_v2'));
                        if (v2Index >= 0) {
                            return v2Index;
                        }
                        const extraIndex = candidates.findIndex((item) => item.label && String(item.label).includes('V2'));
                        if (extraIndex >= 0) {
                            return extraIndex;
                        }
                    } else {
                        const currentIndex = candidates.findIndex((item) => item.kind === 'current' && !String(item.kind || '').includes('v2'));
                        if (currentIndex >= 0) {
                            return currentIndex;
                        }
                        const workingIndex = candidates.findIndex((item) => item.kind === 'working');
                        if (workingIndex >= 0) {
                            return workingIndex;
                        }
                    }
                    return 0;
                };

                let defaultIndex = findDefaultIndex();
                let selected = candidates[defaultIndex];
                if (candidates.length > 1) {
                    const dialogSelection = await showBgmSelectionDialog(candidates, defaultIndex);
                    if (!dialogSelection) {
                        return;
                    }
                    selected = dialogSelection;
                }

                const payloadCandidate = { ...selected };
                const originalKind = String(payloadCandidate.kind || '');

                if (target === 'v2') {
                    if (!originalKind.includes('v2')) {
                        payloadCandidate.kind = 'custom_v2';
                    }
                } else if (originalKind.includes('custom_v2')) {
                    payloadCandidate.kind = 'custom';
                }

                if (payloadCandidate.volume_percent === undefined && selected.volume_percent !== undefined) {
                    payloadCandidate.volume_percent = selected.volume_percent;
                }

                await applyBgmCandidate(payloadCandidate);
                alert(target === 'v2'
                    ? 'ë°°ê²½ìŒì•… V2ë¥¼ íƒ€ì„ë¼ì¸ì— ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.'
                    : 'ë°°ê²½ìŒì•…ì„ íƒ€ì„ë¼ì¸ì— ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
            } catch (err) {
                console.error('Failed to load BGM candidate:', err);
                alert((target === 'v2' ? 'ë°°ê²½ìŒì•… V2ë¥¼ ' : 'ë°°ê²½ìŒì•…ì„ ') + 'ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + err.message);
            } finally {
                if (loadBtn) {
                    loadBtn.disabled = false;
                    loadBtn.textContent = originalLabel || defaultLabel;
                }
            }
        }

        function showBgmSelectionDialog(candidates, defaultIndex = 0) {
            return new Promise((resolve) => {
                let currentAudio = null;

                const overlay = document.createElement('div');
                overlay.id = 'bgm-selection-dialog';
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.right = '0';
                overlay.style.bottom = '0';
                overlay.style.background = 'rgba(0, 0, 0, 0.72)';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.zIndex = '10000';

                overlay.innerHTML = `
                    <div class="bgm-dialog">
                        <div class="bgm-dialog-header">
                            <h3>ë°°ê²½ìŒì•… ì„ íƒ</h3>
                            <button type="button" class="btn-sm" id="bgm-dialog-close">ë‹«ê¸°</button>
                        </div>
                        <div class="bgm-dialog-toolbar">
                            <label for="bgm-dialog-folder">í´ë”</label>
                            <select id="bgm-dialog-folder" class="bgm-dialog-select"></select>
                            <input type="search" id="bgm-dialog-search" class="bgm-dialog-search" placeholder="íŒŒì¼ëª… ë˜ëŠ” ê²½ë¡œ ê²€ìƒ‰...">
                            <button type="button" class="btn-sm" id="bgm-dialog-browse">íŒŒì¼ ì°¾ê¸°</button>
                        </div>
                        <div id="bgm-candidate-list" class="bgm-candidate-list"></div>
                        <div class="bgm-dialog-footer">
                            <button type="button" class="btn-sm" id="bgm-dialog-cancel">ì·¨ì†Œ</button>
                            <button type="button" class="btn-primary btn-sm" id="bgm-dialog-confirm">í™•ì¸</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(overlay);

                const listElem = overlay.querySelector('#bgm-candidate-list');
                const folderSelect = overlay.querySelector('#bgm-dialog-folder');
                const searchInput = overlay.querySelector('#bgm-dialog-search');

                const normalizePath = (path) => {
                    if (!path) {
                        return '';
                    }
                    return String(path).replace(/\\/g, '/');
                };

                const normalizeForMatch = (value) => {
                    if (!value && value !== 0) {
                        return '';
                    }
                    try {
                        return decodeURIComponent(String(value))
                            .toLowerCase()
                            .replace(/\\/g, '/');
                    } catch (error) {
                        return String(value).toLowerCase().replace(/\\/g, '/');
                    }
                };

                const extractDirectory = (candidate) => {
                    if (!candidate || !candidate.path) {
                        return '';
                    }
                    const normalized = normalizePath(candidate.path);
                    const lastSlash = normalized.lastIndexOf('/');
                    if (lastSlash <= 0) {
                        return '';
                    }
                    return normalized.slice(0, lastSlash);
                };

                const isRemovableCandidate = (candidate) => {
                    if (!candidate || !candidate.path) {
                        return false;
                    }
                    const normalized = normalizePath(candidate.path).toLowerCase();
                    if (!normalized.includes('/translator_projects/')) {
                        return false;
                    }
                    return normalized.includes('/audio/') || normalized.includes('/separated/');
                };

                const updateFolderOptions = (currentValue = '') => {
                    if (!folderSelect) {
                        return;
                    }
                    const dirs = Array.from(
                        new Set(
                            candidates
                                .map(extractDirectory)
                                .filter(Boolean)
                        )
                    ).sort((a, b) => a.localeCompare(b));
                    folderSelect.innerHTML = [
                        '<option value="">ì „ì²´ í´ë”</option>',
                        ...dirs.map((dir) => `<option value="${dir}">${dir}</option>`)
                    ].join('');
                    if (currentValue && dirs.includes(currentValue)) {
                        folderSelect.value = currentValue;
                    }
                };

                updateFolderOptions();

                const stopPreview = () => {
                    if (currentAudio) {
                        try {
                            currentAudio.pause();
                        } catch (error) {
                            console.debug('Failed to pause preview audio:', error);
                        }
                        currentAudio = null;
                    }
                };

                const playPreview = (candidate) => {
                    stopPreview();
                    currentAudio = new Audio(candidate.path);
                    currentAudio.play().catch((error) => {
                        console.error('Failed to preview BGM:', error);
                        alert('ë¯¸ë¦¬ë“£ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
                    });
                    setTimeout(stopPreview, 15000);
                };

                let folderFilter = folderSelect ? folderSelect.value || '' : '';
                let filterText = '';
                let selectedIndex = defaultIndex;

                const renderList = () => {
                    if (!listElem) {
                        return;
                    }

                    const normalizedFilter = normalizeForMatch(filterText.trim());

                    const filtered = candidates
                        .map((candidate, index) => ({
                            candidate,
                            index,
                            directory: extractDirectory(candidate),
                        }))
                        .filter(({ candidate, directory }) => {
                            if (folderFilter && directory !== folderFilter) {
                                return false;
                            }
                            if (!normalizedFilter) {
                                return true;
                            }
                            const haystack = [
                                candidate.label,
                                candidate.filename,
                                directory,
                                candidate.path,
                            ]
                                .filter(Boolean)
                                .map(normalizeForMatch)
                                .join(' ');
                            return haystack.includes(normalizedFilter);
                        });

                    if (filtered.length === 0) {
                        listElem.innerHTML = '<div class="bgm-candidate-empty">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                        return;
                    }

                    if (!filtered.some((item) => item.index === selectedIndex)) {
                        selectedIndex = filtered[0].index;
                    }

                    listElem.innerHTML = filtered.map(({ candidate, index, directory }) => {
                        const modifiedLabel = candidate.modified_at
                            ? new Date(candidate.modified_at * 1000).toLocaleString('ko-KR')
                            : 'ì•Œ ìˆ˜ ì—†ìŒ';
                        const isSelected = index === selectedIndex;
                        const badge = candidate.kind && String(candidate.kind).includes('custom_v2')
                            ? '<span style="margin-left: 6px; color: #4bd4ff; font-size: 12px;">V2</span>'
                            : '';
                        const directoryHtml = directory
                            ? `<div class="bgm-dialog-path">í´ë”: ${escapeHtml(directory)}</div>`
                            : '<div class="bgm-dialog-path">í´ë”: -</div>';
                        const wrapperStyle = isSelected
                            ? 'border: 2px solid #4bd4ff; background: rgba(75, 212, 255, 0.08);'
                            : 'border: 2px solid rgba(255, 255, 255, 0.1); background: rgba(13, 21, 32, 0.9);';
                        const removable = isRemovableCandidate(candidate);
                        const actionsHtml = `
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                <button type="button" class="btn-sm" data-bgm-preview="${index}" style="background: #4bd4ff; color: #04142e;">â–¶ï¸ ë¯¸ë¦¬ë“£ê¸°</button>
                                ${removable ? `<button type="button" class="btn-sm" data-bgm-remove="${index}" style="background: #ff6b6b; color: #04142e;">âŒ ì œê±°</button>` : ''}
                            </div>
                        `;
                        return `
                            <label style="
                                display: flex;
                                flex-direction: column;
                                gap: 6px;
                                padding: 12px;
                                border-radius: 10px;
                                ${wrapperStyle}
                                transition: border-color 0.2s ease;
                                cursor: pointer;
                            " data-bgm-index="${index}">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="radio" name="bgm-candidate" value="${index}" ${isSelected ? 'checked' : ''}>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="color: #f0f4f8; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                                            <span>${escapeHtml(candidate.label || candidate.filename || 'ë¬´ì œ')}</span>
                                            ${badge}
                                        </div>
                                        <div style="color: #9ca3af; font-size: 12px;">
                                            ${escapeHtml(candidate.filename || '')}
                                        </div>
                                        ${directoryHtml}
                                        <div style="color: #6b778d; font-size: 12px;">
                                            ìˆ˜ì • ì‹œê°: ${modifiedLabel}
                                        </div>
                                    </div>
                                    ${actionsHtml}
                                </div>
                            </label>
                        `;
                    }).join('');
                };

                renderList();

                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        filterText = searchInput.value || '';
                        renderList();
                    });
                }

                if (folderSelect) {
                    folderSelect.addEventListener('change', () => {
                        folderFilter = folderSelect.value || '';
                        renderList();
                    });
                }

                const browseButton = overlay.querySelector('#bgm-dialog-browse');
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'audio/*';
                fileInput.style.display = 'none';
                overlay.appendChild(fileInput);

                if (browseButton) {
                    browseButton.dataset.originalText = browseButton.textContent;
                    browseButton.addEventListener('click', () => {
                        fileInput.click();
                    });
                }

                fileInput.addEventListener('change', async (event) => {
                    const file = event.target?.files?.[0];
                    if (!file) {
                        return;
                    }
                    try {
                        const uploadResult = await uploadBgmFile(file, { buttonEl: browseButton });
                        const refreshedResponse = await fetch(`/api/translator/projects/${currentProject.id}/bgm/candidates`);
                        if (refreshedResponse.ok) {
                            const payload = await refreshedResponse.json();
                            if (Array.isArray(payload.candidates)) {
                                candidates.splice(0, candidates.length, ...payload.candidates);
                                const previousFolder = folderFilter;
                                updateFolderOptions(previousFolder);
                                folderFilter = folderSelect ? folderSelect.value || '' : '';
                                selectedIndex = candidates.findIndex((item) => item && item.path === uploadResult.bgm_path);
                                if (selectedIndex < 0) {
                                    selectedIndex = defaultIndex;
                                }
                                renderList();
                            }
                        }
                        alert('ì„ íƒí•œ ë°°ê²½ìŒì•… íŒŒì¼ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.');
                    } catch (error) {
                        console.error('Failed to upload BGM file:', error);
                        alert(error?.message || 'ë°°ê²½ìŒì•… íŒŒì¼ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    } finally {
                        event.target.value = '';
                    }
                });

                const removeCandidate = async (candidate, index, buttonEl) => {
                    if (!candidate || !candidate.path) {
                        alert('ì œê±°í•  ë°°ê²½ìŒì•… ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }
                    if (!currentProject || !currentProject.id) {
                        alert('í”„ë¡œì íŠ¸ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                        return;
                    }
                    if (!window.confirm('ì„ íƒí•œ ë°°ê²½ìŒì•… íŒŒì¼ì„ ì œê±°í• ê¹Œìš”?')) {
                        return;
                    }

                    const originalText = buttonEl?.textContent;
                    try {
                        if (buttonEl) {
                            buttonEl.disabled = true;
                            buttonEl.textContent = 'ì œê±° ì¤‘...';
                        }

                        const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/remove`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: candidate.path }),
                        });

                        if (!response.ok) {
                            const text = await response.text();
                            throw new Error(text || `HTTP ${response.status}`);
                        }

                        const result = await response.json();

                        stopPreview();

                        candidates.splice(index, 1);
                        if (selectedIndex === index) {
                            if (candidates.length === 0) {
                                selectedIndex = -1;
                            } else if (index >= candidates.length) {
                                selectedIndex = candidates.length - 1;
                            }
                        } else if (selectedIndex > index) {
                            selectedIndex -= 1;
                        }

                        updateFolderOptions(folderFilter);
                        folderFilter = folderSelect ? folderSelect.value || '' : '';

                        if (currentProject) {
                            currentProject.extra = { ...(result?.extra || {}) };
                        }

                        renderList();

                        if (typeof updateComparisonTimeline === 'function') {
                            try {
                                await updateComparisonTimeline();
                            } catch (error) {
                                console.warn('íƒ€ì„ë¼ì¸ ê°±ì‹  ì¤‘ ì˜¤ë¥˜:', error);
                            }
                        }

                        alert(result?.message || 'ë°°ê²½ìŒì•… íŒŒì¼ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.');
                    } catch (error) {
                        console.error('Failed to remove BGM candidate:', error);
                        alert(error?.message || 'ë°°ê²½ìŒì•… íŒŒì¼ ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    } finally {
                        if (buttonEl) {
                            buttonEl.disabled = false;
                            buttonEl.textContent = originalText || 'âŒ ì œê±°';
                        }
                    }
                };

                const cleanup = () => {
                    stopPreview();
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', onKeyDown);
                };

                const onKeyDown = (event) => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cleanup();
                        resolve(null);
                    }
                };

                document.addEventListener('keydown', onKeyDown);

                overlay.addEventListener('click', (event) => {
                    const target = event.target;
                    if (!(target instanceof HTMLElement)) {
                        return;
                    }
                    if (target.dataset && target.dataset.bgmPreview !== undefined) {
                        event.preventDefault();
                        const index = Number(target.dataset.bgmPreview);
                        const candidate = candidates[index];
                        if (candidate) {
                            playPreview(candidate);
                        }
                        return;
                    }
                    if (target.dataset && target.dataset.bgmRemove !== undefined) {
                        event.preventDefault();
                        const index = Number(target.dataset.bgmRemove);
                        const candidate = candidates[index];
                        if (candidate) {
                            removeCandidate(candidate, index, target);
                        }
                        return;
                    }
                    if (target.id === 'bgm-dialog-close') {
                        event.preventDefault();
                        cleanup();
                        resolve(null);
                        return;
                    }
                });

                overlay.addEventListener('change', (event) => {
                    const target = event.target;
                    if (!(target instanceof HTMLInputElement)) {
                        return;
                    }
                    if (target.name === 'bgm-candidate') {
                        selectedIndex = Number(target.value);
                        renderList();
                    }
                });

                const cancelBtn = overlay.querySelector('#bgm-dialog-cancel');
                const confirmBtn = overlay.querySelector('#bgm-dialog-confirm');

                cancelBtn?.addEventListener('click', () => {
                    cleanup();
                    resolve(null);
                });

                confirmBtn?.addEventListener('click', () => {
                    const selectedRadio = overlay.querySelector('input[name="bgm-candidate"]:checked');
                    if (!selectedRadio) {
                        cleanup();
                        resolve(null);
                        return;
                    }
                    const index = Number(selectedRadio.value);
                    const candidate = candidates[index];
                    cleanup();
                    resolve(candidate);
                });
            });
        }

        async function applyBgmCandidate(candidate) {
            if (!candidate || !candidate.path) {
                throw new Error('ì„ íƒëœ ë°°ê²½ìŒì•… ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            const payload = {
                path: candidate.path,
                kind: candidate.kind || null,
            };
            if (typeof candidate.volume_percent !== 'undefined') {
                payload.volume_percent = candidate.volume_percent;
            }

            const response = await fetch(`/api/translator/projects/${currentProject.id}/bgm/apply`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(text || `HTTP ${response.status}`);
            }

            const result = await response.json();

            if (!currentProject.extra) {
                currentProject.extra = {};
            }

            const kindString = candidate.kind ? String(candidate.kind) : '';

            if (typeof result.bgm_path !== 'undefined') {
                currentProject.extra.bgm_path = result.bgm_path;
            }
            if (typeof result.bgm_volume_percent !== 'undefined') {
                currentProject.extra.bgm_volume_percent = result.bgm_volume_percent;
            }
            if (typeof result.bgm_cache_token !== 'undefined') {
                currentProject.extra.bgm_cache_token = result.bgm_cache_token;
            }
            if (kindString.startsWith('custom') && !kindString.startsWith('custom_v2')) {
                currentProject.extra.bgm_custom_path = result.bgm_path;
            }

            if (typeof result.bgm_v2_path !== 'undefined') {
                if (result.bgm_v2_path) {
                    currentProject.extra.bgm_v2_path = result.bgm_v2_path;
                    currentProject.extra.bgm_custom_v2_path = result.bgm_v2_path;
                } else {
                    delete currentProject.extra.bgm_v2_path;
                    delete currentProject.extra.bgm_custom_v2_path;
                }
            } else if (kindString.startsWith('custom_v2')) {
                currentProject.extra.bgm_v2_path = candidate.path;
                currentProject.extra.bgm_custom_v2_path = candidate.path;
            }

            if (typeof result.bgm_v2_volume_percent !== 'undefined') {
                currentProject.extra.bgm_v2_volume_percent = result.bgm_v2_volume_percent;
            } else if (kindString.startsWith('custom_v2')) {
                currentProject.extra.bgm_v2_volume_percent = clamp(
                    Number.isFinite(Number(candidate.volume_percent)) ? Number(candidate.volume_percent) : 100,
                    0,
                    200,
                );
            }

            if (typeof result.bgm_v2_cache_token !== 'undefined') {
                currentProject.extra.bgm_v2_cache_token = result.bgm_v2_cache_token;
            } else if (kindString.startsWith('custom_v2')) {
                currentProject.extra.bgm_v2_cache_token = Date.now();
            }

            const appliedBgmV2Path = currentProject.extra.bgm_v2_path || currentProject.extra.bgm_custom_v2_path || '';
            if (appliedBgmV2Path) {
                setBgmV2Track(appliedBgmV2Path, {
                    volumePercent: currentProject.extra.bgm_v2_volume_percent ?? 100,
                    cacheToken: currentProject.extra.bgm_v2_cache_token || Date.now(),
                    force: true,
                });
            } else {
                setBgmV2Track('', { force: true });
            }

            await updateComparisonTimeline();
        }

        function showTrackSelectionDialog(tracks) {
            return new Promise((resolve) => {
                let currentAudio = null;
                let sortOrder = 'date'; // 'date', 'segments', 'name'
                let sortedTracks = [...tracks];

                const sortTracks = (order) => {
                    sortOrder = order;
                    if (order === 'date') {
                        sortedTracks.sort((a, b) => b.created_at - a.created_at);
                    } else if (order === 'segments') {
                        sortedTracks.sort((a, b) => b.segment_count - a.segment_count);
                    } else if (order === 'name') {
                        sortedTracks.sort((a, b) => a.filename.localeCompare(b.filename));
                    }
                    renderTrackList();
                };

                const deleteTrack = async (track, index) => {
                    if (!confirm(`"${track.filename}"ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                        return;
                    }

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/tracks`, {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ file_path: track.file_path })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        // íŠ¸ë™ ëª©ë¡ì—ì„œ ì œê±°
                        sortedTracks.splice(index, 1);
                        tracks.splice(tracks.indexOf(track), 1);

                        if (sortedTracks.length === 0) {
                            alert('ëª¨ë“  íŠ¸ë™ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                            cleanup();
                            resolve(null);
                            return;
                        }

                        renderTrackList();
                        alert('íŠ¸ë™ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } catch (err) {
                        console.error('Failed to delete track:', err);
                        alert('íŠ¸ë™ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    }
                };

                const playPreview = (track) => {
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio = null;
                    }

                    currentAudio = new Audio(track.path);
                    currentAudio.play().catch(err => {
                        console.error('Failed to play preview:', err);
                        alert('ë¯¸ë¦¬ë“£ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    });

                    // 10ì´ˆ í›„ ìë™ ì •ì§€
                    setTimeout(() => {
                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio = null;
                        }
                    }, 10000);
                };

                const renderTrackList = () => {
                    const trackListElem = document.getElementById('track-list');
                    if (!trackListElem) return;

                    trackListElem.innerHTML = sortedTracks.map((track, index) => {
                        const date = new Date(track.created_at * 1000).toLocaleString('ko-KR');
                        const isLatest = sortOrder === 'date' && index === 0;
                        return `
                            <div style="
                                display: flex;
                                align-items: center;
                                gap: 8px;
                                padding: 12px;
                                margin-bottom: 8px;
                                background: ${isLatest ? '#2a3f5f' : '#0d1520'};
                                border: 2px solid ${isLatest ? '#4bd4ff' : '#2a3f5f'};
                                border-radius: 8px;
                                transition: all 0.2s;
                            " onmouseover="this.style.borderColor='#4bd4ff'" onmouseout="this.style.borderColor='${isLatest ? '#4bd4ff' : '#2a3f5f'}'">
                                <input type="radio" name="track-selection" value="${index}" ${isLatest ? 'checked' : ''}>
                                <div style="flex: 1; min-width: 0;">
                                    <div style="color: #f0f4f8; font-weight: ${isLatest ? 'bold' : 'normal'}; margin-bottom: 4px;">
                                        ${track.filename}
                                        ${isLatest ? '<span style="color: #4bd4ff; font-size: 12px;"> (ìµœì‹ )</span>' : ''}
                                    </div>
                                    <div style="color: #9ca3af; font-size: 12px;">
                                        ì„¸ê·¸ë¨¼íŠ¸: ${track.segment_count}ê°œ | ${date}
                                    </div>
                                </div>
                                <button class="btn-sm" onclick="event.preventDefault(); window.playTrackPreview(${index});" style="background: #4bd4ff; color: #000; padding: 4px 12px; white-space: nowrap;">
                                    â–¶ï¸ ë¯¸ë¦¬ë“£ê¸°
                                </button>
                                <button class="btn-sm" onclick="event.preventDefault(); window.deleteTrackItem(${index});" style="background: #dc3545; color: #fff; padding: 4px 12px; white-space: nowrap;">
                                    ğŸ—‘ï¸ ì‚­ì œ
                                </button>
                            </div>
                        `;
                    }).join('');
                };

                // ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡ (onclickì—ì„œ ì‚¬ìš©)
                window.playTrackPreview = (index) => playPreview(sortedTracks[index]);
                window.deleteTrackItem = (index) => deleteTrack(sortedTracks[index], index);

                // ë‹¤ì´ì–¼ë¡œê·¸ HTML ìƒì„±
                const dialogHtml = `
                    <div id="track-selection-dialog" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                    ">
                        <div style="
                            background: #1a2332;
                            border-radius: 12px;
                            padding: 24px;
                            max-width: 700px;
                            width: 90%;
                            max-height: 80vh;
                            overflow-y: auto;
                            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h3 style="margin: 0; color: #f0f4f8; font-size: 20px;">
                                    ìƒì„±ëœ ìŒì„± íŠ¸ë™ ì„ íƒ
                                </h3>
                                <div style="display: flex; gap: 8px;">
                                    <select id="track-sort-select" class="form-control form-control-sm" style="width: auto;">
                                        <option value="date">ìµœì‹ ìˆœ</option>
                                        <option value="segments">ì„¸ê·¸ë¨¼íŠ¸ìˆœ</option>
                                        <option value="name">ì´ë¦„ìˆœ</option>
                                    </select>
                                </div>
                            </div>
                            <div id="track-list" style="margin-bottom: 20px;">
                            </div>
                            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                                <button id="track-cancel-btn" class="btn-sm" style="background: #6c757d;">
                                    ì·¨ì†Œ
                                </button>
                                <button id="track-confirm-btn" class="btn-primary btn-sm">
                                    í™•ì¸
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                // ë‹¤ì´ì–¼ë¡œê·¸ë¥¼ DOMì— ì¶”ê°€
                const dialogContainer = document.createElement('div');
                dialogContainer.innerHTML = dialogHtml;
                document.body.appendChild(dialogContainer);

                // ì´ˆê¸° ë Œë”ë§
                sortTracks('date');

                // ì •ë ¬ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
                const sortSelect = document.getElementById('track-sort-select');
                sortSelect.addEventListener('change', (e) => {
                    sortTracks(e.target.value);
                });

                // ë²„íŠ¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
                const cancelBtn = document.getElementById('track-cancel-btn');
                const confirmBtn = document.getElementById('track-confirm-btn');

                const cleanup = () => {
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio = null;
                    }
                    delete window.playTrackPreview;
                    delete window.deleteTrackItem;
                    document.body.removeChild(dialogContainer);
                };

                cancelBtn.onclick = () => {
                    cleanup();
                    resolve(null);
                };

                confirmBtn.onclick = () => {
                    const selectedRadio = document.querySelector('input[name="track-selection"]:checked');
                    if (selectedRadio) {
                        const selectedIndex = parseInt(selectedRadio.value);
                        cleanup();
                        resolve(sortedTracks[selectedIndex]);
                    } else {
                        cleanup();
                        resolve(null);
                    }
                };

                // ESC í‚¤ë¡œ ë‹«ê¸°
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        async function loadTrackToTimeline(audioUrl) {
            // í˜„ì¬ í”„ë¡œì íŠ¸ì˜ extra í•„ë“œì— ë¶ˆëŸ¬ì˜¨ íŠ¸ë™ ê²½ë¡œ ì €ì¥
            if (!currentProject) {
                console.error('No current project');
                return;
            }

            console.log('Loading track to timeline:', audioUrl);

            // í”„ë¡œì íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸ (extra.voice_pathì— ì €ì¥)
            if (!currentProject.extra) {
                currentProject.extra = {};
            }
            currentProject.extra.voice_path = audioUrl;

            console.log('Updated project extra:', currentProject.extra);

            // ì„œë²„ì— ì—…ë°ì´íŠ¸ ì €ì¥
            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        extra: currentProject.extra
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                const updatedProject = await response.json();
                console.log('Server response:', updatedProject);
                console.log('Server response extra:', updatedProject.extra);

                currentProject = updatedProject;

                console.log('Current project after update:', currentProject);
                console.log('Current project extra after update:', currentProject.extra);

                console.log('Calling updateComparisonTimeline...');
                // íƒ€ì„ë¼ì¸ ìƒˆë¡œê³ ì¹¨ - ì•½ê°„ì˜ ì§€ì—°ì„ ì£¼ì–´ DOM ì—…ë°ì´íŠ¸ ë³´ì¥
                setTimeout(async () => {
                    console.log('Executing updateComparisonTimeline');
                    await updateComparisonTimeline();
                    console.log('Timeline updated successfully');
                }, 100);

            } catch (err) {
                console.error('Failed to update project with track:', err);
                // ì‹¤íŒ¨í•´ë„ í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” íƒ€ì„ë¼ì¸ ì—…ë°ì´íŠ¸ ì‹œë„
                console.log('Attempting to update timeline anyway...');
                await updateComparisonTimeline();
            }
        }

        function playAllAudio() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const audioSegments = currentProject.segments
                .filter(seg => seg.audio_path)
                .map(seg => ({
                    segmentId: seg.id,
                    path: toWebAudioPath(seg.audio_path)
                }))
                .filter(item => item.path);

            if (audioSegments.length === 0) {
                alert('ì¬ìƒí•  ìŒì„± íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìŒì„±ì„ ìƒì„±í•´ì£¼ì„¸ìš”.');
                return;
            }

            stopComparisonTimeline({ clearHighlight: false });
            stopSingleAudioPlayback({ clearHighlight: true });
            stopAllAudio({ clearHighlight: true });

            allAudioQueue = audioSegments;
            allAudioIndex = 0;
            allAudioPlayer = new Audio();
            allAudioPlayer.addEventListener('ended', handleAllAudioEnded);
            allAudioPlayer.addEventListener('error', handleAllAudioError);

            if (stopAllAudioBtn) {
                stopAllAudioBtn.disabled = false;
            }

            playCurrentAllAudioSegment();
        }

        function saveAllAudio() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            alert('ì „ì²´ ìŒì„± ì €ì¥ ê¸°ëŠ¥ì€ ë°±ì—”ë“œì—ì„œ êµ¬í˜„ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. í˜„ì¬ëŠ” ê°œë³„ ì„¸ê·¸ë¨¼íŠ¸ ìŒì„± íŒŒì¼ì´ ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.');
        }

        async function saveSelectedAudioAs() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            if (selectedSegmentIds.size === 0) {
                alert('ì €ì¥í•  ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ ì¤‘ ìŒì„±ì´ ìƒì„±ëœ ê²ƒë§Œ í•„í„°ë§
            const selectedSegments = currentProject.segments.filter(seg =>
                selectedSegmentIds.has(seg.id) && seg.audio_path
            );

            if (selectedSegments.length === 0) {
                alert('ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ ì¤‘ ìŒì„±ì´ ìƒì„±ëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìŒì„±ì„ ìƒì„±í•´ì£¼ì„¸ìš”.');
                return;
            }

            const newName = prompt(
                `${selectedSegments.length}ê°œì˜ ì„ íƒëœ ìŒì„±ì„ ìƒˆ í”„ë¡œì íŠ¸ë¡œ ì €ì¥í•©ë‹ˆë‹¤.\nìƒˆ í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:`,
                currentProject.base_name + '_ì„ íƒìŒì„±'
            );

            if (!newName || newName.trim() === '') {
                return;
            }

            const saveBtn = document.getElementById('save-selected-audio-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'ğŸ’¾ ì €ì¥ ì¤‘...';
            }

            try {
                const trimmedName = newName.trim();
                console.log(`ğŸ’¾ Saving selected audio with name: "${trimmedName}"`);

                // ë¨¼ì € í”„ë¡œì íŠ¸ë¥¼ ë³µì œ
                const clonePayload = { new_name: trimmedName };
                console.log('ğŸ“¤ Clone request payload:', clonePayload);

                const cloneResponse = await fetch(`/api/translator/projects/${currentProject.id}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(clonePayload)
                });

                if (!cloneResponse.ok) {
                    const errorText = await cloneResponse.text();
                    console.error('âŒ Clone failed:', errorText);
                    throw new Error('í”„ë¡œì íŠ¸ ë³µì‚¬ ì‹¤íŒ¨');
                }

                const newProject = await cloneResponse.json();
                console.log('âœ… Project cloned:', {
                    id: newProject.id,
                    base_name: newProject.base_name,
                    expected_name: trimmedName
                });

                // ë³µì œëœ í”„ë¡œì íŠ¸ì—ì„œ ì„ íƒë˜ì§€ ì•Šì•˜ê±°ë‚˜ ìŒì„±ì´ ì—†ëŠ” ì„¸ê·¸ë¨¼íŠ¸ ì‚­ì œ
                const segmentsToDelete = newProject.segments.filter(seg =>
                    !selectedSegmentIds.has(seg.id) || !seg.audio_path
                );
                console.log(`ğŸ—‘ï¸ Deleting ${segmentsToDelete.length} segments from cloned project...`);

                let deletedCount = 0;
                for (const segment of segmentsToDelete) {
                    try {
                        const deleteResponse = await fetch(`/api/translator/projects/${newProject.id}/segments/${segment.id}`, {
                            method: 'DELETE'
                        });

                        if (deleteResponse.ok) {
                            deletedCount++;
                        }
                    } catch (error) {
                        console.error(`Failed to delete segment ${segment.id}:`, error);
                    }
                }

                console.log(`âœ… Deleted ${deletedCount} segments from cloned project`);

                alert(`âœ… ${selectedSegments.length}ê°œì˜ ìŒì„±ì´ "${newName}"ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);

                // ìƒˆ í”„ë¡œì íŠ¸ë¡œ ì´ë™í• ì§€ ë¬¼ì–´ë³´ê¸°
                if (confirm('ì €ì¥ëœ í”„ë¡œì íŠ¸ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    window.location.href = `/translator?id=${newProject.id}`;
                }
            } catch (error) {
                console.error('Save selected audio error:', error);
                alert('âŒ ì„ íƒëœ ìŒì„± ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'ğŸ’¾ ì„ íƒ ìŒì„± ì €ì¥';
                }
            }
        }

        function syncSelectionWithProject() {
            if (!currentProject) {
                selectedSegmentIds.clear();
                updateSelectionUI();
                return;
            }
            const validIds = new Set(currentProject.segments.map(seg => seg.id));
            Array.from(selectedSegmentIds).forEach(id => {
                if (!validIds.has(id)) {
                    selectedSegmentIds.delete(id);
                }
            });
            updateSelectionUI();
        }

        async function saveSelectedSegmentsAs() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            if (selectedSegmentIds.size === 0) {
                alert('ì €ì¥í•  ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const selectedSegments = currentProject.segments.filter(seg => selectedSegmentIds.has(seg.id));
            const newName = prompt(
                `${selectedSegments.length}ê°œì˜ ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ìƒˆ í”„ë¡œì íŠ¸ë¡œ ì €ì¥í•©ë‹ˆë‹¤.\nìƒˆ í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:`,
                currentProject.base_name + '_ì„ íƒë³¸'
            );

            if (!newName || newName.trim() === '') {
                return;
            }

            const saveBtn = document.getElementById('save-selected-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'ğŸ’¾ ì €ì¥ ì¤‘...';
            }

            try {
                const trimmedName = newName.trim();
                console.log(`ğŸ’¾ Saving selected segments with name: "${trimmedName}"`);

                // ë¨¼ì € í”„ë¡œì íŠ¸ë¥¼ ë³µì œ
                const clonePayload = { new_name: trimmedName };
                console.log('ğŸ“¤ Clone request payload:', clonePayload);

                const cloneResponse = await fetch(`/api/translator/projects/${currentProject.id}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(clonePayload)
                });

                if (!cloneResponse.ok) {
                    const errorText = await cloneResponse.text();
                    console.error('âŒ Clone failed:', errorText);
                    throw new Error('í”„ë¡œì íŠ¸ ë³µì‚¬ ì‹¤íŒ¨');
                }

                const newProject = await cloneResponse.json();
                console.log('âœ… Project cloned:', {
                    id: newProject.id,
                    base_name: newProject.base_name,
                    expected_name: trimmedName
                });

                // ë³µì œëœ í”„ë¡œì íŠ¸ì—ì„œ ì„ íƒë˜ì§€ ì•Šì€ ì„¸ê·¸ë¨¼íŠ¸ ì‚­ì œ
                const segmentsToDelete = newProject.segments.filter(seg => !selectedSegmentIds.has(seg.id));
                console.log(`ğŸ—‘ï¸ Deleting ${segmentsToDelete.length} unselected segments from cloned project...`);

                let deletedCount = 0;
                for (const segment of segmentsToDelete) {
                    try {
                        const deleteResponse = await fetch(`/api/translator/projects/${newProject.id}/segments/${segment.id}`, {
                            method: 'DELETE'
                        });

                        if (deleteResponse.ok) {
                            deletedCount++;
                        }
                    } catch (error) {
                        console.error(`Failed to delete segment ${segment.id}:`, error);
                    }
                }

                console.log(`âœ… Deleted ${deletedCount} segments from cloned project`);

                alert(`âœ… ${selectedSegments.length}ê°œì˜ ì„¸ê·¸ë¨¼íŠ¸ê°€ "${newName}"ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);

                // ìƒˆ í”„ë¡œì íŠ¸ë¡œ ì´ë™í• ì§€ ë¬¼ì–´ë³´ê¸°
                if (confirm('ì €ì¥ëœ í”„ë¡œì íŠ¸ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    window.location.href = `/translator?id=${newProject.id}`;
                }
            } catch (error) {
                console.error('Save selected segments error:', error);
                alert('âŒ ì„ íƒëœ ì„¸ê·¸ë¨¼íŠ¸ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'ì²´í¬ìë§‰ ë‹¤ë¥¸ì´ë¦„ ì €ì¥';
                }
            }
        }

        async function deleteUnselectedSegments() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const unselectedSegments = currentProject.segments.filter(seg => !selectedSegmentIds.has(seg.id));

            if (unselectedSegments.length === 0) {
                alert('ì‚­ì œí•  ë¯¸ì„ íƒ ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const selectedCount = selectedSegmentIds.size;
            const totalCount = currentProject.segments.length;
            const deleteCount = unselectedSegments.length;

            const confirmMessage = `ì´ ${totalCount}ê°œ ì¤‘ ${selectedCount}ê°œê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.\nì„ íƒë˜ì§€ ì•Šì€ ${deleteCount}ê°œì˜ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`;
            if (!confirm(confirmMessage)) {
                return;
            }

            // Show progress
            const deleteBtn = document.getElementById('delete-unselected-btn');
            if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.textContent = `ì‚­ì œ ì¤‘... 0/${deleteCount}`;
            }

            let deletedCount = 0;
            let failedCount = 0;

            for (let i = 0; i < unselectedSegments.length; i++) {
                const segment = unselectedSegments[i];
                try {
                    const response = await fetch(`/api/translator/projects/${currentProject.id}/segments/${segment.id}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        deletedCount++;
                        // Update progress
                        if (deleteBtn) {
                            deleteBtn.textContent = `ì‚­ì œ ì¤‘... ${deletedCount}/${deleteCount}`;
                        }
                    } else {
                        failedCount++;
                        console.error(`Failed to delete segment ${segment.id}: ${response.status}`);
                    }
                } catch (error) {
                    failedCount++;
                    console.error(`Error deleting segment ${segment.id}:`, error);
                }
            }

            // Reset button
            if (deleteBtn) {
                deleteBtn.disabled = false;
                deleteBtn.textContent = 'ë¯¸ì„ íƒ í™”ì ì „ì²´ ì‚­ì œ';
            }

            if (failedCount > 0) {
                alert(`${deletedCount}ê°œ ì‚­ì œ ì™„ë£Œ, ${failedCount}ê°œ ì‹¤íŒ¨`);
            } else {
                alert(`âœ… ${deletedCount}ê°œ ì„¸ê·¸ë¨¼íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
            }

            // Clear selection after deletion
            selectedSegmentIds.clear();

            // Reload the project to reflect changes
            try {
                console.log('ğŸ”„ Fetching updated project...');
                const response = await fetch(`/api/translator/projects/${currentProject.id}`);
                if (response.ok) {
                    const updatedProject = await response.json();

                    console.log('ğŸ“¦ Received project data:', {
                        id: updatedProject.id,
                        segmentCount: updatedProject.segments.length,
                        status: updatedProject.status
                    });

                    // Update current project reference
                    currentProject = updatedProject;

                    // Update project title and status
                    if (projectTitle) {
                        projectTitle.textContent = updatedProject.base_name;
                    }
                    if (projectStatus) {
                        projectStatus.textContent = `ìƒíƒœ: ${updatedProject.status} | ì„¸ê·¸ë¨¼íŠ¸: ${updatedProject.segments.length}ê°œ`;
                    }

                    console.log('ğŸ¨ Re-rendering segments...');
                    // Re-render segments with updated data
                    renderSegments(updatedProject);

                    console.log('âœ… Segments rendered. DOM element count:', document.querySelectorAll('.segment-item').length);

                    // Update selection UI
                    updateSelectionUI();

                    console.log('âœ… Project reloaded successfully. New segment count:', updatedProject.segments.length);
                    console.log('ğŸ“Š Segment IDs:', updatedProject.segments.map(s => s.id).join(', '));
                } else {
                    console.error('âŒ Failed to reload project:', response.status);
                    alert('í”„ë¡œì íŠ¸ ìƒˆë¡œê³ ì¹¨ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.');
                    window.location.reload();
                }
            } catch (error) {
                console.error('âŒ Failed to reload project:', error);
                alert('í”„ë¡œì íŠ¸ ìƒˆë¡œê³ ì¹¨ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.');
                window.location.reload();
            }
        }

        function updateSelectionUI() {
            if (selectionCountElem) {
                selectionCountElem.textContent = selectedSegmentIds.size.toString();
            }
            document.querySelectorAll('.segment-select').forEach(cb => {
                const id = cb.dataset.segmentId;
                cb.checked = selectedSegmentIds.has(id);
            });
        }

        function attachSelectionCheckboxListeners() {
            document.querySelectorAll('.segment-select').forEach(cb => {
                const segmentId = cb.dataset.segmentId;
                cb.addEventListener('change', (event) => {
                    if (!segmentId) {
                        return;
                    }
                    if (event.target.checked) {
                        selectedSegmentIds.add(segmentId);
                    } else {
                        selectedSegmentIds.delete(segmentId);
                    }
                    updateSelectionUI();
                });
            });
        }

        function switchSourceSelectorMode(mode) {
            if (sourceSelectorMode === mode) {
                updateSourceApplyState();
                return;
            }

            sourceSelectorMode = mode;
            selectedSourceIndex = null;
            selectedSavedResultId = null;
            selectedProjectId = null;
            updateSourceApplyState();

            if (sourceSelectorTabs) {
                sourceSelectorTabs.querySelectorAll('.tab').forEach(tab => {
                    const tabMode = tab.dataset.mode;
                    if (tabMode === mode) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
            }

            if (mode === 'downloads') {
                loadDownloadSources();
            } else if (mode === 'projects') {
                loadTranslatorProjects();
            } else {
                loadSavedResultOptions();
            }
        }

        function applySourceSelection() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }
            sourceSelectorApplyBtn.disabled = true;
            const originalLabel = sourceSelectorApplyBtn.textContent;
            sourceSelectorApplyBtn.textContent = 'ì ìš© ì¤‘...';

            let request;

            if (sourceSelectorMode === 'downloads') {
                if (selectedSourceIndex === null || selectedSourceIndex < 0) {
                    alert('ì‚¬ìš©í•  íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                const option = availableSourceOptions[selectedSourceIndex];
                if (!option || !option.video_path) {
                    alert('ì„ íƒí•œ í•­ëª©ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                const payload = {
                    source_video: option.video_path,
                    source_subtitle: option.subtitle_path || null
                };

                request = fetch(`/api/translator/projects/${currentProject.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
            } else if (sourceSelectorMode === 'projects') {
                if (!selectedProjectId) {
                    alert('ë¶ˆëŸ¬ì˜¬ í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                // ì„ íƒí•œ í”„ë¡œì íŠ¸ë¡œ ì´ë™
                window.location.href = `/translator?id=${selectedProjectId}`;
                return;
            } else {
                if (!selectedSavedResultId) {
                    alert('ì¬í•´ì„ ì €ì¥ë³¸ì„ ì„ íƒí•˜ì„¸ìš”.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }
                const savedResult = savedResultDetailCache[selectedSavedResultId];
                if (!savedResult) {
                    alert('ì €ì¥ë³¸ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                    return;
                }

                request = fetch(`/api/translator/projects/${currentProject.id}/apply-saved-result`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ saved_result: savedResult })
                });
            }

            request
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    renderProject(project);
                    closeSourceSelectorModal();
                })
                .catch(err => {
                    console.error('Failed to update project source:', err);
                    alert('ì†ŒìŠ¤ë¥¼ ì—…ë°ì´íŠ¸í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                })
                .finally(() => {
                    sourceSelectorApplyBtn.textContent = originalLabel;
                    updateSourceApplyState();
                });
        }



        function renderDownloads(items) {
            if (!items || !items.length) {
                downloadsList.innerHTML = '<p class="empty-state">ë‹¤ìš´ë¡œë“œëœ ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤. <a href="/ytdl">ìœ íŠœë¸Œ ë‹¤ìš´ë¡œë“œ</a> ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¨¼ì € ì˜ìƒì„ ë°›ì•„ì£¼ì„¸ìš”.</p>';
                return;
            }
            const html = items.map((item, index) => {
                const hasSubtitle = item.subtitle_path;
                const videoName = item.base_name;
                const subtitleName = hasSubtitle ? item.subtitle_path.split('/').pop() : 'ìë§‰ ì—†ìŒ';
                return `
                    <div class="download-item" data-index="${index}">
                        <div class="item-header">
                            <input type="radio" name="source" id="source-${index}" value="${index}">
                            <label for="source-${index}">${videoName}</label>
                        </div>
                        <div class="item-meta">
                            <span>${item.video_path}</span>
                            <span class="${hasSubtitle ? 'text-success' : 'text-warning'}">${subtitleName}</span>
                        </div>
                    </div>
                `;
            }).join('');
            downloadsList.innerHTML = `<div class="form-group">${html}</div>`;
            downloadsList.querySelectorAll('input[name="source"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    const selectedIndex = parseInt(event.target.value, 10);
                    selectedSource = items[selectedIndex];
                    showAICommentarySection();
                });
            });
        }

        function fetchDownloads() {
            downloadsList.innerHTML = '<p class="empty-state">API í˜¸ì¶œ ì¤‘...</p>';

            // Add cache busting parameter
            const cacheBuster = Date.now();
            fetch(`/api/translator/downloads?_cb=${cacheBuster}`)
                .then(res => {
                    if (res.ok) {
                        return res.json();
                    } else {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                })
                .then(data => {
                    renderDownloads(data);
                })
                .catch(err => {
                    console.error('Download fetch error:', err);
                    downloadsList.innerHTML = `<p class="empty-state error">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${err.message}</p>`;
                });
        }

        function applySettings(settings) {
            // alert('Received settings: ' + JSON.stringify(settings));
            if (settings) {
                document.getElementById('target-lang').value = settings.target_lang || 'ja';
                document.getElementById('translation-mode').value = settings.translation_mode || 'reinterpret';
                document.getElementById('tone-hint').value = settings.tone_hint || 'ë“œë¼ë§ˆí•˜ê³  ìœ ì¾Œí•˜ë©´ì„œ ìœ ë¨¸ëŸ¬ìŠ¤í•˜ê²Œ';
            }
        }

        const loadSettingsBtn = document.getElementById('load-settings-btn');
        if (loadSettingsBtn) {
            loadSettingsBtn.addEventListener('click', () => {
                fetch('/api/translator/settings')
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(applySettings)
                    .catch(err => {
                        console.error(err);
                        alert('ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    });
            });
        }

        const saveSettingsBtn = document.getElementById('save-settings-btn');
        if (saveSettingsBtn) {
            saveSettingsBtn.addEventListener('click', () => {
                const formData = new FormData(creationForm);
                const settings = {
                    target_lang: formData.get('target_lang'),
                    translation_mode: formData.get('translation_mode'),
                    tone_hint: formData.get('tone_hint') || null,
                };

                fetch('/api/translator/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings),
                })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(result => {
                    alert('ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                })
                .catch(err => {
                    console.error(err);
                    alert('ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                });
            });
        }

        creationForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!selectedSource) {
                alert('ë²ˆì—­í•  ì†ŒìŠ¤ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            const formData = new FormData(creationForm);
            const payload = {
                source_video: selectedSource.video_path,
                source_subtitle: selectedSource.subtitle_path || null,
                target_lang: formData.get('target_lang'),
                translation_mode: formData.get('translation_mode'),
                tone_hint: formData.get('tone_hint') || null,
            };
            const submitButton = creationForm.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.textContent = 'ìƒì„± ì¤‘...';
            fetch('/api/translator/projects', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            })
            .then(res => res.ok ? res.json() : Promise.reject(res))
            .then(project => {
                window.location.href = `/translator?id=${project.id}`;
            })
            .catch(err => {
                console.error(err);
                alert('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            })
            .finally(() => {
                submitButton.disabled = false;
                submitButton.textContent = 'ë²ˆì—­ í”„ë¡œì íŠ¸ ìƒì„±';
            });
        });

        function renderProject(project) {
            // URLì˜ í”„ë¡œì íŠ¸ IDì™€ ë¡œë“œëœ í”„ë¡œì íŠ¸ ID ê²€ì¦
            const urlParams = new URLSearchParams(window.location.search);
            const expectedProjectId = urlParams.get('id') || urlParams.get('project');

            if (expectedProjectId && project.id !== expectedProjectId) {
                console.warn(`âš ï¸ Project ID mismatch detected!`);
                console.warn(`   URL expects: ${expectedProjectId}`);
                console.warn(`   But got: ${project.id}`);
                console.warn(`   Reloading correct project...`);

                // ì˜¬ë°”ë¥¸ í”„ë¡œì íŠ¸ ë‹¤ì‹œ ë¡œë“œ
                loadProject(expectedProjectId);
                return;
            }

            currentProject = project;
            syncSelectionWithProject();
            creationView.classList.add('hidden');
            projectView.classList.remove('hidden');

            if (openSourceSelectorBtn) {
                openSourceSelectorBtn.style.display = 'inline-flex';
            }

            // base_name ë˜ëŠ” idì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ì œê±°í•œ ê°’ í‘œì‹œ
            let displayTitle = project.base_name || project.id || 'ì´ë¦„ ì—†ìŒ';
            if (displayTitle.startsWith('backup_')) {
                displayTitle = displayTitle.substring(7);
            }
            displayTitle = displayTitle.replace(/_\d{8}_\d{6}$/, '');

            projectTitle.textContent = displayTitle;
            projectStatus.textContent = `ìƒíƒœ: ${project.status}`;

            // Reconstruct selectedSource from project data
            if (project.source_video) {
                selectedSource = {
                    video_path: project.source_video,
                    subtitle_path: project.source_subtitle,
                    base_name: project.base_name,
                    video_name: extractFileName(project.source_video),
                    subtitle_name: extractFileName(project.source_subtitle)
                };
            }

            projectActions.innerHTML = ''; // Clear actions

            const timelineToggleBtn = document.createElement('button');
            timelineToggleBtn.id = 'timeline-toggle-btn';
            timelineToggleBtn.className = 'btn-secondary';
            // í˜„ì¬ ëª¨ë“œë¥¼ í‘œì‹œ: íƒ€ì„ë¼ì¸ ëª¨ë“œë©´ "ğŸ“‹ íƒ€ì„ë¼ì¸ í¸ì§‘ê¸° (í˜„ì¬)", ì¹´ë“œ ëª¨ë“œë©´ "íƒ€ì„ë¼ì¸ í¸ì§‘ê¸°ë¡œ ì „í™˜"
            timelineToggleBtn.textContent = isTimelineView ? 'ğŸ“‹ ì¹´ë“œ ë³´ê¸°' : 'ğŸ“‹ íƒ€ì„ë¼ì¸ í¸ì§‘ê¸°';
            timelineToggleBtn.addEventListener('click', () => {
                isTimelineView = !isTimelineView;
                timelineToggleBtn.textContent = isTimelineView ? 'ğŸ“‹ ì¹´ë“œ ë³´ê¸°' : 'ğŸ“‹ íƒ€ì„ë¼ì¸ í¸ì§‘ê¸°';
                renderSegments(currentProject);
            });

            const sourceSelectorActionBtn = document.createElement('button');
            sourceSelectorActionBtn.id = 'project-source-selector-btn';
            sourceSelectorActionBtn.className = 'btn-secondary';
            sourceSelectorActionBtn.textContent = 'íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°';
            sourceSelectorActionBtn.addEventListener('click', openSourceSelectorModal);
            projectActions.appendChild(sourceSelectorActionBtn);
            projectActions.appendChild(timelineToggleBtn);

            const selectionControls = buildSelectionControls();
            projectActions.appendChild(selectionControls);
            updateSelectionUI();

            // Save buttons
            const saveBtn = document.createElement('button');
            saveBtn.id = 'save-project-btn';
            saveBtn.className = 'btn-primary';
            saveBtn.textContent = 'ğŸ’¾ ì €ì¥';
            saveBtn.addEventListener('click', saveProject);
            projectActions.appendChild(saveBtn);

            const saveAsBtn = document.createElement('button');
            saveAsBtn.id = 'save-as-project-btn';
            saveAsBtn.className = 'btn-secondary';
            saveAsBtn.textContent = 'ğŸ’¾ ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥';
            saveAsBtn.addEventListener('click', saveProjectAs);
            projectActions.appendChild(saveAsBtn);

            // Always show delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.id = 'delete-project-btn';
            deleteBtn.className = 'btn-secondary';
            deleteBtn.style.background = 'linear-gradient(120deg, #ff6d6d, #ff3d7f)';
            deleteBtn.style.color = '#fff6f6';
            deleteBtn.textContent = 'í”„ë¡œì íŠ¸ ì‚­ì œ';
            deleteBtn.addEventListener('click', deleteProject);
            projectActions.appendChild(deleteBtn);

            if (project.status === 'segmenting' || project.status === 'draft') {
                const translateBtn = document.createElement('button');
                translateBtn.id = 'translate-btn';
                translateBtn.className = 'btn-primary';
                translateBtn.textContent = 'ë²ˆì—­ ì‹¤í–‰';
                translateBtn.addEventListener('click', runTranslation);
                projectActions.appendChild(translateBtn);

                const commentaryBtn = document.createElement('button');
                commentaryBtn.id = 'korean-commentary-btn';
                commentaryBtn.className = 'btn-secondary';
                commentaryBtn.textContent = 'í•œêµ­ì–´ AI í•´ì„¤ ë„£ê¸°';
                commentaryBtn.style.background = '#28a745';
                commentaryBtn.style.color = 'white';
                commentaryBtn.addEventListener('click', generateKoreanCommentary);
                projectActions.appendChild(commentaryBtn);
            } else if (project.status === 'voice_ready') {
                // Voice synthesis mode selector
                const voiceModeDiv = document.createElement('div');
                voiceModeDiv.style.display = 'flex';
                voiceModeDiv.style.alignItems = 'center';
                voiceModeDiv.style.gap = '10px';
                voiceModeDiv.style.marginBottom = '10px';

                const voiceModeLabel = document.createElement('label');
                voiceModeLabel.textContent = 'ìŒì„± í•©ì„± ëŒ€ìƒ:';
                voiceModeLabel.style.fontWeight = 'bold';

                const voiceModeSelect = document.createElement('select');
                voiceModeSelect.id = 'voice-synthesis-mode';
                voiceModeSelect.innerHTML = `
                    <option value="subtitle" ${project.voice_synthesis_mode === 'subtitle' ? 'selected' : ''}>ìë§‰ë§Œ</option>
                    <option value="commentary" ${project.voice_synthesis_mode === 'commentary' ? 'selected' : ''}>í•´ì„¤ë§Œ</option>
                    <option value="both" ${project.voice_synthesis_mode === 'both' ? 'selected' : ''}>ìë§‰+í•´ì„¤</option>
                `;
                voiceModeSelect.addEventListener('change', updateVoiceSynthesisMode);

                voiceModeDiv.appendChild(voiceModeLabel);
                voiceModeDiv.appendChild(voiceModeSelect);
                projectActions.appendChild(voiceModeDiv);

                const voiceBtn = document.createElement('button');
                voiceBtn.id = 'voice-btn';
                voiceBtn.className = 'btn-primary';
                voiceBtn.textContent = 'ìŒì„± ìƒì„±';
                voiceBtn.addEventListener('click', runVoiceSynthesis);
                projectActions.appendChild(voiceBtn);

                const reverseTranslateAllBtn = document.createElement('button');
                reverseTranslateAllBtn.id = 'reverse-translate-all-btn';
                reverseTranslateAllBtn.className = 'btn-secondary';
                reverseTranslateAllBtn.style.background = 'rgba(255, 209, 102, 0.15)';
                reverseTranslateAllBtn.style.border = '1px solid rgba(255, 209, 102, 0.6)';
                reverseTranslateAllBtn.style.color = '#ffd166';
                reverseTranslateAllBtn.textContent = 'ì „ì²´ ì—­ë²ˆì—­';
                reverseTranslateAllBtn.addEventListener('click', runReverseTranslateAll);
                projectActions.appendChild(reverseTranslateAllBtn);
            } else if (project.status === 'voice_complete') {
                // Voice synthesis mode selector (keep it for re-generation)
                const voiceModeDiv = document.createElement('div');
                voiceModeDiv.style.display = 'flex';
                voiceModeDiv.style.alignItems = 'center';
                voiceModeDiv.style.gap = '10px';
                voiceModeDiv.style.marginBottom = '10px';

                const voiceModeLabel = document.createElement('label');
                voiceModeLabel.textContent = 'ìŒì„± í•©ì„± ëŒ€ìƒ:';
                voiceModeLabel.style.fontWeight = 'bold';

                const voiceModeSelect = document.createElement('select');
                voiceModeSelect.id = 'voice-synthesis-mode';
                voiceModeSelect.innerHTML = `
                    <option value="subtitle" ${project.voice_synthesis_mode === 'subtitle' ? 'selected' : ''}>ìë§‰ë§Œ</option>
                    <option value="commentary" ${project.voice_synthesis_mode === 'commentary' ? 'selected' : ''}>í•´ì„¤ë§Œ</option>
                    <option value="both" ${project.voice_synthesis_mode === 'both' ? 'selected' : ''}>ìë§‰+í•´ì„¤</option>
                `;
                voiceModeSelect.addEventListener('change', updateVoiceSynthesisMode);

                voiceModeDiv.appendChild(voiceModeLabel);
                voiceModeDiv.appendChild(voiceModeSelect);
                projectActions.appendChild(voiceModeDiv);

                const editBtn = document.createElement('button');
                editBtn.id = 'edit-btn';
                editBtn.className = 'btn-secondary';
                editBtn.textContent = 'í¸ì§‘ ëª¨ë“œë¡œ ëŒì•„ê°€ê¸°';
                editBtn.addEventListener('click', () => {
                    // Reset project status to allow editing
                    fetch(`/api/translator/projects/${currentProject.id}/reset-to-translated`, {
                        method: 'POST'
                    })
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(renderProject)
                    .catch(err => {
                        console.error(err);
                        alert('í¸ì§‘ ëª¨ë“œ ì „í™˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    });
                });
                projectActions.appendChild(editBtn);

                const voiceBtn = document.createElement('button');
                voiceBtn.id = 'voice-btn';
                voiceBtn.className = 'btn-secondary';
                voiceBtn.textContent = 'ìŒì„± ì¬ìƒì„±';
                voiceBtn.addEventListener('click', runVoiceSynthesis);
                projectActions.appendChild(voiceBtn);

                const reverseTranslateAllBtn = document.createElement('button');
                reverseTranslateAllBtn.id = 'reverse-translate-all-btn';
                reverseTranslateAllBtn.className = 'btn-secondary';
                reverseTranslateAllBtn.textContent = 'ì „ì²´ ì—­ë²ˆì—­';
                reverseTranslateAllBtn.addEventListener('click', runReverseTranslateAll);
                projectActions.appendChild(reverseTranslateAllBtn);

                const renderBtn = document.createElement('button');
                renderBtn.id = 'render-btn';
                renderBtn.className = 'btn-primary';
                renderBtn.textContent = 'ë¹„ë””ì˜¤ ë Œë”ë§';
                renderBtn.addEventListener('click', runRender);
                projectActions.appendChild(renderBtn);
            }

            stopComparisonTimeline({ clearHighlight: false });
            renderSegments(project);
            // async í•¨ìˆ˜ì§€ë§Œ await ì—†ì´ ì‹¤í–‰ (Fire and forget)
            updateComparisonTimeline().catch(err => console.error('Failed to update timeline:', err));

            // Update AI commentary section with selected source info
            showAICommentarySection();
        }

        function runTranslation() {
            const btn = document.getElementById('translate-btn');
            btn.disabled = true;
            btn.textContent = 'ë²ˆì—­ ì¤‘...';

            fetch(`/api/translator/projects/${currentProject.id}/translate`, { method: 'POST' })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(renderProject)
                .catch(err => {
                    console.error(err);
                    alert('ë²ˆì—­ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                })
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'ë²ˆì—­ ì‹¤í–‰';
                    }
                });
        }

        function runVoiceSynthesis() {
            const btn = document.getElementById('voice-btn');
            btn.disabled = true;
            btn.textContent = 'ìŒì„± ìƒì„± ì¤‘...';

            fetch(`/api/translator/projects/${currentProject.id}/voice`, { method: 'POST' })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(renderProject)
                .catch(err => {
                    console.error(err);
                    alert('ìŒì„± ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                })
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'ìŒì„± ìƒì„±';
                    }
                });
        }

        function runRender() {
            const btn = document.getElementById('render-btn');
            btn.disabled = true;
            btn.textContent = 'ë Œë”ë§ ì¤‘...';

            fetch(`/api/translator/projects/${currentProject.id}/render`, { method: 'POST' })
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(project => {
                    renderProject(project);
                    const videoPath = project.extra.rendered_video_path;
                    if (videoPath) {
                        const videoLink = document.createElement('a');
                        videoLink.href = videoPath.replace('/home/sk/ws/mcp-playwright', '');
                        videoLink.textContent = 'ë‹¤ìš´ë¡œë“œ';
                        videoLink.target = '_blank';
                        projectActions.appendChild(videoLink);
                    }
                })
                .catch(err => {
                    console.error(err);
                    alert('ë Œë”ë§ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                })
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'ë¹„ë””ì˜¤ ë Œë”ë§';
                    }
                });
        }

    async function saveSegmentText(segmentId, textType, textValue) {
        try {
            const response = await fetch(`/api/translator/projects/${currentProject.id}/segments`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    segment_id: segmentId,
                    text_type: textType,
                    text_value: textValue
                })
            });

            if (response.ok) {
                updateSegmentCache(segmentId, textType, textValue);
                console.log(`Successfully saved ${textType} text for segment ${segmentId}`);
                return true;
            } else {
                console.error('Failed to save segment text:', response.status, response.statusText);
                return false;
            }
        } catch (error) {
            console.error('Error saving segment text:', error);
            return false;
        }
    }

        function loadProject(id) {
            fetch(`/api/translator/projects/${id}`)
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(renderProject)
                .catch(err => {
                    console.error(err);
                    creationView.innerHTML = '<p class="empty-state error">í”„ë¡œì íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>';
                });
        }

        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('id') || urlParams.get('project');
        const viewModeParam = urlParams.get('view') || urlParams.get('mode');
        if (viewModeParam) {
            const normalized = viewModeParam.toLowerCase();
            if (normalized === 'card' || normalized === 'list') {
                isTimelineView = false;
            } else if (normalized === 'timeline') {
                isTimelineView = true;
            }
        }

        function loadInitialSettings() {
            const cacheBuster = Date.now();
            fetch(`/api/translator/settings?_cb=${cacheBuster}`)
                .then(res => {
                    if (res.ok) {
                        return res.json();
                    } else {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                })
                .then(settings => {
                    applySettings(settings);
                })
                .catch(err => {
                    console.error('Failed to load initial settings:', err);
                });
        }

        function attachSegmentEventListeners() {
            // Edit text buttons
            document.querySelectorAll('.btn-edit-text').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const textType = e.target.dataset.type;
                    const textContent = e.target.closest('.text-content');
                    const textDisplay = textContent.querySelector('.text-display');
                    const textEdit = textContent.querySelector('.text-edit');

                    if (e.target.textContent === 'ìˆ˜ì •') {
                        // Enter edit mode
                        textEdit.value = textDisplay.textContent;
                        textDisplay.style.display = 'none';
                        textEdit.style.display = '';
                        textEdit.focus();
                        e.target.textContent = 'ì €ì¥';
                    } else if (e.target.textContent === 'ì €ì¥') {
                        // Save changes
                        const newText = textEdit.value.trim();

                        // ì €ì¥ ì¤‘ í‘œì‹œ
                        const originalText = e.target.textContent;
                        e.target.textContent = 'ì €ì¥ ì¤‘...';
                        e.target.disabled = true;

                        // ì„œë²„ì— ì €ì¥
                        saveSegmentText(segmentId, textType, newText).then(success => {
                            if (success) {
                                textDisplay.textContent = newText;
                                textDisplay.style.display = '';
                                textEdit.style.display = 'none';
                                textEdit.value = newText;
                                e.target.textContent = 'ìˆ˜ì •';

                                // ì €ì¥ ì‹œê°„ í‘œì‹œ
                                const now = new Date();
                                const timeString = now.toLocaleString('ko-KR', {
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit'
                                });
                                const lastModifiedDiv = textContent.querySelector('.last-modified');
                                lastModifiedDiv.textContent = `ë§ˆì§€ë§‰ ì €ì¥: ${timeString}`;
                                lastModifiedDiv.style.color = '#28a745';

                                // ì„±ê³µ í‘œì‹œ
                                const originalColor = e.target.style.backgroundColor;
                                e.target.textContent = 'âœ“ ì €ì¥ì™„ë£Œ';
                                e.target.style.backgroundColor = '#28a745';
                                e.target.style.color = 'white';
                                setTimeout(() => {
                                    e.target.textContent = 'ìˆ˜ì •';
                                    e.target.style.backgroundColor = originalColor;
                                    e.target.style.color = '';
                                    // ì €ì¥ ì‹œê°„ ìƒ‰ìƒì„ ì›ë˜ëŒ€ë¡œ
                                    lastModifiedDiv.style.color = '#888';
                                }, 3000);
                            } else {
                                alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                                e.target.textContent = 'ì €ì¥';
                            }
                            e.target.disabled = false;
                        });
                    }
                });
            });

            // Copy text buttons
            document.querySelectorAll('.btn-copy-text').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const textType = e.target.dataset.type;
                    const textDisplay = e.target.closest('.text-content').querySelector('.text-display');
                    const textToCopy = textDisplay.textContent.trim();

                    if (!textToCopy) {
                        alert('ë³µì‚¬í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }

                    try {
                        await navigator.clipboard.writeText(textToCopy);
                        e.target.textContent = 'ë³µì‚¬ë¨';
                        setTimeout(() => {
                            e.target.textContent = 'ë³µì‚¬';
                        }, 1000);
                    } catch (err) {
                        console.error('í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:', err);
                        // Fallback for older browsers
                        const textarea = document.createElement('textarea');
                        textarea.value = textToCopy;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);

                        e.target.textContent = 'ë³µì‚¬ë¨';
                        setTimeout(() => {
                            e.target.textContent = 'ë³µì‚¬';
                        }, 1000);
                    }
                });
            });

            // Reverse translate buttons (Japanese to Korean)
            document.querySelectorAll('.btn-translate-reverse').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const japaneseText = e.target.closest('.text-content').querySelector('.text-display').textContent.trim();

                    if (!japaneseText) {
                        alert('ë²ˆì—­í•  ì¼ë³¸ì–´ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }

                    e.target.disabled = true;
                    e.target.textContent = 'ë²ˆì—­ì¤‘...';

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/reverse-translate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                segment_id: segmentId,
                                japanese_text: japaneseText
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const result = await response.json();

                        // Update reverse translation Korean text display
                        const segmentItem = e.target.closest('.segment-item');
                        const reverseKoreanTextDisplay = segmentItem.querySelector('.text-row.korean.reverse .text-display');
                        if (reverseKoreanTextDisplay) {
                            reverseKoreanTextDisplay.textContent = result.korean_text;
                            const reverseTextContent = reverseKoreanTextDisplay.closest('.text-content');
                            if (reverseTextContent) {
                                const reverseEdit = reverseTextContent.querySelector('.text-edit');
                                if (reverseEdit) {
                                    reverseEdit.value = result.korean_text;
                                }
                                const reverseLastModified = reverseTextContent.querySelector('.last-modified');
                                if (reverseLastModified) {
                                    const now = new Date();
                                    const timeString = now.toLocaleString('ko-KR', {
                                        month: '2-digit',
                                        day: '2-digit',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                    reverseLastModified.textContent = `ë§ˆì§€ë§‰ ì €ì¥: ${timeString}`;
                                    reverseLastModified.style.color = '#28a745';
                                    setTimeout(() => {
                                        reverseLastModified.style.color = '#888';
                                    }, 3000);
                                }
                            }
                        } else {
                            console.error('Cannot find reverse translation text display element');
                        }

                        // Update the server with the new reverse translated text
                        updateSegmentText(segmentId, 'reverse_translated', result.korean_text);

                    } catch (err) {
                        console.error('ì—­ë²ˆì—­ ì‹¤íŒ¨:', err);
                        alert('ì—­ë²ˆì—­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    } finally {
                        e.target.disabled = false;
                        e.target.textContent = 'ì—­ë²ˆì—­';
                    }
                });
            });

            // Delete text buttons
            document.querySelectorAll('.btn-delete-text').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    const textType = e.target.dataset.type;
                    const label = TEXT_TYPE_LABELS[textType] || 'ì„ íƒí•œ ë‚´ìš©';

                    if (confirm(`ì •ë§ë¡œ "${label}" ë‚´ìš©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                        updateSegmentText(segmentId, textType, '');
                        const textContent = e.target.closest('.text-content');
                        const textDisplay = textContent.querySelector('.text-display');
                        const textEdit = textContent.querySelector('.text-edit');
                        const lastModifiedDiv = textContent.querySelector('.last-modified');
                        textDisplay.textContent = '';
                        if (textEdit) {
                            textEdit.value = '';
                        }
                        if (lastModifiedDiv) {
                            lastModifiedDiv.textContent = '';
                        }
                    }
                });
            });

            // Delete segment buttons
            document.querySelectorAll('.btn-delete-segment').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    if (!segmentId) {
                        return;
                    }
                    if (!confirm('ì´ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        return;
                    }
                    deleteSegment(segmentId, e.target);
                });
            });

            // Move up buttons
            document.querySelectorAll('.btn-move-up').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    moveSegment(segmentId, 'up');
                });
            });

            // Move down buttons
            document.querySelectorAll('.btn-move-down').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    moveSegment(segmentId, 'down');
                });
            });

            // Play audio buttons
            document.querySelectorAll('.btn-play-audio').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const target = e.currentTarget;
                    const segmentId = target.dataset.segmentId;
                    const audioPath = target.dataset.audioPath;

                    if (!audioPath) {
                        alert('ìŒì„± íŒŒì¼ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }

                    playSegmentAudio(segmentId, audioPath);
                });
            });

            // Generate audio buttons
            document.querySelectorAll('.btn-generate-audio').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentId = e.target.dataset.segmentId;
                    if (!segmentId) {
                        return;
                    }

                    const voice = getSelectedVoice();
                    const audioFormat = getSelectedAudioFormat();

                    e.target.disabled = true;
                    const originalText = e.target.textContent;
                    e.target.textContent = 'ìƒì„± ì¤‘...';

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/generate-audio`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                segment_id: segmentId,
                                voice: voice,
                                audio_format: audioFormat
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const project = await response.json();
                        currentProject = project;
                        renderProject(project);
                        alert('ìŒì„± ìƒì„± ì™„ë£Œ!');
                    } catch (err) {
                        console.error('Failed to generate audio:', err);
                        alert('ìŒì„± ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    } finally {
                        e.target.disabled = false;
                        e.target.textContent = originalText;
                    }
                });
            });
        }

        function updateSegmentText(segmentId, textType, newText) {
            const payload = {
                segment_id: segmentId,
                text_type: textType,
                text_value: newText
            };

            fetch(`/api/translator/projects/${currentProject.id}/segments`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                // Update successful
                updateSegmentCache(segmentId, textType, newText);
                console.log(`Updated ${textType} for segment ${segmentId}`);
            })
            .catch(err => {
                console.error('Failed to update segment text:', err);
                alert('í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            });
        }

        function moveSegment(segmentId, direction) {
            const segments = currentProject.segments;
            const currentIndex = segments.findIndex(seg => seg.id === segmentId);

            if (currentIndex === -1) {
                console.error('Segment not found:', segmentId);
                return;
            }

            let newIndex;
            if (direction === 'up' && currentIndex > 0) {
                newIndex = currentIndex - 1;
            } else if (direction === 'down' && currentIndex < segments.length - 1) {
                newIndex = currentIndex + 1;
            } else {
                // Cannot move - already at boundary
                return;
            }

            // Swap segments in the array
            const segmentToMove = segments[currentIndex];
            const segmentAtTarget = segments[newIndex];

            segments[currentIndex] = segmentAtTarget;
            segments[newIndex] = segmentToMove;

            // Update clip_index values to maintain order
            segments.forEach((seg, index) => {
                seg.clip_index = index;
            });

            // Save the reordered segments to the server
            fetch(`/api/translator/projects/${currentProject.id}/reorder-segments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    segment_orders: segments.map((seg, index) => ({
                        segment_id: seg.id,
                        new_index: index
                    }))
                })
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                // Re-render the project to show the new order
                renderProject(currentProject);
            })
            .catch(err => {
                console.error('Failed to reorder segments:', err);
                alert('ì„¸ê·¸ë¨¼íŠ¸ ìˆœì„œ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                // Revert the local changes
                segments[newIndex] = segmentToMove;
                segments[currentIndex] = segmentAtTarget;
            });
        }

        function deleteSegment(segmentId, triggerBtn) {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            if (triggerBtn) {
                triggerBtn.disabled = true;
            }

            selectedSegmentIds.delete(segmentId);
            updateSelectionUI();

            fetch(`/api/translator/projects/${currentProject.id}/segments/${segmentId}`, {
                method: 'DELETE'
            })
                .then(res => res.ok ? res.json() : res.text().then(text => { throw new Error(text || `HTTP ${res.status}`); }))
                .then(project => {
                    renderProject(project);
                })
                .catch(err => {
                    console.error('Failed to delete segment:', err);
                    alert('ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ' + err.message);
                    if (triggerBtn) {
                        triggerBtn.disabled = false;
                    }
                });
        }

        function updateVoiceSynthesisMode() {
            const select = document.getElementById('voice-synthesis-mode');
            const mode = select.value;

            fetch(`/api/translator/projects/${currentProject.id}/voice-synthesis-mode`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ voice_synthesis_mode: mode })
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                console.log(`Voice synthesis mode updated to: ${mode}`);
                currentProject.voice_synthesis_mode = mode;
            })
            .catch(err => {
                console.error('Failed to update voice synthesis mode:', err);
                alert('ìŒì„± í•©ì„± ëª¨ë“œ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                // Revert select to previous value
                select.value = currentProject.voice_synthesis_mode;
            });
        }

        function runReverseTranslateAll() {
            const btn = document.getElementById('reverse-translate-all-btn');
            btn.disabled = true;
            btn.textContent = 'ì „ì²´ ì—­ë²ˆì—­ ì¤‘...';

            let completedCount = 0;
            const totalSegments = currentProject.segments.filter(seg => seg.translated_text).length;

            if (totalSegments === 0) {
                alert('ì—­ë²ˆì—­í•  ì¼ë³¸ì–´ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                btn.disabled = false;
                btn.textContent = 'ì „ì²´ ì—­ë²ˆì—­';
                return;
            }

            // Process each segment with Japanese text
            currentProject.segments.forEach(async (segment, index) => {
                if (!segment.translated_text) return;

                try {
                    const response = await fetch(`/api/translator/projects/${currentProject.id}/reverse-translate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            segment_id: segment.id,
                            japanese_text: segment.translated_text
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();

                        // Update UI
                        const segmentElement = document.querySelector(`[data-segment-id="${segment.id}"]`);
                        if (segmentElement) {
                            const reverseDisplay = segmentElement.querySelector('.text-row.korean.reverse .text-display');
                            if (reverseDisplay) {
                                reverseDisplay.textContent = result.korean_text;
                            }
                        }

                        // Update server
                        updateSegmentText(segment.id, 'reverse_translated', result.korean_text);
                    }
                } catch (err) {
                    console.error(`Failed to reverse translate segment ${segment.id}:`, err);
                }

                completedCount++;
                if (completedCount === totalSegments) {
                    btn.disabled = false;
                    btn.textContent = 'ì „ì²´ ì—­ë²ˆì—­';
                    alert(`ì „ì²´ ì—­ë²ˆì—­ ì™„ë£Œ! (${completedCount}ê°œ ì„¸ê·¸ë¨¼íŠ¸)`);
                }
            });
        }

        function showAICommentarySection() {
            const aiCommentarySection = document.getElementById('ai-commentary-section');
            const translationSettingsSection = document.getElementById('translation-settings-section');

            // Show AI commentary section
            aiCommentarySection.style.display = 'block';

            // Keep translation settings section visible
            translationSettingsSection.style.display = 'block';

            // Update selected source info if selectedSource is available
            const videoNameElem = document.getElementById('selected-video-name');
            const subtitleNameElem = document.getElementById('selected-subtitle-name');

            const fallbackVideoPath = (selectedSource && selectedSource.video_path) || (currentProject && currentProject.source_video) || null;
            const fallbackSubtitlePath = (selectedSource && selectedSource.subtitle_path) || (currentProject && currentProject.source_subtitle) || null;

            if (!selectedSource && (fallbackVideoPath || fallbackSubtitlePath) && currentProject) {
                selectedSource = {
                    video_path: fallbackVideoPath,
                    subtitle_path: fallbackSubtitlePath,
                    base_name: currentProject.base_name,
                    video_name: extractFileName(fallbackVideoPath),
                    subtitle_name: extractFileName(fallbackSubtitlePath)
                };
            }

            const videoLabel = extractFileName(fallbackVideoPath) || (currentProject && currentProject.base_name) || 'ì„ íƒë˜ì§€ ì•ŠìŒ';
            const subtitleLabel = fallbackSubtitlePath ? extractFileName(fallbackSubtitlePath) : 'ìë§‰ ì—†ìŒ';

            videoNameElem.textContent = videoLabel;
            subtitleNameElem.textContent = subtitleLabel;

            // Scroll to AI commentary section with a slight delay for better UX
            setTimeout(() => {
                aiCommentarySection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }, 100);
        }

        // Make function globally accessible for debugging
        window.showAICommentarySection = showAICommentarySection;

        function showTranslationSettings() {
            const translationSettingsSection = document.getElementById('translation-settings-section');
            translationSettingsSection.style.display = 'block';

            // Scroll to translation settings
            translationSettingsSection.scrollIntoView({ behavior: 'smooth' });
        }

        async function generateAICommentary() {
            if (!selectedSource) {
                alert('ì†ŒìŠ¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const generateBtn = document.getElementById('generate-commentary-btn');
            const skipBtn = document.getElementById('skip-commentary-btn');
            const statusDiv = document.getElementById('commentary-generation-status');

            // Disable buttons and show status
            generateBtn.disabled = true;
            skipBtn.disabled = true;
            generateBtn.textContent = 'AI í•´ì„¤ ìƒì„± ì¤‘...';
            statusDiv.style.display = 'block';

            try {
                // First create the project
                const projectData = {
                    source_video: selectedSource.video_path,
                    source_subtitle: selectedSource.subtitle_path || null,
                    target_lang: 'ja',
                    translation_mode: 'literal',
                    tone_hint: 'ê°„ê²°í•˜ê²Œ'
                };

                const createResponse = await fetch('/api/translator/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectData)
                });

                if (!createResponse.ok) {
                    throw new Error(`í”„ë¡œì íŠ¸ ìƒì„± ì‹¤íŒ¨: ${createResponse.status}`);
                }

                const project = await createResponse.json();

                // Then generate AI commentary
                const commentaryResponse = await fetch(`/api/translator/projects/${project.id}/generate-commentary`, {
                    method: 'POST'
                });

                if (!commentaryResponse.ok) {
                    throw new Error(`AI í•´ì„¤ ìƒì„± ì‹¤íŒ¨: ${commentaryResponse.status}`);
                }

                const updatedProject = await commentaryResponse.json();

                // Load the project in the UI
                renderProject(updatedProject);

            } catch (error) {
                console.error('AI í•´ì„¤ ìƒì„± ì˜¤ë¥˜:', error);
                alert(`AI í•´ì„¤ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);

                // Re-enable buttons
                generateBtn.disabled = false;
                skipBtn.disabled = false;
                generateBtn.textContent = 'AI í•´ì„¤ ìƒì„±í•˜ê¸°';
                statusDiv.style.display = 'none';
            }
        }

        function skipAICommentary() {
            showTranslationSettings();
        }

        async function generateKoreanCommentary() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const btn = document.getElementById('korean-commentary-btn');
            btn.disabled = true;
            btn.textContent = 'í•œêµ­ì–´ AI í•´ì„¤ ìƒì„± ì¤‘...';

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/generate-korean-commentary`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response details:', {
                        status: response.status,
                        statusText: response.statusText,
                        url: response.url,
                        body: errorText
                    });
                    throw new Error(`í•œêµ­ì–´ AI í•´ì„¤ ìƒì„± ì‹¤íŒ¨: ${response.status} - ${response.statusText} - ${errorText}`);
                }

                const updatedProject = await response.json();

                // Update current project and re-render
                renderProject(updatedProject);

                alert('í•œêµ­ì–´ AI í•´ì„¤ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');

            } catch (error) {
                console.error('í•œêµ­ì–´ í•´ì„¤ ìƒì„± ì˜¤ë¥˜:', error);
                alert(`í•œêµ­ì–´ AI í•´ì„¤ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'í•œêµ­ì–´ AI í•´ì„¤ ë„£ê¸°';
                }
            }
        }

        async function saveProject() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const saveBtn = document.getElementById('save-project-btn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'ğŸ’¾ ì €ì¥ ì¤‘...';
            }

            try {
                // í˜„ì¬ í”„ë¡œì íŠ¸ ìƒíƒœë¥¼ ì„œë²„ì— ì €ì¥ (ì´ë¯¸ ê° ìˆ˜ì • ì‹œ ì €ì¥ë˜ë¯€ë¡œ í™•ì¸ ë©”ì‹œì§€ë§Œ í‘œì‹œ)
                const response = await fetch(`/api/translator/projects/${currentProject.id}`);
                if (response.ok) {
                    alert('âœ… í”„ë¡œì íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                } else {
                    throw new Error('í”„ë¡œì íŠ¸ ì €ì¥ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('Save project error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'ğŸ’¾ ì €ì¥';
                }
            }
        }

        async function saveProjectAs() {
            if (!currentProject) {
                alert('í”„ë¡œì íŠ¸ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const newName = prompt('ìƒˆ í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', currentProject.base_name + '_ë³µì‚¬ë³¸');
            if (!newName || newName.trim() === '') {
                return;
            }

            const saveAsBtn = document.getElementById('save-as-project-btn');
            if (saveAsBtn) {
                saveAsBtn.disabled = true;
                saveAsBtn.textContent = 'ğŸ’¾ ì €ì¥ ì¤‘...';
            }

            try {
                const response = await fetch(`/api/translator/projects/${currentProject.id}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_name: newName.trim() })
                });

                if (response.ok) {
                    const newProject = await response.json();
                    alert(`âœ… í”„ë¡œì íŠ¸ê°€ "${newProject.base_name}"ë¡œ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);

                    // ìƒˆ í”„ë¡œì íŠ¸ë¡œ ì´ë™í• ì§€ ë¬¼ì–´ë³´ê¸°
                    if (confirm('ë³µì‚¬ëœ í”„ë¡œì íŠ¸ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        window.location.href = `/translator?id=${newProject.id}`;
                    }
                } else {
                    throw new Error('í”„ë¡œì íŠ¸ ë³µì‚¬ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('Save project as error:', error);
                alert('âŒ í”„ë¡œì íŠ¸ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                if (saveAsBtn) {
                    saveAsBtn.disabled = false;
                    saveAsBtn.textContent = 'ğŸ’¾ ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥';
                }
            }
        }

        function deleteProject() {
            if (!confirm('ì •ë§ë¡œ ì´ í”„ë¡œì íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
                return;
            }

            const deleteBtn = document.getElementById('delete-project-btn');
            deleteBtn.disabled = true;
            deleteBtn.textContent = 'ì‚­ì œ ì¤‘...';

            fetch(`/api/translator/projects/${currentProject.id}`, {
                method: 'DELETE'
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.json();
            })
            .then(() => {
                alert('í”„ë¡œì íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                window.location.href = '/translator';
            })
            .catch(err => {
                console.error('Failed to delete project:', err);
                alert('í”„ë¡œì íŠ¸ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            })
            .finally(() => {
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = 'í”„ë¡œì íŠ¸ ì‚­ì œ';
                }
            });
        }

        function attachTimeEditListeners() {
            // Time display click to edit
            document.querySelectorAll('.time-display').forEach(timeDisplay => {
                timeDisplay.addEventListener('click', () => {
                    const segmentTimeDiv = timeDisplay.closest('.segment-time');
                    if (!segmentTimeDiv) {
                        return;
                    }
                    const timeEdit = segmentTimeDiv.querySelector('.time-edit');
                    if (!timeEdit) {
                        return;
                    }

                    // Hide display, show edit
                    timeDisplay.style.display = 'none';
                    timeEdit.style.display = 'flex';

                    // Focus on first input
                    const startInput = timeEdit.querySelector('.start-input');
                    if (startInput) {
                        startInput.focus();
                        startInput.select();
                    }
                });
            });

            // Save time button
            document.querySelectorAll('.btn-save-time').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const segmentTimeDiv = e.target.closest('.segment-time');
                    const segmentId = segmentTimeDiv.dataset.segmentId;
                    const timeDisplay = segmentTimeDiv.querySelector('.time-display');
                    const timeEdit = segmentTimeDiv.querySelector('.time-edit');
                    if (!timeDisplay || !timeEdit) {
                        return;
                    }

                    const startInput = timeEdit.querySelector('.start-input');
                    const endInput = timeEdit.querySelector('.end-input');

                    const startTime = parseFloat(startInput.value);
                    const endTime = parseFloat(endInput.value);

                    // Validation
                    if (Number.isNaN(startTime) || Number.isNaN(endTime)) {
                        alert('ì‹œê°„ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                        return;
                    }

                    if (startTime >= endTime) {
                        alert('ì‹œì‘ ì‹œê°„ì€ ì¢…ë£Œ ì‹œê°„ë³´ë‹¤ ì‘ì•„ì•¼ í•©ë‹ˆë‹¤.');
                        return;
                    }

                    if (startTime < 0 || endTime < 0) {
                        alert('ì‹œê°„ì€ 0ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤.');
                        return;
                    }

                    // Save to server
                    btn.disabled = true;
                    const originalText = btn.textContent;
                    btn.textContent = 'ì €ì¥ ì¤‘...';

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/segments/time`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                segment_id: segmentId,
                                start_time: startTime,
                                end_time: endTime
                            })
                        });

                        if (response.ok) {
                            // Update display
                            const startLabel = timeDisplay.querySelector('.start-time');
                            const endLabel = timeDisplay.querySelector('.end-time');
                            const durationLabel = timeDisplay.querySelector('.time-duration');

                            if (startLabel) {
                                startLabel.textContent = formatTimestamp(startTime);
                            }
                            if (endLabel) {
                                endLabel.textContent = formatTimestamp(endTime);
                            }
                            if (durationLabel) {
                                durationLabel.textContent = `(${Math.max(endTime - startTime, 0).toFixed(1)}ì´ˆ)`;
                            }

                            timeEdit.style.display = 'none';
                            timeDisplay.style.display = 'flex';

                            // Success feedback
                            btn.textContent = 'âœ“';
                            btn.style.background = '#28a745';
                            setTimeout(() => {
                                btn.textContent = originalText || 'ì €ì¥';
                                btn.style.background = '';
                            }, 1500);
                        } else {
                            throw new Error('ì„œë²„ ì €ì¥ ì‹¤íŒ¨');
                        }
                    } catch (error) {
                        console.error('Time save error:', error);
                        alert('ì‹œê°„ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    } finally {
                        btn.disabled = false;
                        if (btn.textContent === 'ì €ì¥ ì¤‘...') {
                            btn.textContent = originalText || 'ì €ì¥';
                        }
                    }
                });
            });

            // Cancel time edit button
            document.querySelectorAll('.btn-cancel-time').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const segmentTimeDiv = e.target.closest('.segment-time');
                    const timeDisplay = segmentTimeDiv.querySelector('.time-display');
                    const timeEdit = segmentTimeDiv.querySelector('.time-edit');

                    // Reset inputs to original values
                    const segmentId = segmentTimeDiv.dataset.segmentId;
                    const segment = currentProject.segments.find(s => s.id === segmentId);
                    if (segment) {
                        timeEdit.querySelector('.start-input').value = segment.start.toFixed(2);
                        timeEdit.querySelector('.end-input').value = segment.end.toFixed(2);
                    }

                    // Hide edit, show display
                    timeEdit.style.display = 'none';
                    timeDisplay.style.display = 'flex';
                });
            });
        }

        if (openSourceSelectorBtn) {
            openSourceSelectorBtn.addEventListener('click', openSourceSelectorModal);
        }
        if (sourceSelectorCloseBtn) {
            sourceSelectorCloseBtn.addEventListener('click', closeSourceSelectorModal);
        }
        if (sourceSelectorCancelBtn) {
            sourceSelectorCancelBtn.addEventListener('click', closeSourceSelectorModal);
        }
        if (sourceSelectorApplyBtn) {
            sourceSelectorApplyBtn.addEventListener('click', applySourceSelection);
        }
        if (sourceSelectorModal) {
            sourceSelectorModal.addEventListener('click', (event) => {
                if (event.target === sourceSelectorModal) {
                    closeSourceSelectorModal();
                }
            });
        }
        if (sourceSelectorTabs) {
            sourceSelectorTabs.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const mode = tab.dataset.mode;
                    if (mode) {
                        switchSourceSelectorMode(mode);
                    }
                });
            });
        }
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && sourceSelectorModal && !sourceSelectorModal.classList.contains('hidden')) {
                closeSourceSelectorModal();
            }
        });

        // Add event listeners for AI commentary buttons
        document.getElementById('generate-commentary-btn').addEventListener('click', generateAICommentary);
        document.getElementById('skip-commentary-btn').addEventListener('click', skipAICommentary);

        if (projectId) {
            loadProject(projectId);
        } else {
            creationView.classList.remove('hidden');
            projectView.classList.add('hidden');
            fetchDownloads();
            loadInitialSettings();

            // Show AI commentary section on initial load
            showAICommentarySection();
        }

        const videoAnalysisBtn = document.getElementById('btn-open-videoanalysis');
        if (videoAnalysisBtn && !videoAnalysisBtn.dataset.bound) {
            videoAnalysisBtn.dataset.bound = '1';
            videoAnalysisBtn.addEventListener('click', () => {
                let targetUrl = 'http://127.0.0.1:8002/';
                const projectFolderId = (currentProject && currentProject.id) || projectId || selectedProjectId;
                if (projectFolderId) {
                    const projectPath = `ai_shorts_maker/outputs/translator_projects/${projectFolderId}`;
                    targetUrl += `?path=${encodeURIComponent(projectPath)}`;
                }
                window.open(targetUrl, '_blank');
            });
        }

        // === íŠ¸ë™ ì²˜ë¦¬ ê¸°ëŠ¥ ===
        function attachTrackProcessingEventListeners() {
            bgmVolumeRangeInput = document.getElementById('bgm-volume-range');
            bgmVolumeValueLabel = document.getElementById('bgm-volume-value');
            bgmVolumeApplyButton = document.getElementById('btn-bgm-apply-volume');
            bgmTrimToggleButton = document.getElementById('btn-bgm-trim-mode');
            bgmTrimDeleteButton = document.getElementById('btn-bgm-trim-delete');
            bgmV2VolumeRangeInput = document.getElementById('bgm-v2-volume-range');
            bgmV2VolumeValueLabel = document.getElementById('bgm-v2-volume-value');
            bgmV2VolumeApplyButton = document.getElementById('btn-bgm-v2-apply-volume');
            bgmV2TrimToggleButton = document.getElementById('btn-bgm-v2-trim-mode');
            bgmV2TrimDeleteButton = document.getElementById('btn-bgm-v2-trim-delete');
            bgmV2SaveCopyButton = document.getElementById('btn-bgm-v2-save-copy');
            bgmV2DuckToggleButton = document.getElementById('btn-bgm-v2-duck-toggle');
            bgmV2PlaybackTimeLabel = document.getElementById('bgm-v2-playback-time');
            bgmV2JumpButton = document.getElementById('btn-bgm-v2-jump-end');

            if (bgmVolumeRangeInput && !bgmVolumeRangeInput.dataset.bound) {
                bgmVolumeRangeInput.dataset.bound = '1';
                bgmVolumeRangeInput.addEventListener('input', (event) => {
                    applyBgmPlaybackVolume(event.target.value);
                });
                bgmVolumeRangeInput.addEventListener('change', (event) => {
                    applyBgmPlaybackVolume(event.target.value);
                });
            }
            if (bgmV2VolumeRangeInput && !bgmV2VolumeRangeInput.dataset.bound) {
                bgmV2VolumeRangeInput.dataset.bound = '1';
                const handleV2Slider = (event) => {
                    const value = event?.target?.value ?? bgmV2VolumeRangeInput.value;
                    applyBgmV2PlaybackVolume(Number(value));
                    updateBgmV2VolumeLabel(Number(value));
                };
                bgmV2VolumeRangeInput.addEventListener('input', handleV2Slider);
                bgmV2VolumeRangeInput.addEventListener('change', handleV2Slider);
            }
            if (bgmVolumeApplyButton && !bgmVolumeApplyButton.dataset.bound) {
                bgmVolumeApplyButton.dataset.bound = '1';
                bgmVolumeApplyButton.addEventListener('click', () => {
                    commitBgmVolume().catch((error) => console.error('Failed to commit BGM volume:', error));
                });
            }
            if (bgmV2VolumeApplyButton && !bgmV2VolumeApplyButton.dataset.bound) {
                bgmV2VolumeApplyButton.dataset.bound = '1';
                bgmV2VolumeApplyButton.addEventListener('click', () => {
                    commitBgmV2Volume().catch((error) => console.error('Failed to commit BGM V2 volume:', error));
                });
            }

            if (bgmV2TrimToggleButton && !bgmV2TrimToggleButton.dataset.bound) {
                bgmV2TrimToggleButton.dataset.bound = '1';
                bgmV2TrimToggleButton.addEventListener('click', () => {
                    if (!window.bgmV2TimelineWaveform || !bgmV2RegionsPlugin) {
                        alert('ë°°ê²½ìŒì•… V2 íŠ¸ë™ì´ ì¤€ë¹„ëœ í›„ì— ì‚¬ìš©í•´ ì£¼ì„¸ìš”.');
                        return;
                    }
                    setBgmV2TrimMode(!bgmV2TrimMode);
                });
            }

            if (bgmV2TrimDeleteButton && !bgmV2TrimDeleteButton.dataset.bound) {
                bgmV2TrimDeleteButton.dataset.bound = '1';
                bgmV2TrimDeleteButton.addEventListener('click', () => {
                    deleteSelectedBgmV2Region().catch((error) => console.error('Failed to delete BGM V2 region:', error));
                });
            }

            if (bgmV2JumpButton && !bgmV2JumpButton.dataset.bound) {
                bgmV2JumpButton.dataset.bound = '1';
                bgmV2JumpButton.addEventListener('click', jumpBgmV2ToBase);
            }

            if (bgmV2SaveCopyButton && !bgmV2SaveCopyButton.dataset.bound) {
                bgmV2SaveCopyButton.dataset.bound = '1';
                bgmV2SaveCopyButton.addEventListener('click', () => {
                    saveCurrentBgmV2As().catch((error) => console.error('Failed to save BGM V2 copy:', error));
                });
            }

            if (bgmV2DuckToggleButton && !bgmV2DuckToggleButton.dataset.bound) {
                bgmV2DuckToggleButton.dataset.bound = '1';
                bgmV2DuckToggleButton.addEventListener('click', toggleBgmV2AutoDuck);
            }

            updateBgmVolumeUI(Boolean(window.bgmTimelineWaveform));
            updateBgmV2VolumeUI(Boolean(window.bgmV2TimelineWaveform));
            updateBgmV2JumpButtonState();
            updateBgmV2DuckButtonState();

            // Vocal/ë°°ê²½ìŒì•… ë¶„ë¦¬
            const btnSeparateVocal = document.getElementById('btn-separate-vocal');
            if (btnSeparateVocal) {
                btnSeparateVocal.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    btnSeparateVocal.disabled = true;

                    // ì§„í–‰ìœ¨ í‘œì‹œ ì• ë‹ˆë©”ì´ì…˜
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress = Math.min(progress + Math.random() * 15, 95);
                        btnSeparateVocal.textContent = `ğŸ”„ ë¶„ë¦¬ ì¤‘... ${Math.floor(progress)}%`;
                    }, 500);

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/separate-vocal`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });

                        clearInterval(progressInterval);

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'ë¶„ë¦¬ ì‹¤íŒ¨');
                        }

                        const result = await response.json();
                        console.log('Vocal separation result:', result);

                        if (!currentProject.extra) {
                            currentProject.extra = {};
                        }
                        currentProject.extra.bgm_path = result.bgm_path;
                        currentProject.extra.bgm_volume_percent = 100;
                        currentProject.extra.bgm_cache_token = Date.now();
                        setBgmTrack(result.bgm_path, {
                            volumePercent: 100,
                            cacheToken: currentProject.extra.bgm_cache_token,
                            force: true,
                        });

                        btnSeparateVocal.textContent = 'ğŸ”„ ì™„ë£Œ 100%';
                        setTimeout(() => {
                            alert(result.message || 'Vocalê³¼ ë°°ê²½ìŒì•… ë¶„ë¦¬ ì™„ë£Œ');
                        }, 300);
                    } catch (error) {
                        clearInterval(progressInterval);
                        console.error('Vocal separation error:', error);
                        alert(`ë¶„ë¦¬ ì‹¤íŒ¨: ${error.message}`);
                    } finally {
                        btnSeparateVocal.disabled = false;
                        setTimeout(() => {
                            btnSeparateVocal.textContent = 'ğŸµ ë¶„ë¦¬';
                        }, 1000);
                    }
                });
            }

            // ìŒì„±ëŒ€ì‚¬ ì¶”ì¶œ
            const btnExtractDialogue = document.getElementById('btn-extract-dialogue');
            if (btnExtractDialogue) {
                btnExtractDialogue.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    btnExtractDialogue.disabled = true;

                    // ì§„í–‰ìœ¨ í‘œì‹œ ì• ë‹ˆë©”ì´ì…˜
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress = Math.min(progress + Math.random() * 15, 95);
                        btnExtractDialogue.textContent = `ğŸ”„ ì¶”ì¶œ ì¤‘... ${Math.floor(progress)}%`;
                    }, 500);

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/extract-dialogue`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });

                        clearInterval(progressInterval);

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'ì¶”ì¶œ ì‹¤íŒ¨');
                        }

                        const result = await response.json();
                        console.log('Dialogue extraction result:', result);

                        // ëŒ€ì‚¬ íŠ¸ë™ í‘œì‹œ
                        const dialogueTrack = document.getElementById('timeline-track-dialogue');
                        if (dialogueTrack && result.dialogue_path) {
                            dialogueTrack.style.display = 'block';

                            // WaveSurferë¡œ ëŒ€ì‚¬ íŒŒí˜• í‘œì‹œ
                            const dialogueWaveformContainer = document.getElementById('timeline-dialogue-waveform');
                            if (dialogueWaveformContainer && typeof WaveSurfer !== 'undefined') {
                                dialogueWaveformContainer.innerHTML = '';
                                const dialogueWaveform = WaveSurfer.create({
                                    container: '#timeline-dialogue-waveform',
                                    height: 90,
                                    waveColor: '#6ee7b7',
                                    progressColor: '#34d399',
                                    cursorColor: '#ffd166',
                                    normalize: true,
                                    responsive: true
                                });
                                const dialogueUrl = toWebAudioPath(result.dialogue_path);
                                console.log('Loading dialogue track:', dialogueUrl);
                                dialogueWaveform.on('error', (err) => {
                                    console.error('Dialogue waveform load error:', err);
                                });
                                dialogueWaveform.load(dialogueUrl);
                                dialogueWaveform.on('ready', () => {
                                    const duration = dialogueWaveform.getDuration();
                                    const durationElem = document.getElementById('timeline-dialogue-duration');
                                    if (durationElem) {
                                        durationElem.textContent = formatDuration(duration);
                                    }
                                });
                                window.dialogueTimelineWaveform = dialogueWaveform;
                                window.dialogueTimelineUrl = dialogueUrl;
                            }
                        }

                        btnExtractDialogue.textContent = 'ğŸ”„ ì™„ë£Œ 100%';
                        setTimeout(() => {
                            alert(result.message || 'ëŒ€ì‚¬ ì¶”ì¶œ ì™„ë£Œ');
                        }, 300);
                    } catch (error) {
                        clearInterval(progressInterval);
                        console.error('Dialogue extraction error:', error);
                        alert(`ì¶”ì¶œ ì‹¤íŒ¨: ${error.message}`);
                    } finally {
                        btnExtractDialogue.disabled = false;
                        setTimeout(() => {
                            btnExtractDialogue.textContent = 'ğŸ—£ï¸ ëŒ€ì‚¬ì¶”ì¶œ';
                        }, 1000);
                    }
                });
            }

            const btnExtractDialogueMuted = document.getElementById('btn-extract-dialogue-muted');
            if (btnExtractDialogueMuted) {
                btnExtractDialogueMuted.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    btnExtractDialogueMuted.disabled = true;

                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress = Math.min(progress + Math.random() * 15, 95);
                        btnExtractDialogueMuted.textContent = `ğŸ”„ ë²ˆì—­ ì œì™¸... ${Math.floor(progress)}%`;
                    }, 500);

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/extract-dialogue-muted`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });

                        clearInterval(progressInterval);

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'ì¶”ì¶œ ì‹¤íŒ¨');
                        }

                        const result = await response.json();
                        console.log('Dialogue-muted extraction result:', result);

                        const dialogueTrack = document.getElementById('timeline-track-dialogue-muted');
                        if (dialogueTrack && result.dialogue_path) {
                            dialogueTrack.style.display = 'block';

                            const waveformContainer = document.getElementById('timeline-dialogue-muted-waveform');
                            if (waveformContainer && typeof WaveSurfer !== 'undefined') {
                                waveformContainer.innerHTML = '';
                                const waveform = WaveSurfer.create({
                                    container: '#timeline-dialogue-muted-waveform',
                                    height: 90,
                                    waveColor: '#fda4af',
                                    progressColor: '#fb7185',
                                    cursorColor: '#ffd166',
                                    normalize: true,
                                    responsive: true
                                });
                                const dialogueUrlRaw = toWebAudioPath(result.dialogue_path);
                                const dialogueUrl = `${dialogueUrlRaw}?t=${Date.now()}`;
                                console.log('Loading dialogue-muted track:', dialogueUrl);
                                waveform.on('error', (err) => {
                                    console.error('Dialogue-muted waveform load error:', err);
                                });
                                waveform.load(dialogueUrl);
                                waveform.on('ready', () => {
                                    const duration = waveform.getDuration();
                                    const durationElem = document.getElementById('timeline-dialogue-muted-duration');
                                    if (durationElem) {
                                        durationElem.textContent = formatDuration(duration);
                                    }
                                });
                                waveform.on('audioprocess', (time) => handleTimelineTimeUpdate('dialogue-muted', time));
                                waveform.on('finish', () => handleTimelineFinish('dialogue-muted'));

                                window.dialogueMutedTimelineWaveform = waveform;
                                window.dialogueMutedTimelineUrl = dialogueUrlRaw;
                            }
                        }

                        if (!currentProject.extra) {
                            currentProject.extra = {};
                        }
                        currentProject.extra.dialogue_muted_path = result.dialogue_path;
                        try {
                            await fetch(`/api/translator/projects/${currentProject.id}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ extra: currentProject.extra })
                            });
                        } catch (patchError) {
                            console.warn('Failed to persist dialogue-muted path:', patchError);
                        }

                        btnExtractDialogueMuted.textContent = 'ğŸ—£ï¸ ë²ˆì—­ ì œì™¸ ì™„ë£Œ';
                        setTimeout(() => {
                            alert(result.message || 'ë²ˆì—­ ìŒì„±ì„ ì œì™¸í•œ ëŒ€ì‚¬ ì¶”ì¶œì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                        }, 300);
                    } catch (error) {
                        clearInterval(progressInterval);
                        console.error('Dialogue-muted extraction error:', error);
                        alert(`ì¶”ì¶œ ì‹¤íŒ¨: ${error.message}`);
                    } finally {
                        btnExtractDialogueMuted.disabled = false;
                        setTimeout(() => {
                            btnExtractDialogueMuted.textContent = 'ğŸ—£ï¸ ë²ˆì—­ ì œì™¸';
                        }, 1000);
                    }
                });
            }

            // ì²´í¬í•œ íŠ¸ë™ í•©ì¹˜ê¸°
            const btnMergeChecked = document.getElementById('timeline-merge-checked-btn');
            if (btnMergeChecked) {
                btnMergeChecked.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    // ì²´í¬ëœ íŠ¸ë™ ì°¾ê¸°
                    const trackDefs = [
                        { id: 'track-checkbox-bgm-v2', waveform: window.bgmV2TimelineWaveform, url: window.bgmV2TimelineUrl, role: 'bgm_v2' },
                        { id: 'track-checkbox-bgm', waveform: window.bgmTimelineWaveform, url: window.bgmTimelineUrl, role: 'bgm' },
                        { id: 'track-checkbox-original', waveform: originalTimelineWaveform, url: originalTimelineUrl, role: 'original' },
                        { id: 'track-checkbox-dialogue-muted', waveform: window.dialogueMutedTimelineWaveform, url: window.dialogueMutedTimelineUrl, role: 'dialogue_muted' },
                        { id: 'track-checkbox-dialogue', waveform: window.dialogueTimelineWaveform, url: window.dialogueTimelineUrl, role: 'dialogue' },
                        { id: 'track-checkbox-translated', waveform: translatedTimelineWaveform, url: translatedTimelineUrl, role: 'translated' }
                    ];

                    const selectedTrackItems = [];
                    for (const def of trackDefs) {
                        const checkbox = document.getElementById(def.id);
                        if (checkbox && checkbox.checked && def.url) {
                            selectedTrackItems.push({ path: def.url, role: def.role });
                        }
                    }

                    if (selectedTrackItems.length === 0) {
                        alert('í•©ì¹  íŠ¸ë™ì„ ì„ íƒí•˜ì„¸ìš” (ì²´í¬ë°•ìŠ¤ ì„ íƒ)');
                        return;
                    }

                    selectedTrackItems.sort((a, b) => {
                        const rank = role => {
                            switch (role) {
                                case 'bgm_v2': return 0;
                                case 'bgm': return 1;
                                case 'dialogue':
                                case 'dialogue_muted':
                                case 'translated': return 2;
                                default: return 3;
                            }
                        };
                        return rank(a.role) - rank(b.role);
                    });

                    btnMergeChecked.disabled = true;
                    let mergeProgress = 0;
                    btnMergeChecked.textContent = `ğŸ”„ í•©ì¹˜ëŠ” ì¤‘... ${mergeProgress}%`;
                    const mergeInterval = setInterval(() => {
                        mergeProgress = Math.min(mergeProgress + 12, 95);
                        btnMergeChecked.textContent = `ğŸ”„ í•©ì¹˜ëŠ” ì¤‘... ${mergeProgress}%`;
                    }, 350);

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/merge-tracks`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                tracks: selectedTrackItems,
                                auto_duck: Boolean(bgmV2AutoDuckEnabled),
                                duck_ratio: BGM_V2_DUCK_RATIO
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'í•©ì¹˜ê¸° ì‹¤íŒ¨');
                        }

                        const result = await response.json();
                        console.log('Merge result:', result);

                        const mergedPath = result.merged_path || '';
                        const mergedName = result.merged_filename || (mergedPath ? mergedPath.split('/').pop() : 'merged_tracks.wav');

                        alert((result.message || 'íŠ¸ë™ í•©ì¹˜ê¸° ì™„ë£Œ') + (mergedPath ? `\nì €ì¥ ìœ„ì¹˜: ${mergedPath}` : ''));

                        if (mergedPath) {
                            const projectPath = `ai_shorts_maker/outputs/translator_projects/${currentProject.id}`;
                            const explorerUrl = `http://127.0.0.1:8002/?path=${encodeURIComponent(projectPath)}`;
                            console.log('Opening file explorer:', explorerUrl);
                            window.open(explorerUrl, '_blank');
                        }

                        mergeProgress = 100;
                        btnMergeChecked.textContent = `âœ… í•©ì¹˜ê¸° ì™„ë£Œ (100%)`;
                    } catch (error) {
                        console.error('Track merge error:', error);
                        alert(`í•©ì¹˜ê¸° ì‹¤íŒ¨: ${error.message}`);
                    } finally {
                        clearInterval(mergeInterval);
                        btnMergeChecked.disabled = false;
                        setTimeout(() => {
                            btnMergeChecked.textContent = 'ğŸ”€ ì²´í¬í•œ íŠ¸ë™ í•©ì¹˜ê¸°';
                        }, 1200);
                    }
                });
            }

            // íŠ¸ë™ ì €ì¥ ê¸°ëŠ¥
            const btnSaveTracks = document.getElementById('btn-save-tracks');
            if (btnSaveTracks) {
                btnSaveTracks.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    // í˜„ì¬ íŠ¸ë™ ìƒíƒœ ìˆ˜ì§‘
                    const trackState = {
                        bgm_path: resolveTrackStatePath(window.bgmTimelineUrl, currentProject?.extra?.bgm_path),
                        bgm_volume_percent: Number.isFinite(bgmPlaybackVolume)
                            ? Math.round(bgmPlaybackVolume * 100)
                            : (currentProject?.extra?.bgm_volume_percent ?? 100),
                        bgm_v2_path: resolveTrackStatePath(
                            window.bgmV2TimelineUrl,
                            currentProject?.extra?.bgm_v2_path,
                            currentProject?.extra?.bgm_custom_v2_path
                        ),
                        bgm_v2_volume_percent: Number.isFinite(bgmV2PlaybackVolume)
                            ? Math.round(bgmV2PlaybackVolume * 100)
                            : (currentProject?.extra?.bgm_v2_volume_percent ?? 100),
                        bgm_v2_auto_duck: Boolean(bgmV2AutoDuckEnabled),
                        dialogue_path: resolveTrackStatePath(window.dialogueTimelineUrl, currentProject?.extra?.dialogue_path),
                        dialogue_muted_path: resolveTrackStatePath(window.dialogueMutedTimelineUrl, currentProject?.extra?.dialogue_muted_path)
                    };

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/save-tracks`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(trackState)
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'ì €ì¥ ì‹¤íŒ¨');
                        }

                        const result = await response.json();

                        if (!currentProject.extra) {
                            currentProject.extra = {};
                        }
                        currentProject.extra.bgm_path = trackState.bgm_path || null;
                        currentProject.extra.dialogue_path = trackState.dialogue_path || null;
                        currentProject.extra.dialogue_muted_path = trackState.dialogue_muted_path || null;
                        currentProject.extra.bgm_volume_percent = trackState.bgm_volume_percent;
                        currentProject.extra.bgm_cache_token = result.bgm_cache_token || currentProject.extra.bgm_cache_token;
                        currentProject.extra.bgm_v2_path = trackState.bgm_v2_path || null;
                        if (trackState.bgm_v2_path) {
                            currentProject.extra.bgm_custom_v2_path = trackState.bgm_v2_path;
                        } else {
                            delete currentProject.extra.bgm_custom_v2_path;
                        }
                        currentProject.extra.bgm_v2_volume_percent = trackState.bgm_v2_volume_percent;
                        currentProject.extra.bgm_v2_cache_token = result.bgm_v2_cache_token || currentProject.extra.bgm_v2_cache_token;
                        currentProject.extra.bgm_v2_auto_duck = trackState.bgm_v2_auto_duck;

                        alert(result.message || 'íŠ¸ë™ ìƒíƒœê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } catch (error) {
                        console.error('Track save error:', error);
                        alert(`ì €ì¥ ì‹¤íŒ¨: ${error.message}`);
                    }
                });
            }

            // íŠ¸ë™ ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ëŠ¥
            const btnLoadTracks = document.getElementById('btn-load-tracks');
            if (btnLoadTracks) {
                btnLoadTracks.addEventListener('click', async () => {
                    if (!currentProject) {
                        alert('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ë¡œë“œí•˜ì„¸ìš”.');
                        return;
                    }

                    try {
                        const response = await fetch(`/api/translator/projects/${currentProject.id}/load-tracks`);

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨');
                        }

                        const result = await response.json();

                        if (!currentProject.extra) {
                            currentProject.extra = {};
                        }
                        if (result.bgm_path) {
                            currentProject.extra.bgm_path = result.bgm_path;
                        }
                        if (typeof result.bgm_volume_percent !== 'undefined') {
                            currentProject.extra.bgm_volume_percent = result.bgm_volume_percent;
                        }
                        if (typeof result.bgm_cache_token !== 'undefined') {
                            currentProject.extra.bgm_cache_token = result.bgm_cache_token;
                        }
                        if (result.bgm_path) {
                            setBgmTrack(result.bgm_path, {
                                volumePercent: currentProject.extra.bgm_volume_percent ?? 100,
                                cacheToken: result.bgm_cache_token || Date.now(),
                                force: true,
                            });
                        } else {
                            setBgmTrack('', { force: true });
                        }

                        if (typeof result.bgm_v2_path !== 'undefined') {
                            if (result.bgm_v2_path) {
                                currentProject.extra.bgm_v2_path = result.bgm_v2_path;
                                currentProject.extra.bgm_custom_v2_path = result.bgm_v2_path;
                            } else {
                                delete currentProject.extra.bgm_v2_path;
                                delete currentProject.extra.bgm_custom_v2_path;
                            }
                        }
                        if (typeof result.bgm_v2_volume_percent !== 'undefined') {
                            currentProject.extra.bgm_v2_volume_percent = result.bgm_v2_volume_percent;
                        }
                        if (typeof result.bgm_v2_cache_token !== 'undefined') {
                            currentProject.extra.bgm_v2_cache_token = result.bgm_v2_cache_token;
                        }
                        if (typeof result.bgm_v2_path !== 'undefined') {
                            if (result.bgm_v2_path) {
                                setBgmV2Track(result.bgm_v2_path, {
                                    volumePercent: result.bgm_v2_volume_percent ?? 100,
                                    cacheToken: result.bgm_v2_cache_token || Date.now(),
                                    force: true,
                                });
                            } else {
                                setBgmV2Track('', { force: true });
                            }
                        }

                        if ('bgm_v2_auto_duck' in result) {
                            bgmV2AutoDuckEnabled = Boolean(result.bgm_v2_auto_duck);
                            currentProject.extra.bgm_v2_auto_duck = bgmV2AutoDuckEnabled;
                        } else {
                            bgmV2AutoDuckEnabled = false;
                            delete currentProject.extra.bgm_v2_auto_duck;
                        }
                        refreshBgmV2DuckState();

                        // ëŒ€ì‚¬ íŠ¸ë™ ë³µì›
                        if ('dialogue_path' in result) {
                            if (result.dialogue_path) {
                                currentProject.extra.dialogue_path = result.dialogue_path;
                            } else {
                                delete currentProject.extra.dialogue_path;
                            }
                        }

                        if (result.dialogue_path) {
                            const dialogueTrack = document.getElementById('timeline-track-dialogue');
                            if (dialogueTrack) {
                                dialogueTrack.style.display = 'block';

                                const dialogueWaveformContainer = document.getElementById('timeline-dialogue-waveform');
                                if (dialogueWaveformContainer && typeof WaveSurfer !== 'undefined') {
                                    dialogueWaveformContainer.innerHTML = '';
                                    const dialogueWaveform = WaveSurfer.create({
                                        container: '#timeline-dialogue-waveform',
                                        height: 90,
                                        waveColor: '#6ee7b7',
                                        progressColor: '#34d399',
                                        cursorColor: '#ffd166',
                                        normalize: true,
                                        responsive: true
                                    });
                                    const dialogueUrl = toWebAudioPath(result.dialogue_path);
                                    console.log('Loading saved dialogue track:', dialogueUrl);
                                    dialogueWaveform.on('error', (err) => {
                                        console.error('Saved dialogue waveform load error:', err);
                                    });
                                    dialogueWaveform.load(dialogueUrl);
                                    dialogueWaveform.on('ready', () => {
                                        const duration = dialogueWaveform.getDuration();
                                        const durationElem = document.getElementById('timeline-dialogue-duration');
                                        if (durationElem) {
                                            durationElem.textContent = formatDuration(duration);
                                        }
                                    });
                                    window.dialogueTimelineWaveform = dialogueWaveform;
                                    window.dialogueTimelineUrl = dialogueUrl;
                                }
                            }
                        }

                        // ë²ˆì—­ ì œì™¸ ëŒ€ì‚¬ íŠ¸ë™ ë³µì›
                        if ('dialogue_muted_path' in result) {
                            if (result.dialogue_muted_path) {
                                currentProject.extra.dialogue_muted_path = result.dialogue_muted_path;
                            } else {
                                delete currentProject.extra.dialogue_muted_path;
                            }
                        }

                        if (result.dialogue_muted_path) {
                            const dialogueMutedTrack = document.getElementById('timeline-track-dialogue-muted');
                            if (dialogueMutedTrack) {
                                dialogueMutedTrack.style.display = 'block';

                                const dialogueMutedWaveformContainer = document.getElementById('timeline-dialogue-muted-waveform');
                                if (dialogueMutedWaveformContainer && typeof WaveSurfer !== 'undefined') {
                                    dialogueMutedWaveformContainer.innerHTML = '';
                                    const dialogueMutedWaveform = WaveSurfer.create({
                                        container: '#timeline-dialogue-muted-waveform',
                                        height: 90,
                                        waveColor: '#fda4af',
                                        progressColor: '#fb7185',
                                        cursorColor: '#ffd166',
                                        normalize: true,
                                        responsive: true
                                    });
                                    const dialogueMutedUrlRaw = toWebAudioPath(result.dialogue_muted_path);
                                    const dialogueMutedUrl = `${dialogueMutedUrlRaw}?t=${Date.now()}`;
                                    console.log('Loading saved dialogue-muted track:', dialogueMutedUrl);
                                    dialogueMutedWaveform.on('error', (err) => {
                                        console.error('Saved dialogue-muted waveform load error:', err);
                                    });
                                    dialogueMutedWaveform.load(dialogueMutedUrl);
                                    dialogueMutedWaveform.on('ready', () => {
                                        const duration = dialogueMutedWaveform.getDuration();
                                        const durationElem = document.getElementById('timeline-dialogue-muted-duration');
                                        if (durationElem) {
                                            durationElem.textContent = formatDuration(duration);
                                        }
                                    });
                                    dialogueMutedWaveform.on('audioprocess', (time) => handleTimelineTimeUpdate('dialogue-muted', time));
                                    dialogueMutedWaveform.on('finish', () => handleTimelineFinish('dialogue-muted'));
                                    window.dialogueMutedTimelineWaveform = dialogueMutedWaveform;
                                    window.dialogueMutedTimelineUrl = dialogueMutedUrlRaw;
                                }
                            }
                        }

                        alert(result.message || 'íŠ¸ë™ì´ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } catch (error) {
                        console.error('Track load error:', error);
                        alert(`ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${error.message}`);
                    }
                });
            }
        }
    })();
    </script>

    <style>
        .segment-item.segment-playing {
            border-color: #4bd4ff !important;
            box-shadow: 0 0 12px rgba(75, 212, 255, 0.5);
            background: rgba(75, 212, 255, 0.08);
            transition: box-shadow 0.15s ease, background 0.15s ease;
        }

        .timeline-row.segment-playing {
            background: rgba(75, 212, 255, 0.16);
        }

        .comparison-timeline-panel {
            margin-top: 18px;
            padding: 18px;
            border-radius: 12px;
            border: 1px solid rgba(58, 91, 124, 0.85);
            background: rgba(16, 26, 38, 0.92);
            box-shadow: 0 12px 32px rgba(9, 15, 24, 0.35);
        }

        .timeline-title {
            margin: 0 0 12px 0;
            font-size: 1.05rem;
            color: #4bd4ff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-status {
            border-radius: 8px;
            background: rgba(83, 109, 173, 0.2);
            border: 1px solid rgba(83, 109, 173, 0.45);
            color: #bac8ff;
            font-size: 0.9rem;
            padding: 10px 12px;
            margin-bottom: 12px;
        }

        .timeline-track {
            margin-bottom: 18px;
        }

        .timeline-track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .timeline-track-header .track-label {
            font-weight: 600;
            color: #e4ecff;
        }

        .timeline-track-header .track-duration {
            font-size: 0.85rem;
            color: rgba(208, 219, 255, 0.75);
        }

        .waveform {
            width: 100%;
            height: 90px;
            background: rgba(10, 20, 32, 0.8);
            border-radius: 8px;
            border: 1px solid rgba(66, 94, 129, 0.6);
            overflow: hidden;
        }

        .timeline-control-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .timeline-control-row .btn-sm {
            background: rgba(45, 69, 102, 0.85);
            color: #d8e2ff;
            border: 1px solid rgba(78, 114, 164, 0.6);
        }

        .timeline-control-row .btn-sm:hover {
            background: rgba(68, 102, 150, 0.95);
        }

        .text-row.commentary {
            background: #f8f9ff;
            border-left: 3px solid #6c5ce7;
            padding-left: 10px;
            margin: 8px 0;
        }

        .text-row.commentary label {
            color: #6c5ce7;
            font-weight: bold;
        }

        .text-row.commentary .text-edit {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }

        .text-row.commentary .text-display {
            font-style: italic;
            color: #555;
            min-height: 20px;
        }

        .text-row.commentary .text-display:empty::before {
            content: 'í•´ì„¤ì„ ì…ë ¥í•˜ì„¸ìš”...';
            color: #999;
            font-style: italic;
        }

        #voice-synthesis-mode {
            padding: 6px 12px;
            border: 1px solid #252424;
            border-radius: 4px;
            background: white;
            color: #333;
        }

        #ai-commentary-section {
            border: 2px solid #007bff;
            border-radius: 10px;
            background: #f8fbff;
            box-shadow: 0 2px 10px rgba(0, 123, 255, 0.1);
        }

        #ai-commentary-section .panel-header h2 {
            color: #007bff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #ai-commentary-section .panel-header h2::before {
            content: 'ğŸ¤–';
            font-size: 1.2em;
        }

        .source-info {
            background: #f8f9fa;
            border: 1px solid #636161;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .source-details h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .source-details p {
            margin: 5px 0;
            color: #6c757d;
        }

        .ai-commentary-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        .ai-commentary-controls button {
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
        }

        .status-message {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            color: #1565c0;
            font-weight: bold;
        }

        .status-message p {
            margin: 0;
        }

        .selection-toolbar {
            background: #ffffff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .selection-summary {
            font-weight: bold;
            color: #000000;
            font-size: 14px;
        }

        .selection-summary #selected-count {
            color: #007bff;
            font-size: 16px;
            font-weight: bold;
        }

        .selection-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .selection-buttons button {
            background: #ffffff;
            color: #000000;
            border: 1px solid #333;
        }

        .selection-buttons button:hover {
            background: #f0f0f0;
            color: #000000;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            padding-top: 10px;
            border-top: 2px solid #333;
        }

        .bulk-actions label {
            font-weight: bold;
            color: #000000;
            margin: 0;
        }

        .bulk-actions select {
            min-width: 120px;
            background: #ffffff;
            color: #000000;
            border: 1px solid #333;
        }

        .bulk-actions button {
            background: #ffffff;
            color: #000000;
            border: 1px solid #333;
        }

        .bulk-actions button:hover {
            background: #f0f0f0;
            color: #000000;
        }

        .bulk-actions button.btn-primary,
        .audio-actions button.btn-primary {
            background: #007bff !important;
            color: #000000 !important;
            border: 1px solid #0056b3 !important;
        }

        .bulk-actions button.btn-primary:hover,
        .audio-actions button.btn-primary:hover {
            background: #0056b3 !important;
            color: #000000 !important;
        }

        .bulk-actions button.btn-success,
        .audio-actions button.btn-success {
            background: #28a745;
            color: #ffffff;
            border: 1px solid #218838;
        }

        .bulk-actions button.btn-success:hover,
        .audio-actions button.btn-success:hover {
            background: #218838;
            color: #ffffff;
        }

        .bulk-actions button.btn-danger,
        .audio-actions button.btn-danger {
            background: #dc3545;
            color: #ffffff;
            border: 1px solid #bd2130;
        }

        .bulk-actions button.btn-danger:hover,
        .audio-actions button.btn-danger:hover {
            background: #bd2130;
            color: #ffffff;
        }

        .segment-select {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
        }

        .segment-select-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .segment-index {
            font-weight: bold;
            min-width: 30px;
        }

        .btn-sm {
            padding: 4px 12px;
            font-size: 13px;
        }
    </style>
</body>
</html>
