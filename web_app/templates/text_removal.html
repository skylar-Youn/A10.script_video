<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>영상에서 글자 지우기</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        .canvas-wrapper {
            margin-top: 16px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #111;
            padding: 12px;
            display: none;
        }
        .canvas-wrapper.active {
            display: block;
        }
        #roi-canvas {
            max-width: 100%;
            border-radius: 4px;
            cursor: crosshair;
        }
        .canvas-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }
        .boxes-list {
            width: 100%;
            min-height: 80px;
            font-family: monospace;
        }
        .hidden {
            display: none !important;
        }
        .status-text {
            margin-top: 8px;
            font-size: 0.95rem;
            color: #9ad7ff;
        }
        .status-text.error {
            color: #ff8a8a;
        }
        .status-text.success {
            color: #8af5a6;
        }
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .form-grid label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-weight: 500;
        }
        .result-link {
            margin-top: 12px;
        }
        .result-link a {
            color: #8af5a6;
            text-decoration: underline;
        }
    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>영상에서 글자 지우기</h1>
        <nav class="nav-links">
            <a href="/ytdl" class="nav-link {% if nav_active == 'ytdl' %}active{% endif %}">⬇️ 다운로드 도구</a>
            <a href="/text-removal" class="nav-link {% if nav_active == 'text_removal' %}active{% endif %}">🧽 영상에서 글자 지우기</a>
            <a href="/analysis" class="nav-link">📊 분석 도구</a>
            <a href="/" class="nav-link">🏠 AI 쇼츠 메이커</a>
            <a href="/similarity" class="nav-link {% if nav_active == 'similarity' %}active{% endif %}">🎞️ 영상 유사도 검사</a>
            <a href="/copyright" class="nav-link {% if nav_active == 'copyright' %}active{% endif %}">🛡️ 저작권 검사</a>
        </nav>
        <p class="page-description">영상 첫 프레임에서 지울 영역을 직접 지정하고, Stable Diffusion 인페인팅 또는 OpenCV 배경 채우기로 텍스트를 제거해 보세요.</p>
    </header>

    <section class="panel">
        <h2>🧠 사용 흐름</h2>
        <ol>
            <li><strong>영상 업로드</strong>: 첫 프레임을 추출해 브라우저에서 바로 영역을 지정합니다.</li>
            <li><strong>영역 지정</strong>: 캔버스에서 드래그하여 지울 텍스트/워터마크 영역을 여러 개 그립니다.</li>
            <li><strong>글자 지우고 인페인팅 영상 복원</strong>: Stable Diffusion(runwayml/stable-diffusion-inpainting)으로 프레임 전체를 복원합니다.</li>
            <li><strong>글자를 배경색으로 가리기</strong>: OpenCV 인페인트를 활용해 지정한 박스를 주변 배경색으로 빠르게 덮습니다.</li>
        </ol>
        <p class="hint-text">처리에는 GPU가 권장됩니다. CPU 모드도 가능하지만 시간이 오래 걸릴 수 있습니다.</p>
    </section>

    <section class="panel">
        <h3>1️⃣ 영상 업로드 & 미리보기</h3>
        <form id="preview-form" class="text-removal-form" enctype="multipart/form-data">
            <div class="form-grid">
                <label>영상 파일 선택
                    <input type="file" id="video-file" name="video" accept="video/*" required>
                </label>
            </div>
            <div class="action-buttons">
                <button type="submit" class="primary">
                    <span class="label">첫 프레임 불러오기</span>
                    <span class="progress" id="preview-progress"></span>
                </button>
                <button type="button" id="split-media" class="secondary" disabled>
                    <span class="label">음성·영상·자막 분리</span>
                    <span class="progress" id="split-progress"></span>
                </button>
            </div>
            <div class="trim-controls">
                <div class="trim-inputs">
                    <label>시작 시간(초)
                        <input type="number" id="trim-start" value="0" min="0" step="0.1">
                    </label>
                    <label>잘라낼 길이(초)
                        <input type="number" id="trim-duration" value="4" min="0.1" step="0.1">
                    </label>
                    <button type="button" id="trim-preview" class="secondary" disabled>
                        <span class="label">선택 영상 미리보기 및 자르기</span>
                        <span class="progress" id="trim-progress"></span>
                    </button>
                    <button type="button" id="trim-download" class="secondary" disabled>
                        <span class="label">다른 이름으로 저장</span>
                    </button>
                </div>
                <p id="trim-status" class="status-text"></p>
                <div id="trim-preview-wrapper" class="trim-preview hidden">
                    <video id="trim-video" controls preload="metadata"></video>
                </div>
            </div>
            <p id="preview-status" class="status-text"></p>
        </form>

        <div id="canvas-wrapper" class="canvas-wrapper">
            <canvas id="roi-canvas" width="640" height="360"></canvas>
            <div class="canvas-controls">
                <div>
                    <strong>지정된 영역:</strong> <span id="box-count">0</span>개
                </div>
                <div>
                    <button type="button" id="undo-box" class="btn-secondary" disabled>마지막 영역 취소</button>
                    <button type="button" id="clear-boxes" class="btn-secondary" disabled>모두 초기화</button>
                </div>
            </div>
        </div>
    </section>

    <section class="panel hidden" id="process-panel">
        <h3>2️⃣ 인페인팅 설정</h3>
        <form id="process-form">
            <input type="hidden" id="session-id" name="session_id">
            <div class="form-grid">
                <label>Prompt
                    <input type="text" id="prompt" value="clean smooth surface, natural background, seamless texture">
                </label>
                <label>Negative Prompt
                    <input type="text" id="negative-prompt" value="text, watermark, caption, letters, words, characters">
                </label>
                <label>모델 ID
                    <select id="model-id">
                        <option value="stabilityai/stable-diffusion-2-inpainting" selected>SD 2.0 Inpainting (추천, 고품질)</option>
                        <option value="runwayml/stable-diffusion-inpainting">SD 1.5 Inpainting (빠름)</option>
                        <option value="diffusers/stable-diffusion-xl-1.0-inpainting-0.1">SDXL Inpainting (최고품질, 느림)</option>
                    </select>
                </label>
                <label>Guidance Scale
                    <input type="number" step="0.1" id="guidance-scale" value="7.5">
                </label>
                <label>Strength
                    <input type="number" step="0.05" min="0" max="1" id="strength" value="0.9">
                </label>
                <label>Diffusion Steps
                    <input type="number" min="1" max="100" id="inference-steps" value="30">
                </label>
                <label>Mask Dilate (px)
                    <input type="number" min="0" max="32" id="dilate" value="10">
                </label>
                <label>디바이스
                    <select id="device">
                        {% if torch_cuda_available %}
                        <option value="cuda">cuda (GPU)</option>
                        <option value="cpu">cpu</option>
                        {% else %}
                        <option value="cpu" selected>cpu</option>
                        <option value="cuda" disabled>cuda (GPU)</option>
                        {% endif %}
                    </select>
                </label>
                <label>dtype
                    <select id="dtype">
                        <option value="float16">float16</option>
                        <option value="float32">float32</option>
                    </select>
                </label>
                <label>Seed (선택)
                    <input type="number" id="seed" placeholder="랜덤">
                </label>
                <label>FPS Override (선택)
                    <input type="number" step="0.01" id="fps-override" placeholder="원본 유지">
                </label>
                <label>Max Frames (선택)
                    <input type="number" id="max-frames" placeholder="전체 처리">
                </label>
            </div>

            <label>영역 목록 (JSON)
                <textarea id="boxes-json" class="boxes-list" readonly></textarea>
            </label>

            <div class="action-buttons">
                <button type="submit" id="process-submit" class="primary" disabled>
                    <span class="label">글자 지우고 인페인팅 영상 복원</span>
                    <span class="progress" id="process-progress"></span>
                </button>
                <button type="button" id="fill-background" class="secondary" disabled>
                    <span class="label">글자를 배경색으로 덮어 가리기</span>
                    <span class="progress" id="fill-progress"></span>
                </button>
            </div>
            <p id="process-status" class="status-text"></p>
            <div id="result-link" class="result-link"></div>
        </form>
    </section>
</div>

<script>
(() => {
    const previewForm = document.getElementById('preview-form');
    const previewStatus = document.getElementById('preview-status');
    const previewSubmit = previewForm.querySelector('button[type="submit"]');
    const previewProgress = document.getElementById('preview-progress');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const canvas = document.getElementById('roi-canvas');
    const ctx = canvas.getContext('2d');
    const undoBtn = document.getElementById('undo-box');
    const clearBtn = document.getElementById('clear-boxes');
    const boxCount = document.getElementById('box-count');
    const processPanel = document.getElementById('process-panel');
    const sessionInput = document.getElementById('session-id');
    const boxesTextarea = document.getElementById('boxes-json');
    const processForm = document.getElementById('process-form');
    const processStatus = document.getElementById('process-status');
    const processSubmit = document.getElementById('process-submit');
    const fillBackgroundBtn = document.getElementById('fill-background');
    const splitMediaBtn = document.getElementById('split-media');
    const resultLink = document.getElementById('result-link');
    const processLabel = processSubmit.querySelector('.label');
    const processProgress = document.getElementById('process-progress');
    const fillLabel = fillBackgroundBtn.querySelector('.label');
    const fillProgress = document.getElementById('fill-progress');
    const splitLabel = splitMediaBtn.querySelector('.label');
    const splitProgress = document.getElementById('split-progress');
    const trimButton = document.getElementById('trim-preview');
    const trimLabel = trimButton.querySelector('.label');
    const trimProgress = document.getElementById('trim-progress');
    const trimDownloadButton = document.getElementById('trim-download');
    const trimStatus = document.getElementById('trim-status');
    const trimStartInput = document.getElementById('trim-start');
    const trimDurationInput = document.getElementById('trim-duration');
    const trimWrapper = document.getElementById('trim-preview-wrapper');
    const trimVideo = document.getElementById('trim-video');
    const DEFAULT_PROCESS_LABEL = processLabel.textContent.trim();
    const DEFAULT_FILL_LABEL = fillLabel.textContent.trim();
    const DEFAULT_SPLIT_LABEL = splitLabel.textContent.trim();
    const DEFAULT_TRIM_LABEL = trimLabel.textContent.trim();

    const promptInput = document.getElementById('prompt');
    const negativePromptInput = document.getElementById('negative-prompt');
    const modelInput = document.getElementById('model-id');
    const guidanceInput = document.getElementById('guidance-scale');
    const strengthInput = document.getElementById('strength');
    const stepsInput = document.getElementById('inference-steps');
    const dilateInput = document.getElementById('dilate');
    const deviceSelect = document.getElementById('device');
    const dtypeSelect = document.getElementById('dtype');
    const seedInput = document.getElementById('seed');
    const fpsInput = document.getElementById('fps-override');
    const maxFramesInput = document.getElementById('max-frames');

    let sessionId = null;
    let previewImage = new Image();
    let nativeWidth = 0;
    let nativeHeight = 0;
    let scale = 1;
    let boxes = [];
    let isDrawing = false;
    let startPoint = { x: 0, y: 0 };
    let tempPoint = { x: 0, y: 0 };
    let processingMode = null;

    function setStatus(el, message, type = '') {
        el.textContent = message || '';
        el.classList.remove('error', 'success');
        if (type) {
            el.classList.add(type);
        }
    }

function setProcessingState(mode, message = '') {
    processingMode = mode;
    const isDiffusion = mode === 'diffusion';
    const isFill = mode === 'fill';
    const isSplit = mode === 'split';
    const isTrim = mode === 'trim';

        processLabel.textContent = isDiffusion ? (message || '복원 중...') : DEFAULT_PROCESS_LABEL;
        processProgress.textContent = isDiffusion ? '진행 중...' : '';
        processSubmit.classList.toggle('is-processing', isDiffusion);

        fillLabel.textContent = isFill ? (message || '배경 채우는 중...') : DEFAULT_FILL_LABEL;
        fillProgress.textContent = isFill ? '진행 중...' : '';
        fillBackgroundBtn.classList.toggle('is-processing', isFill);

        splitLabel.textContent = isSplit ? (message || '분리 중...') : DEFAULT_SPLIT_LABEL;
        splitProgress.textContent = isSplit ? '진행 중...' : '';
        splitMediaBtn.classList.toggle('is-processing', isSplit);

        trimLabel.textContent = isTrim ? (message || '자르는 중...') : DEFAULT_TRIM_LABEL;
        trimProgress.textContent = isTrim ? '진행 중...' : '';
        trimButton.classList.toggle('is-processing', isTrim);

        if (mode) {
            processSubmit.disabled = true;
            fillBackgroundBtn.disabled = true;
            previewSubmit.disabled = true;
            splitMediaBtn.disabled = true;
            trimButton.disabled = true;
            trimDownloadButton.disabled = true;
        } else {
            const disabled = !sessionId || boxes.length === 0;
            processSubmit.disabled = disabled;
            fillBackgroundBtn.disabled = disabled;
            previewSubmit.disabled = false;
            splitMediaBtn.disabled = !sessionId;
            trimButton.disabled = !sessionId;
            trimDownloadButton.disabled = !trimVideo.src;
        }
}

    function resetTrimPreview() {
        if (!trimVideo.paused) {
            trimVideo.pause();
        }
        trimVideo.removeAttribute('src');
        trimVideo.load();
        trimWrapper.classList.add('hidden');
        setStatus(trimStatus, '');
        trimDownloadButton.disabled = true;
        delete trimDownloadButton.dataset.downloadUrl;
    }

    async function parseJSONResponse(response) {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
            try {
                return await response.json();
            } catch (error) {
                return { detail: '서버 응답을 해석하지 못했습니다.' };
            }
        }
        const text = await response.text();
        return { detail: text || response.statusText || '요청 처리 중 오류가 발생했습니다.' };
    }

    function renderResultLink(links, defaultLabel = '처리된 영상 내려받기') {
        if (!links) {
            resultLink.innerHTML = '';
            return;
        }
        const items = Array.isArray(links)
            ? links
            : [typeof links === 'string' ? { url: links, label: defaultLabel } : links];
        const markup = items
            .filter((item) => item && item.url)
            .map((item) => `<a href="${item.url}" target="_blank" rel="noopener">${item.label || defaultLabel}</a>`)
            .join(' ');
        resultLink.innerHTML = markup;
    }

    function serializeBoxes() {
        return boxes.map((box) => ({
            x: Math.round(box.x),
            y: Math.round(box.y),
            width: Math.round(box.width),
            height: Math.round(box.height),
        }));
    }

    function buildDiffusionPayload() {
        return {
            session_id: sessionId,
            prompt: promptInput.value.trim() || 'clean smooth surface, natural background, seamless texture',
            negative_prompt: negativePromptInput.value.trim() || 'text, watermark, caption, letters, words, characters',
            model_id: modelInput.value.trim() || 'stabilityai/stable-diffusion-2-inpainting',
            guidance_scale: parseFloat(guidanceInput.value) || 7.5,
            strength: Math.min(Math.max(parseFloat(strengthInput.value) || 0.9, 0), 1),
            num_inference_steps: Math.max(parseInt(stepsInput.value, 10) || 30, 1),
            dilate: Math.max(parseInt(dilateInput.value, 10) || 10, 0),
            device: deviceSelect.value,
            dtype: dtypeSelect.value,
            seed: seedInput.value ? parseInt(seedInput.value, 10) : null,
            fps: fpsInput.value ? parseFloat(fpsInput.value) : null,
            max_frames: maxFramesInput.value ? parseInt(maxFramesInput.value, 10) : null,
            boxes: serializeBoxes(),
        };
    }

    function buildFillPayload() {
        return {
            session_id: sessionId,
            dilate: Math.max(parseInt(dilateInput.value, 10) || 0, 0),
            fps: fpsInput.value ? parseFloat(fpsInput.value) : null,
            max_frames: maxFramesInput.value ? parseInt(maxFramesInput.value, 10) : null,
            boxes: serializeBoxes(),
        };
    }

    function updateBoxesUI() {
        boxesTextarea.value = JSON.stringify(boxes, null, 2);
        boxCount.textContent = boxes.length.toString();
        undoBtn.disabled = boxes.length === 0;
        clearBtn.disabled = boxes.length === 0;
        if (!processingMode) {
            const disabled = !sessionId || boxes.length === 0;
            processSubmit.disabled = disabled;
            fillBackgroundBtn.disabled = disabled;
            splitMediaBtn.disabled = !sessionId;
        }
        renderCanvas();
    }

    function renderCanvas(tempRect = null) {
        if (!previewImage.src) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(previewImage, 0, 0, canvas.width, canvas.height);

        ctx.lineWidth = 2;
        boxes.forEach((box) => {
            ctx.strokeStyle = 'rgba(0, 255, 180, 0.9)';
            ctx.fillStyle = 'rgba(0, 255, 180, 0.15)';
            ctx.beginPath();
            ctx.rect(box.x * scale, box.y * scale, box.width * scale, box.height * scale);
            ctx.fill();
            ctx.stroke();
        });

        if (tempRect) {
            ctx.strokeStyle = 'rgba(255, 200, 0, 0.9)';
            ctx.fillStyle = 'rgba(255, 200, 0, 0.2)';
            ctx.beginPath();
            ctx.rect(tempRect.x * scale, tempRect.y * scale, tempRect.width * scale, tempRect.height * scale);
            ctx.fill();
            ctx.stroke();
        }
    }

    function toVideoCoords(evt) {
        const rect = canvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) / scale;
        const y = (evt.clientY - rect.top) / scale;
        return {
            x: Math.min(Math.max(x, 0), nativeWidth),
            y: Math.min(Math.max(y, 0), nativeHeight),
        };
    }

    canvas.addEventListener('mousedown', (evt) => {
        if (!sessionId || !previewImage.src) return;
        isDrawing = true;
        startPoint = toVideoCoords(evt);
        tempPoint = { ...startPoint };
    });

    canvas.addEventListener('mousemove', (evt) => {
        if (!isDrawing) return;
        tempPoint = toVideoCoords(evt);
        const rect = normalizeRect(startPoint, tempPoint);
        renderCanvas(rect);
    });

    function normalizeRect(a, b) {
        const x = Math.min(a.x, b.x);
        const y = Math.min(a.y, b.y);
        const width = Math.abs(b.x - a.x);
        const height = Math.abs(b.y - a.y);
        return { x, y, width, height };
    }

    function finalizeRect() {
        if (!isDrawing) return;
        isDrawing = false;
        const rect = normalizeRect(startPoint, tempPoint);
        if (rect.width < 5 || rect.height < 5) {
            renderCanvas();
            return;
        }
        boxes.push(rect);
        updateBoxesUI();
    }

    canvas.addEventListener('mouseup', finalizeRect);
    canvas.addEventListener('mouseleave', () => {
        if (!isDrawing) return;
        finalizeRect();
    });

    undoBtn.addEventListener('click', () => {
        boxes.pop();
        updateBoxesUI();
    });

    clearBtn.addEventListener('click', () => {
        boxes = [];
        updateBoxesUI();
    });

    previewForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        renderResultLink(null);
        boxes = [];
        updateBoxesUI();
        setProcessingState(null);
        setStatus(processStatus, '');
        processSubmit.disabled = true;
        fillBackgroundBtn.disabled = true;
        resetTrimPreview();
        trimStartInput.value = '0';
        trimDurationInput.value = '4';
        trimButton.disabled = true;

        const fileInput = document.getElementById('video-file');
        if (!fileInput.files || fileInput.files.length === 0) {
            setStatus(previewStatus, '영상 파일을 선택하세요.', 'error');
            return;
        }

        const formData = new FormData();
        formData.append('video', fileInput.files[0]);
        setStatus(previewStatus, '미리보기를 생성하는 중...', '');
        previewProgress.textContent = '진행 중...';
        previewSubmit.disabled = true;
        splitMediaBtn.disabled = true;

        try {
            const response = await fetch('/api/text-removal/preview', {
                method: 'POST',
                body: formData,
            });

            const data = await parseJSONResponse(response);
            if (!response.ok) {
                const message = (data && typeof data === 'object' && data.detail)
                    ? data.detail
                    : '미리보기를 생성하지 못했습니다.';
                throw new Error(message);
            }

            sessionId = data.session_id;
            sessionInput.value = sessionId;

            nativeWidth = data.width;
            nativeHeight = data.height;
            scale = Math.min(720 / nativeWidth, 1);
            canvas.width = Math.round(nativeWidth * scale);
            canvas.height = Math.round(nativeHeight * scale);

            previewImage = new Image();
            previewImage.onload = () => {
                canvasWrapper.classList.add('active');
                processPanel.classList.remove('hidden');
                updateBoxesUI();
            };
            previewImage.src = data.preview_image;

            setStatus(previewStatus, '미리보기가 준비되었습니다. 캔버스에서 영역을 지정하세요.', 'success');
            previewProgress.textContent = '완료';
            previewSubmit.disabled = false;
            splitMediaBtn.disabled = false;
            trimButton.disabled = false;
        } catch (error) {
            sessionId = null;
            sessionInput.value = '';
            previewImage = new Image();
            canvasWrapper.classList.remove('active');
            processPanel.classList.add('hidden');
            setStatus(previewStatus, error.message || '미리보기를 생성하지 못했습니다.', 'error');
            previewProgress.textContent = '';
            previewSubmit.disabled = false;
            splitMediaBtn.disabled = true;
            trimButton.disabled = true;
            resetTrimPreview();
        }
    });

trimButton.addEventListener('click', async () => {
        if (!sessionId) {
            setStatus(trimStatus, '먼저 영상을 업로드하고 미리보기를 생성하세요.', 'error');
            return;
        }

        const start = Number(trimStartInput.value ?? 0);
        const duration = Number(trimDurationInput.value ?? 0);
        if (Number.isNaN(start) || start < 0) {
            setStatus(trimStatus, '시작 시간은 0 이상이어야 합니다.', 'error');
            return;
        }
        if (Number.isNaN(duration) || duration <= 0) {
            setStatus(trimStatus, '잘라낼 길이는 0보다 커야 합니다.', 'error');
            return;
        }

        resetTrimPreview();
        setStatus(trimStatus, '영상 자르는 중...', '');
        setProcessingState('trim', '트리밍 중...');

        try {
            const response = await fetch('/api/text-removal/trim', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: sessionId,
                    start,
                    duration,
                }),
            });
            const data = await parseJSONResponse(response);
            if (!response.ok) {
                const message = (data && typeof data === 'object' && data.detail)
                    ? data.detail
                    : '영상 자르기에 실패했습니다.';
                throw new Error(message);
            }

            const videoUrl = `${data.video_url}?v=${Date.now()}`;
            trimStartInput.value = (data.start ?? start).toString();
            trimDurationInput.value = (data.duration ?? duration).toString();
            trimVideo.src = videoUrl;
            trimVideo.load();
            trimWrapper.classList.remove('hidden');
            trimVideo.play().catch(() => {});
            setStatus(
                trimStatus,
                `시작 ${Number(trimStartInput.value).toFixed(2)}초, 길이 ${Number(trimDurationInput.value).toFixed(2)}초로 잘랐습니다.`,
                'success',
            );
            trimDownloadButton.disabled = false;
            trimDownloadButton.dataset.downloadUrl = videoUrl;
        } catch (error) {
            setStatus(trimStatus, error.message || '영상 자르기에 실패했습니다.', 'error');
        } finally {
            setProcessingState(null);
        }
});

trimDownloadButton.addEventListener('click', () => {
    if (!trimDownloadButton.dataset.downloadUrl) {
        return;
    }

    const url = trimDownloadButton.dataset.downloadUrl;
    const fileName = prompt('저장할 파일 이름을 입력하세요 (확장자 제외)', 'trimmed_clip');
    if (fileName === null) {
        return;
    }

    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = `${fileName || 'trimmed_clip'}.mp4`;
    document.body.appendChild(anchor);
    anchor.click();
    document.body.removeChild(anchor);
});

    splitMediaBtn.addEventListener('click', async () => {
        if (!sessionId) {
            setStatus(previewStatus, '먼저 영상을 업로드하고 미리보기를 생성하세요.', 'error');
            return;
        }

        setProcessingState('split', '분리 중...');
        setStatus(processStatus, '영상에서 음성, 영상, 자막을 분리하는 중입니다...', '');
        renderResultLink(null);

        try {
            const response = await fetch('/api/text-removal/split-media', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    session_id: sessionId,
                }),
            });

            const data = await parseJSONResponse(response);
            if (!response.ok) {
                const message = (data && typeof data === 'object' && data.detail)
                    ? data.detail
                    : '미디어 분리에 실패했습니다.';
                throw new Error(message);
            }

            setStatus(processStatus, '음성·영상·자막 분리가 완료되었습니다!', 'success');
            splitProgress.textContent = '완료';
            const links = [];
            if (data.audio_url) {
                links.push({ url: data.audio_url, label: '음성 트랙 다운로드' });
            }
            if (data.video_url) {
                links.push({ url: data.video_url, label: '영상(무음) 다운로드' });
            }
            if (data.subtitle_url) {
                links.push({ url: data.subtitle_url, label: '자막 다운로드' });
            }
            renderResultLink(links);
        } catch (error) {
            setStatus(processStatus, error.message || '미디어 분리 중 오류가 발생했습니다.', 'error');
        } finally {
            setTimeout(() => {
                setProcessingState(null);
                updateBoxesUI();
            }, 600);
        }
    });

    processForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!sessionId) {
            setStatus(processStatus, '먼저 영상을 업로드하고 미리보기를 생성하세요.', 'error');
            return;
        }
        if (boxes.length === 0) {
            setStatus(processStatus, '인페인팅할 영역을 최소 한 개 이상 지정하세요.', 'error');
            return;
        }

        setProcessingState('diffusion', '복원 중...');
        setStatus(processStatus, 'Stable Diffusion으로 영상을 복원하는 중입니다. 시간이 다소 걸릴 수 있습니다...', '');
        renderResultLink(null);

        const payload = buildDiffusionPayload();

        try {
            const response = await fetch('/api/text-removal/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            const data = await parseJSONResponse(response);
            if (!response.ok) {
                const message = (data && typeof data === 'object' && data.detail)
                    ? data.detail
                    : '영상 복원에 실패했습니다.';
                throw new Error(message);
            }

            setStatus(processStatus, '영상 복원이 완료되었습니다!', 'success');
            processProgress.textContent = '완료';
            renderResultLink(data.video_url, '복원된 영상 내려받기');
        } catch (error) {
            setStatus(processStatus, error.message || '영상 복원 중 오류가 발생했습니다.', 'error');
        } finally {
            setTimeout(() => {
                setProcessingState(null);
                updateBoxesUI();
            }, 600);
        }
    });

    fillBackgroundBtn.addEventListener('click', async () => {
        if (!sessionId) {
            setStatus(processStatus, '먼저 영상을 업로드하고 미리보기를 생성하세요.', 'error');
            return;
        }
        if (boxes.length === 0) {
            setStatus(processStatus, '먼저 가릴 영역을 지정하세요.', 'error');
            return;
        }

        setProcessingState('fill', '배경 채우는 중...');
        setStatus(processStatus, 'OpenCV 인페인트로 텍스트 영역을 배경에 맞춰 덮는 중입니다...', '');
        renderResultLink(null);

        const payload = buildFillPayload();

        try {
            const response = await fetch('/api/text-removal/fill-background', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            const data = await parseJSONResponse(response);
            if (!response.ok) {
                const message = (data && typeof data === 'object' && data.detail)
                    ? data.detail
                    : '배경 채우기에 실패했습니다.';
                throw new Error(message);
            }

            setStatus(processStatus, '배경 가리기가 완료되었습니다!', 'success');
            fillProgress.textContent = '완료';
            renderResultLink(data.video_url, '배경 처리된 영상 내려받기');
        } catch (error) {
            setStatus(processStatus, error.message || '배경 채우기 중 오류가 발생했습니다.', 'error');
        } finally {
            setTimeout(() => {
                setProcessingState(null);
                updateBoxesUI();
            }, 600);
        }
    });
})();
</script>
</body>
</html>
