# 키워드 기반 스토리 생성기 사양서

## 0. 시장 조사 & UX 인사이트
- **창작 도구 벤치마킹**: Jasper AI(스토리 아이디어 생성), Notion AI(문서 내 인라인 편집), Canva Video Suite(타임라인 기반 쇼츠 제작) UI를 조사하여, "빠른 아이디어 제안 → 즉시 편집 → 멀티 포맷 내보내기" 흐름이 핵심이라는 점을 확인했다.
- **사용자 인터뷰 참고**: Product Hunt 및 Reddit 커뮤니티(예: r/VideoEditing) 피드백에 따르면, AI가 만든 결과를 "부분 수정" 하고 "여러 결과를 한 흐름으로 이어붙이는" 기능에 대한 수요가 높다.
- **디자인 가이드라인**: Material Design 3, Nielsen Norman Group의 오류 메시지/피드백 규칙을 참고하여, 즉각적인 피드백과 명확한 상태 표시(로딩/성공/실패)를 UI의 필수 요구사항으로 반영한다.
- **경쟁 제품의 차별점**: 기존 유사 서비스들이 JSON 다운로드 위주로 결과를 제공하는 데 반해, 본 프로젝트는 UI 상에서 바로 편집·병합이 가능하도록 인터랙션을 강화한다.

## 1. 개요
- **목적**: 키워드 또는 이미지 설명을 입력받아 스토리 제목, 쇼츠용 대본, 이미지 프롬프트 등을 자동 생성하고, 결과를 파일 및 Google Sheets로 관리하는 Python 애플리케이션을 개발한다.
- **참고 자료**:
  - `86.wsl_stroy_gptapi_excel2googleokk.py`: `.env` 로드, OpenAI 응답 처리, 구글 스프레드시트 연동, 엑셀 저장 로직 참고.
  - `all.txt`: OpenAI `responses.create` 호출 예시 및 다양한 프롬프트 요구사항.
- **산출물**: CLI/웹 UI를 통해 입력과 출력을 제어할 수 있는 Python 패키지 + 실행 스크립트.

## 2. 기능 요구사항
### 2.1 입력 옵션
1. **스토리 키워드 입력** (필수)
   - 단일 키워드 또는 간단한 문장 형태.
   - UI에서 텍스트 필드 제공.
   - 최근 사용한 키워드 목록(최대 10개) 저장 및 재사용.
2. **이미지 설명 입력** (선택)
   - 이미지 기반 제목 생성 모듈에서 사용.
   - 미입력 시 키워드 기반 제목만 생성.
3. **선택적 옵션**
   - 생성 개수(기본 30개, 10~50 범위).
   - 출력 언어(기본 한국어, 영어/일본어 등 확장 가능).
   - 쇼츠 대본 길이(기본 60초, 30~90초 범위).
   - Google Sheets 저장 여부, 로컬 파일 저장 형식 (XLSX/SRT/TXT/JSON).

### 2.2 생성 모듈
| 모듈 | 설명 | 관련 프롬프트 | 출력 형식 |
| --- | --- | --- | --- |
| **KeywordTitleGenerator** | 키워드를 바탕으로 30개 스토리 제목 생성 | `all.txt` 1번 | 번호+제목 리스트 |
| **ImageTitleGenerator** | 이미지 설명 기반 제목 30개 생성 | `all.txt` 2번 | 번호+제목 리스트 |
| **ShortsScriptGenerator** | 키워드 기반 SRT 형식 대본 + 이미지 묘사 생성 | `all.txt` 3번 | `SRT` + 이미지 묘사 목록 |
| **ShortsSceneGenerator** | 쇼츠 대본 + 영상 장면 프롬프트 | `all.txt` 4번 | `SRT` + 씬별 프롬프트 |
| **StoryAssembler** | 선택한 제목·대본 조각을 이어 붙여 장/단편 스토리로 병합 | 사용자 입력 + `all.txt` 변형 | Markdown/TXT |
| **(확장)** Keyword Outline/Blog | 기존 스크립트의 블로그 목차/키워드 추출 모듈과 연동 가능 | `86...py` | 엑셀/시트 |

각 모듈은 공통 OpenAI 클라이언트를 사용하며, 프롬프트 템플릿은 `prompts.py`에 상수로 정의한다.

### 2.3 편집·스토리 빌드
- 결과 항목별 인라인 편집 지원(제목 텍스트, 대본 문장, 이미지 프롬프트). 수정 시 실시간 미리보기, Ctrl+Z/Shift+Ctrl+Z 단축키 제공. 변경 내역은 히스토리 패널로 자동 기록.
- 항목 삭제/복원 기능 제공: 휴지통 탭에 최근 50개 항목 보관, 24시간 후 자동 폐기. 휴지통에서도 바로 StoryAssembler로 끌어다 쓸 수 있도록 허용.
- StoryAssembler:
  - "초안", "메인 스토리" 두 개의 컬럼 보드 구성. 초안 컬럼에는 생성된 조각이 자동 배치되고, 메인 스토리 컬럼으로 옮기면 최종 스토리에 포함된다.
  - 결과 리스트에서 드래그 앤 드롭으로 순서를 재배치하며, 다중 선택(Shift+클릭)과 블록 이동 지원.
  - 서로 다른 모듈의 조각(예: 제목 + SRT 일부 + 이미지 묘사)을 하나의 스토리 챕터로 병합. 병합 시 챕터 메모/톤(감성, 장르) 설정 필드 노출.
  - 연결부/전환 문장을 AI에게 추가로 요청하는 버튼 제공(선택한 두 챕터 사이에 삽입).
  - 최종 스토리 분량을 글자 수, 예상 재생 시간(60초 스크립트 기준)으로 동시 표시하고, 목표 범위를 벗어나면 경고 색상 표시.
- 스토리 버전 관리: 저장 시 `v1`, `v2` 식의 버전 번호 자동 부여. 각 버전은 비교 보기(차이 강조), 이전 버전으로 복원, 주석 달기 기능 포함.
- 각 단계별 "재생성" 버튼 제공: 키워드→스토리, 스토리→자막/이미지 프롬프트, 자막/프롬프트→영상 초안. 재생성 시 이전 결과는 히스토리에 보관하고 새 카드로 분리 표시.
- "스텝 리플로우" 기능: 특정 단계에서 편집/삭제를 수행하면 이후 단계(예: 영상 초안)에서 자동으로 변동 사항을 반영하도록 트리거. 사용자는 "자동 반영" 또는 "수동 반영" 중 선택할 수 있다.
- 자막·음성·장면 동시 편집: 듀얼 타임라인을 제공하여 텍스트 자막, 음성 파형, 이미지/영상 프레임을 한 화면에서 조정. 각 요소 위에 실시간 타임스탬프 오버레이를 띄워 현재 위치를 정확히 확인하며, 싱크 맞춤, 구간 삭제, 구간 복제, 구간 교체(재생성) 옵션을 동일 패널에서 처리한다.
- 미디어 프롬프트 카드 클릭 시 우측 프리뷰 패널에 장면 설명/카메라 정보를 표시하고, 필요한 경우 바로 편집/삭제/재생성으로 분기할 수 있도록 한다.

### 2.4 출력 및 저장
- 결과 화면(UI)에서 탭 또는 아코디언으로 모듈별 결과 및 StoryAssembler 출력 표시.
- 다운로드 옵션(기본값은 사람이 읽기 쉬운 형식):
  - 제목 목록: CSV/TXT (필수), JSON은 개발자 옵션으로 숨김 메뉴에 배치.
  - 쇼츠 대본: SRT/TXT.
  - 이미지 프롬프트: Markdown/TXT(기본), 필요 시 JSON으로 추가 내보내기.
  - 이어붙인 스토리: Markdown/PDF(선택), Word(.docx) 내보내기 확장 고려.
- `save_manager.py`를 통해 다음 기능 제공:
  - 로컬 저장: `outputs/{YYYYMMDD_HHMMSS}/` 구조.
  - `86...py` 참고하여 Google Sheets (`gspread`) 동기화 (테이블 데이터만 저장).
  - 저장 내역 로컬 DB(JSON 또는 SQLite)로 기록하여 UI에서 히스토리 조회 및 버전 비교.

### 2.5 오류 및 예외 처리
- `.env` 미존재 시 경고 후 대체 경로(기존 스크립트와 동일) 탐색.
- OpenAI 호출 실패 시 재시도 로직(최대 3회, exponential backoff).
- Google 인증 실패 시 UI 알림 + 로컬 저장만 수행.
- 필수 입력 누락 시 UI에서 즉시 검증.
- 응답 포맷 파싱 실패 시 원본 텍스트도 함께 저장하여 누락 방지.

### 2.6 단계별 워크플로우 & 재생성 규칙
1. **키워드 → 스토리 생성**
   - 입력: 키워드/이미지 설명/추가 옵션.
   - 출력: 제목 리스트, 스토리 초안(요약), 장면 리스트.
   - UI: 결과 카드당 `편집`, `삭제`, `재생성`, `다른 버전 보기` 버튼. 재생성 시 동일 입력(또는 수정된 프롬프트)으로 새 카드 생성.
2. **스토리 → 자막 & 이미지 프롬프트 경로**
   - 입력: 선택된 스토리 카드.
   - 출력: SRT 자막, 이미지 프롬프트(씬별).
   - UI: 자막 카드와 이미지 카드가 페어링되어 링크됨. 한쪽을 수정하면 다른쪽에 영향 여부를 선택할 수 있는 토글 제공.
   - 재생성: 특정 장면만 선택하여 자막 또는 이미지 프롬프트 재생성 가능.
3. **스토리 → 자막 & 영상 프롬프트 경로**
   - 입력: 선택된 스토리 카드.
   - 출력: SRT 자막, 영상 씬 프롬프트.
   - UI: 영상 프롬프트 카드에는 카메라, 톤, 소품 등을 태그로 제공. 재생성시 태그 단위 수정 지원.
   - 자막과 영상 프롬프트는 동기화 뷰에서 동시에 편집 가능.
4. **자막/음성/장면 동시 편집**
   - 자막을 편집하면 즉시 음성 합성 재생성을 제안(선택사항).
   - 음성 파형 구간을 조정하면 해당 구간 자막 타임스탬프가 자동 조정되며, 필요 시 롤백 가능.
   - 이미지/영상 장면 교체 시 링크된 자막 또는 음성 구간을 유지/재생성 선택 팝업 제공.
   - 실시간 미리보기 캔버스에서 현재 타임스탬프의 자막, 음성, 이미지/영상 프레임을 동시에 출력하며, 편집 내용이 즉시 반영된다.
5. **영상 생성 & 이어붙이기**
   - 입력: 편집 완료된 자막/음성/장면 세트.
   - 출력: 영상 클립, 또는 StoryAssembler 타임라인에서의 여러 클립.
   - UI: 타임라인 상에서 클립 재생성(프롬프트 수정), 클립 삭제, 구간 이동, 전환 효과 적용을 모두 드래그/컨텍스트 메뉴로 수행.
   - 여러 영상 프로젝트 간 클립 선택 후 이어붙이기 가능하며, 자동으로 자막/음성 트랙을 정렬한다.
6. **단계별 상태 추적**
   - 각 카드/클립은 "초안", "편집 중", "승인", "재생성 중" 상태를 가진다.
   - 사용자는 각 단계에서 `재생성`, `편집`, `삭제`를 반복 수행할 수 있으며, 모든 변경은 히스토리와 버전 로그에 기록된다.

### 2.7 미디어 효과 & 텍스트 템플릿 요구사항
- **이미지/영상 효과 (10종 최소 제공)**
  1. 좌측에서 우측으로 팬(Pan Left→Right)
  2. 우측에서 좌측으로 팬(Pan Right→Left)
  3. 상단에서 하단으로 패닝(Pan Top→Bottom)
  4. 줌 인(Ken Burns Zoom In)
  5. 줌 아웃(Ken Burns Zoom Out)
  6. 패럴랙스(전경/배경 분리 후 서서히 이동)
  7. 모자이크 인/아웃(Mosaic reveal/hide)
  8. 컬러 시프트(Color grade warm↔cool 교차)
  9. 글리치 효과(짧은 노이즈+RGB 분리)
 10. 페이드+블러 전환(Fade with blur)
  - 모든 효과는 효과 패널에서 미리보기 가능하며, 타임라인에서 구간별로 드래그하여 적용/제거할 수 있다.

- **화면 템플릿 (5종 이상)**
  - 공통 구조: 상단 30~40% 영역은 제목 전용, 하단 60~70% 영역은 설명/자막 전용.
  - 템플릿 샘플 예시
    1. `Clean Split`: 상단 중앙 정렬 제목, 하단 좌측 정렬 자막.
    2. `Bold Banner`: 상단 컬러 배너 형태, 하단 투명 배경 위 자막.
    3. `Shadow Card`: 상단 반투명 카드, 하단 섀도우 박스 자막.
    4. `Subtitle Focus`: 상단 작은 제목, 하단 큰 자막 박스(대사 강조).
    5. `Dual Column`: 상단 제목 + 부제 구역, 하단 자막과 이미지 캡션 2열 구성.
  - 템플릿 선택 시 즉시 미리보기 캔버스에서 반영되고, 타임라인에 있는 모든 장면에도 일괄 적용 또는 개별 적용 옵션 제공.

- **텍스트 위치/크기/효과 (10종)**
  - 제목 및 자막 텍스트의 위치는 드래그 앤 드롭 또는 좌표 입력으로 조정 가능하며, 실시간 프리뷰 캔버스에서 확인.
  - 글자 크기는 슬라이더 또는 직접 입력을 통해 변경, 변경 즉시 프리뷰에 반영.
  - 제공 효과 예시 (최소 10개):
    1. 기본(Normal)
    2. 아웃라인(Outline)
    3. 그림자(Drop Shadow)
    4. 네온(Glow)
    5. 그라디언트 채우기(Gradient Fill)
    6. 타자기 애니메이션(Typewriter)
    7. 파도(Wave)
    8. 펄스(Pulse)
    9. 흔들림(Shake)
   10. 페이드 인/아웃(Fade)
  - 각 효과는 지속 시간과 강도를 조절할 수 있으며, 효과 패널에서 여러 효과를 조합 적용할 수 있도록 레이어링 기능 제공.

## 3. 시스템 구성
### 3.1 파일 구조 (제안)
```
keywordimagestory/
  ├── __init__.py
  ├── main.py                # CLI 진입점
  ├── app.py                 # 웹 UI 진입점 (FastAPI + Jinja or Streamlit)
  ├── config.py              # .env 로드, 경로/상수 관리
  ├── openai_client.py       # OpenAI 래퍼 (responses/chat 둘 다 지원)
  ├── prompts.py             # all.txt 기반 프롬프트 템플릿
  ├── generators/
  │     ├── base.py
  │     ├── keyword_titles.py
  │     ├── image_titles.py
  │     ├── shorts_script.py
  │     ├── shorts_scene.py
  │     └── story_assembler.py
  ├── services/
  │     ├── save_manager.py
  │     ├── sheet_service.py
  │     ├── history_service.py
  │     └── editor_service.py
  ├── ui/
  │     ├── __init__.py
  │     ├── fastapi_app.py   # if FastAPI 선택
  │     ├── templates/
  │     │     ├── base.html
  │     │     └── index.html
  │     └── static/
  └── outputs/ (gitignore)
```

### 3.2 모듈 간 흐름
1. `config.py`: `.env`에서 API 키, 구글 자격증 등 로드 (`86...py`와 동일 로직 포함).
2. `main.py/app.py`: UI에서 입력 수집 후 `generators` 호출.
3. 각 `Generator`는 `prompts.py` 템플릿과 입력을 결합하여 `openai_client` 호출.
4. 결과를 구조화(`dataclasses` 또는 `pydantic` 모델)하여 `services`에 전달.
5. `editor_service`가 편집/삭제/버전 관리 로직을 담당하고, `save_manager`가 파일/Sheets 저장, `history_service`가 메타데이터 기록.

### 3.3 데이터 모델 (예시)
```python
@dataclass
class TitleItem:
    index: int
    text: str
    source: Literal["keyword", "image"]

@dataclass
class SubtitleSegment:
    index: int
    start: str
    end: str
    text: str
    scene_tag: str

@dataclass
class ImagePrompt:
    tag: str
    description: str

@dataclass
class StoryChapter:
    order: int
    source_id: str  # 생성 결과 식별자
    text: str
    metadata: dict[str, Any]

@dataclass
class MediaEffect:
    effect_id: str
    name: str
    parameters: dict[str, Any]
    start_time: float
    end_time: float

@dataclass
class TemplateSetting:
    template_id: str
    title_position: tuple[float, float]
    subtitle_position: tuple[float, float]
    title_style: dict[str, Any]
    subtitle_style: dict[str, Any]
```

## 4. UI 요구사항
### 4.1 정보 구조
- 상단: 프로젝트 설명, API 상태 표시.
- 좌측(또는 상단): 입력 폼
  - 키워드 필드 + 최근 사용 드롭다운
  - 이미지 설명 필드 + 이미지 업로드(선택, 추후 확장)
  - 생성 옵션(체크박스/슬라이더)
  - 실행 버튼 (생성 모듈별 토글)
- 우측(또는 하단): 결과 탭
  - `제목 생성` 탭: 키워드/이미지 결과 표 + 인라인 수정/삭제 아이콘
  - `쇼츠 대본` 탭: SRT 뷰어 (타임라인 카드) + 문장 편집/삭제/시간 조정 UI
  - `씬 프롬프트` 탭: 씬별 카드 + 편집/삭제 버튼, 라벨 재지정
  - `스토리 빌더` 탭: 드래그 앤 드롭 리스트, 전환문 생성 버튼, 버전 히스토리 패널
  - `동시 편집` 탭: 자막 텍스트, 음성 파형, 이미지/영상 썸네일 3분할 뷰. 구간 선택 시 하이라이트 동기화.
  - `템플릿 & 효과` 패널: 좌측에 5가지 화면 템플릿 썸네일, 우측에 선택된 템플릿의 글자 위치/크기 슬라이더 및 10종 텍스트 효과 토글. 실시간 미리보기에서는 현재 타임스탬프 기준으로 적용된 템플릿과 효과가 즉시 반영된다.
  - 프롬프트 프리뷰 패널: 타임라인 요소 클릭 시 이미지/영상 설명, 카메라 설정, 적용 효과를 카드 형식으로 표시하고 즉시 수정/삭제 동작 제공.
  - 다운로드 버튼(파일 형식 선택 커스텀 드롭다운)
- 하단: 저장 히스토리(최근 5개, 재다운로드 버튼)

### 4.2 UI 기술 스택 제안
- **FastAPI + Jinja2 + HTMX/SortableJS**: 기존 프로젝트(`ai_shorts_maker`)와 유사한 스택 활용 + 클라이언트 드래그 기능 지원.
- 대안: Streamlit (빠른 프로토타입), 하지만 저장/히스토리 관리가 필요하다면 FastAPI 권장.
- 공통 컴포넌트
  - 입력 검증: 브라우저 측(HTML5) + 서버 측(pydantic 모델)
  - 로딩 인디케이터 및 오류 알림 모달
  - 반응형 디자인 (모바일/PC 지원)
  - 동시 편집 뷰: Wavesurfer.js(음성 파형), Konva.js(씬 타임라인), CodeMirror(자막 편집) 등을 조합한 컴포넌트 사용 제안.
  - 텍스트/템플릿 편집: Fabric.js 또는 Canvas API를 활용해 드래그 가능한 텍스트 박스와 실시간 스타일 조합 제공.

### 4.3 인터랙션 상태 & 피드백
- **상태 배지**: 각 결과 카드 상단에 `새로 생성`, `수정됨`, `삭제 예정`, `스토리에 포함` 등의 라벨을 컬러 코드로 표시.
- **실시간 저장 알림**: StoryAssembler 보드에서 변경 시 우측 상단 토스트로 “임시 저장 완료” 메시지 표시, 5초 후 자동 숨김.
- **모달/사이드패널**: 상세 편집(예: 장면별 이미지를 교체) 시 전체 화면 모달 대신 우측 슬라이드 패널을 사용하여 맥락을 유지.
- **에러 처리**: Material Snackbar 패턴 적용. 재시도 버튼을 메시지 내부에 배치, 실패 시 관련 로그 ID 링크 제공.
- **협업 대비**: 추후 다중 사용자 편집을 고려해 “다른 세션에서 수정됨” 경고 토스트 레이아웃 사전 정의.
- **효과 미리보기**: 템플릿/텍스트/영상 효과 변경 시 1초 내 프리뷰 영상을 재렌더링 하여 애니메이션을 확인할 수 있도록 로더와 진행 상태를 표시.
- **정렬 미리보기**: 자막/음성/이미지/영상 바를 하나의 오버레이 트랙에 겹쳐서 렌더링하고, 겹치는 구간은 빨간색 윤곽선으로 강조한다.

### 4.4 접근성 & 사용성 원칙
- 대비비율 4.5:1 이상 유지, 키보드 탭 순서 명시. StoryAssembler 드래그 앤 드롭은 키보드 명령(↑/↓, 스페이스 선택)으로도 조작 가능해야 한다.
- 스크린리더용 레이블: 각 카드에 `aria-label` 제공(예: “제목 카드 3, 수정됨, 스토리 미포함”).
- 모션 민감도를 위한 “애니메이션 축소” 옵션 제공시 CSS `prefers-reduced-motion` 적용.
- 저장/삭제와 같이 파괴적 행동에는 확인 대화상자 + Undo 토스트 제공.
- 텍스트 크기/위치 조정 슬라이더는 키보드로도 미세 조정할 수 있도록 하고, 프리뷰 캔버스에 실시간으로 좌표/크기 안내선을 표시.

## 5. 비기능 요구사항
- **성능**: OpenAI API 호출 후 응답 파싱까지 평균 3초 이내 목표 (모듈당).
- **안정성**: API 실패 대응 재시도, 예외 로깅 (`logging` 모듈 → 파일 저장).
- **보안**: API 키는 `.env`로 관리, 저장 결과에 민감 정보 없음.
- **국제화**: UI/출력 기본 한국어, 확장 가능하도록 상수 분리.
- **테스트**: 프롬프트 템플릿 문자열 테스트, 파서(Unit Test), 저장 서비스 Mock 테스트.

## 6. 개발 단계 제안
1. **환경 설정**: `.env` 템플릿, `requirements.txt` (openai, python-dotenv, gspread, fastapi 등).
2. **OpenAI 클라이언트 래퍼**: `responses.create`와 `chat.completions.create` 둘 다 지원.
3. **프롬프트 템플릿 정의**: `all.txt` 내용을 구조화하여 상수화.
4. **Generator 개발**: 모듈별 호출 및 응답 파싱.
5. **저장 서비스 구현**: 엑셀/시트/파일 아웃풋.
6. **UI 구성**: 입력 폼, 결과 탭, 다운로드.
7. **통합 테스트**: 실제 키로 단일 플로우 검증, 오류 케이스 점검.
8. **배포 문서화**: README + 사용 가이드.

## 7. 사용자 여정 & 주요 시나리오
1. **신규 아이디어 발굴**
   - 사용자가 키워드를 입력하고 즉시 `KeywordTitleGenerator`를 실행.
   - 결과 카드에서 마음에 드는 제목을 선택, 인라인으로 몇 단어 수정.
   - 수정된 제목을 StoryAssembler 초안 컬럼으로 보냄.
2. **영상 스크립트 제작**
   - 동일 키워드를 바탕으로 `ShortsScriptGenerator` 실행 → SRT 카드가 생성.
   - 각 자막 카드에서 시간 범위와 텍스트를 조정, 필요 시 삭제.
   - 조정된 카드들을 StoryAssembler 메인 컬럼으로 드래그.
3. **스토리 이어 붙이기**
   - StoryAssembler에서 제목 카드와 자막 카드를 순서대로 배치.
   - 두 카드 사이에서 "전환 문장 생성" 버튼 클릭 → AI가 연결 내레이션 제안.
   - 제안된 문장을 편집 후 "메인 스토리에 추가".
4. **내보내기 & 공유**
   - 최종 스토리 프리뷰 확인.
   - SRT + Markdown + PDF 동시 다운로드.
   - Google Sheets에 제목 목록만 보내고, 로컬 outputs 폴더에는 전체 패키지 저장.
5. **영상 프롬프트 기반 워크플로우**
   - 키워드 입력 후 `ShortsSceneGenerator`로 영상 장면 프롬프트 생성.
   - 동시에 간단한 쇼츠 대본을 자동 생성하여 "프롬프트+대본" 쌍을 카드로 제공.
   - 사용자가 특정 씬을 편집(삭제/수정/복제)하고, AI에게 재생성 요청 시 전체 프롬프트 대신 선택한 씬만 갱신.
   - 편집된 프롬프트와 대본을 StoryAssembler에 배치한 뒤, "영상 합성" 작업을 요청하면 MoviePy 또는 외부 영상 생성기 API에 전달.
   - 이후 "템플릿 & 효과" 패널에서 장면별 화면 템플릿과 텍스트 효과를 선택, 실시간 미리보기로 확인 후 전체 또는 특정 장면에 적용.
6. **영상 이어붙이기 시나리오**
   - 여러 프로젝트에서 만든 영상 clips 또는 생성된 씬 영상을 StoryAssembler의 "영상 타임라인" 섹션에 드래그.
   - 타임라인에서 컷 길이를 조정, 전환(페이드, 슬라이드) 적용.
   - 자막/음성 동기화 패널에서 각 클립에 대응하는 자막 번들을 확인하고, 수정 사항이 있을 경우 즉시 반영.
   - 필요 시 "빈 씬 추가" 버튼으로 중간에 AI 프롬프트 기반 새로운 영상 생성 요청.
   - 최종 렌더링 전, "마스터 프리뷰"로 전체 영상/자막 싱크를 점검.
   - 각 클립에는 10종 이미지/영상 효과 중 하나 이상을 적용할 수 있으며, 적용 영역이 타임라인 위에 하이라이트되어 편집/삭제가 용이하다.
   - 정렬 미리보기 트랙을 통해 겹침을 확인하고, 필요 시 "AI 자동 정렬" 버튼으로 모든 트랙의 시작/종료 시간을 균등 재분배한다.
7. **재생성 & 편집 루프**
   - 사용자가 특정 단계 결과에 만족하지 않을 경우 해당 카드의 "재생성" 메뉴에서 전/후 단계 옵션을 선택.
   - 재생성 시 기존 버전은 히스토리에 보관되며, 새 카드가 생성되어 StoryAssembler 초안 컬럼에 추가.
   - 편집·삭제·복원 버튼은 모든 카드(제목, 자막, 이미지, 영상)에 공통으로 위치하고, 키보드 단축키(Del, Ctrl+Enter)로도 작동.
   - UI는 각 스텝에서 현재 사용 중인 버전을 강조 표시하고, 필요한 경우 이전 버전과 비교하여 변경 사항을 플로팅 패널로 보여준다.

## 8. 향후 확장 아이디어
- 이미지 생성(AI) 연동(DALL·E, Sora 등)하여 씬 프롬프트 자동 비주얼 생성.
- 키워드 분석(검색량 API) 추가하여 SEO 중심의 제목 필터링.
- 다국어 지원 / 번역 파이프라인 연결 (`ai_shorts_maker.translator` 참조).
- 팀 협업을 위한 결과 공유(노션 API, Slack 알림 등).

## 9. 참고 자료
- Jasper AI Story Writer 제품 페이지(https://www.jasper.ai/) – 아이디어 생성 흐름 및 템플릿 기반 UX 참고.
- Canva Video Suite(https://www.canva.com/features/video-editor/) – 타임라인 인터랙션 및 멀티형식 내보내기 UI 참고.
- Notion AI 업데이트 블로그(https://www.notion.so/blog/ai-workflow) – 인라인 편집 경험 및 협업 패턴 분석.
- Nielsen Norman Group: Error Message Guidelines(https://www.nngroup.com/articles/error-message-guidelines/) – 사용자 피드백 설계 기준.

## 10. 구현 로드맵 (Next Steps)
1. **와이어프레임 제작**
   - `동시 편집` 타임라인(자막/음성/장면 3분할)과 `템플릿 & 효과` 패널 구조를 Figma 등으로 스케치.
   - 타임스탬프 표기, 효과 적용 인터랙션, 텍스트 위치 조정 UI를 포함한 상태 다이어그램 작성.
2. **프리뷰 프로토타입**
   - Fabric.js + Canvas로 텍스트 템플릿 미리보기, Wavesurfer.js로 음성 파형, Konva.js로 장면 타임라인을 결합한 Proof of Concept 구현.
   - 실시간 편집 반영(자막 수정, 효과 토글, 텍스트 위치 변경)이 1초 이내로 렌더링 되는지 검증하고, 병목 지점 로깅.
3. **API 계약 정의**
   - `MediaEffect` 적용/제거, `TemplateSetting` CRUD, 타임라인 재생성 요청 등의 엔드포인트 스펙 정의 (요청/응답 JSON, 상태 코드, 오류 메시지 포함).
   - 이후 백엔드 구현에 앞서 Postman/Swagger로 문서화하고, 단위 테스트 케이스 초안 작성.
- **타임라인 정렬 & 자동 보정**
  - 이미지/영상 프롬프트를 추가하면 즉시 타임라인에 반영되고 동일한 챕터 번호로 묶인다.
  - 자막·음성·이미지·영상 각각을 가로 바 형태의 "정렬 미리보기" 트랙에 표시하여 겹침 여부를 시각적으로 확인한다.
  - "AI 자동 정렬" 버튼을 제공하여 기본 길이(예: 60초)를 기준으로 각 요소의 시작/종료를 균등 분배하며 겹침을 최소화한다. 정렬 결과는 실시간 미리보기와 프리뷰 패널에 즉시 반영된다.
